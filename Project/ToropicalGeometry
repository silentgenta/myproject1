/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1ï¼ˆå®‹å…ˆç”Ÿã®å®šç¾©ã«å¿ å®Ÿã«å¾“ã£ãŸ(å¯æ›ãª)Semiringã®å®šç¾©ï¼‰
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

--ã¤ã„ã§ã«åŠä½“ã‚’å®šç¾©
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

--åŠ æ³•çš„å†ªç­‰ã®å®šç¾©
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

--Ex2.1.2 ğ”¹=({0,-âˆ},max,+)ã¯åŠä½“ã§ã‚ã‚‹
inductive ğ”¹ : Type
| negInf
| zero

/-
ã¤ã‘ã¦ãŠãã¨ã„ã„ã“ã¨ãŒã‚ã‚‹ã¨GPTã‹ã‚‰ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Š
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

/- åŠ æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0 : ğ”¹) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- ä¹—æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1 : ğ”¹) (fun _ s => s * a)

--Def2.1.3(åŠç’°æº–åŒå‹ã®å®šç¾©)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--ä»Šå¾ŒãŸã ã®æ§‹é€ ã ã£ã¦Semiringhomomorphismã‚’é–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã„ã¡ã„ã¡f.toFun xã¨æ›¸ã‹ãªãã‚ƒã„ã‘ãªããªã‚‹ã€‚
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

--simpã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--æ’ç­‰æº–åŒå‹ã®å®šç¾©
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--æº–åŒå‹ã®åˆæˆã®å®šç¾©ã€‚åŠç’°æº–åŒå‹ã«å¿…è¦ãªï¼•è¦ç´ ã‚’é †ã«è¨¼æ˜
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgã¯ä¸¡è¾ºã«åŒã˜é–¢æ•°ã‚’é©ç”¨ã—ã¦ã‚ˆã„ã¨ã„ã†è£œé¡Œã€‚f.map_addã®ä¸¡è¾ºã«gã‚’é©ç”¨ã—ãŸã¨ã„ã†ã“ã¨
      _ = g (f a) + g (f b) := by --_ã¯g (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism
--10/9
--Sâ‚ä»£æ•°ã®å®šç¾©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©
--semiringhomoã«ã¯åå‰ã®ã¤ã„ã¦ã„ãªã„é–¢æ•°ãŒã‚ã‚‹ã®ã§ãã‚Œã‚’Î¨ã¨åä»˜ã‘ã‚‹ã€‚

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--Aã¨Bã®é–“ã«å¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’ä¸€ã¤å–ã‚Šå‡ºã™ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚reducibleã«ã™ã‚‹ã“ã¨ã§algeMapã‚’ä½¿ã†ã¨è‡ªå‹•ã§h.homã®ã‚ˆã†ãªå¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’å‘¼ã³å‡ºã—ã¦ãã‚Œã‚‹ã€‚

--simpç”¨
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-ä»£æ•°æº–åŒå‹ã®å®šç¾©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A â†’ X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A â†’ Y
    --åˆæˆã‚’ç¤ºã—ã¦ã„ã‚‹(fã¨toHomã®åˆæˆãŒgã¨ç­‰ã—ããªã‚‹ã€‚)
namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å¯æ›å›³å¼--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)  --Aâ†’X(algebraMap)â†’Y(h.toHom)ã¨ã„ã†å†™åƒã®åˆæˆã«aã‚’é©ç”¨
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g ã« a ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) h.comm
  --congrArgã¯ä¸¡è¾ºã«åŒã˜é–¢æ•°ã‚’é©ç”¨ã™ã‚‹ã¨ãã«ä½¿ã†ã‚³ãƒãƒ³ãƒ‰ã€‚ä»Šå›ã¯ã€Œaã‚’é©ç”¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨è‡ªä½“ãŒé–¢æ•°ã«ãªã£ã¦ã„ã¦ã€ãã‚Œã‚’h.comm(ä¸Šã®AlgHomã®ä¸­ã«ã‚ã‚‹comm)

end AlgHom


--A-ä»£æ•°æº–åŒå‹ã®å­˜åœ¨
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y
  --åå‰ã®è¡çªã‚’é˜²ããŸã‚ã«scopedã‚’ã¤ã‘ã¦ãŠãã€‚ä»Šå¾Œã¯openã€€scoped TGAlgRelã¨æ›¸ãã¨TropicalGeometry.AlgebraRel A X Y ã‚’çœç•¥ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚(åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®å‚ç…§)ã‚‚å¯èƒ½

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--å…·ä½“çš„ãª Î¨ ã¨å¯æ›æ€§(Î¨ ãŒã‚ã£ã¦ã€å¯æ›æ€§ã‚‚è¨¼æ˜ã§ããŸãªã‚‰AlgebraRel A X Yã¯å­˜åœ¨ã—ã¾ã™ã‚ˆã­ã€ã¨ã„ã†è£œé¡Œ)
theorem intro
  (Î¨ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Î¨
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  âŸ¨Î¨, hâŸ©
  --âˆƒ Î¨, P Î¨ã¨ã„ã†å½¢ã®å‘½é¡Œã€‚ã‚ˆã£ã¦ã€âŸ¨ âŸ©ã§å…·ä½“çš„ãªå†™åƒã¨ä»®å®šã‚’ãƒšã‚¢ã§ç¾…åˆ—ã™ã‚‹ã“ã¨ã§å­˜åœ¨ã®è¨¼æ˜ã¯å®Œäº†ã™ã‚‹ã€‚

--ã²ã¨ã¤Î¨ã‚’å–ã‚Šå‡ºã™ã€‚ 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H
--defã¯Hã‹ã‚‰å…·ä½“çš„ãªå†™åƒÎ¨ã‚’å–ã‚Šå‡ºã™æ“ä½œã‚’è¡Œã†ãŸã‚ã®å®šç¾©ã€‚é¸æŠå…¬ç†ã«ä¾å­˜ã—ã¦ã„ã‚‹ã®ã§noncomputableã§å®šç¾©ã™ã‚‹ã€‚ä½¿ã†éš›ã¯Open classicalã«ã™ã‚Œã°ã‚ˆã„ã€‚

--psiHã§å–ã‚Šå‡ºã—ãŸÎ¨ãŒå›³å¼ã‚’å¯æ›ã«ã™ã‚‹ã€‚ 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--å¯æ›æ€§ã®ç‚¹ã”ã¨ver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commã§å¯æ›å›³å¼ã®é–¢æ•°ã®ç­‰å¼ã‚’å–ã‚Šå‡ºã—ã¦congrArgã§aã‚’é©ç”¨ã™ã‚‹ã ã‘
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) hc

end AlgebraRel

-- A-ä»£æ•°åŒå‹ã®å®šç¾©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- äº’ã„ã«é€†ï¼ˆAlgHom ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ toHom ã‚’ä¸€åº¦ã ã‘å–ã‚Šå‡ºã—ã¦ä½¿ã†ï¼‰
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
      --invHom.toHomã¨toHom.toHomã®åˆæˆã§æ’ç­‰å†™åƒã‚’ä½œã‚Šå‡ºã™ã€‚invHomã§AlgIsoã‹ã‚‰AlgHomã‚’å–ã‚Šå‡ºã—ã€toHomã§AlgHomã‹ã‚‰Semiringhomomorphismã‚’å–ã‚Šå‡ºã™æµã‚Œã€‚ï¼ˆAlgHomã«ã‚‚å®šç¾©ãŒã‚ã‚‹ã®ã§ã“ã‚Œã¯å…¥ã‚Œå­æ§‹é€ ï¼‰
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- åŒå‹ã®é †æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- åŒå‹ã®é€†æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv âˆ˜ eã¯identity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idã«xã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism X X) => Ï† x) e.left_inv

--e âˆ˜ e.invã¯identity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idã«yã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism Y Y) => Ï† y) e.right_inv

--å¯¾ç§°æ€§
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--10/17
--ğ”¹ã®å°å…¥
instance : Semiring ğ”¹ where
  mul_zero := by intro a ; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  --<;>ã§ç›´å¾Œã®ã‚¿ã‚¯ãƒ†ã‚£ã‚¯ã‚’å…¨ã¦ã®ã‚´ãƒ¼ãƒ«ã«é©ç”¨ã§ãã‚‹ã€‚
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl


--#check tauto


--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl

--AãŒåŠ æ³•å†ªç­‰ã®ã¨ãï¼Œğ”¹ â†’ Aã§åŠç’°æº–åŒå‹ã¨ãªã‚‹
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ --ã©ã®é–¢æ•°ã‚’å¯¾è±¡ã«ã™ã‚‹ã‹ã‚’æŒ‡å®šã™ã‚‹ã€‚-âˆã‚’0ã«å¯¾å¿œã•ã›ã€0ã‚’-1ã«å¯¾å¿œã•ã›ã‚‹ã€‚
  toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1,

  --F(x + y) = F x + F yã‚’ç¤ºã™ã€‚x,yã®çµ„ã¿åˆã‚ã›ã«ã¯4é€šã‚Šã‚ã‚‹ã®ã§ã€ä»¥ä¸‹ã®4ã¤ã‚’
  map_add := by
    intro x y
    --x,yã§ç·å½“ãŸã‚Šã‚’è¡Œã†ã€‚
    cases x <;> cases y <;> simp
    /-Â· -- F(-âˆ + -âˆ)ï¼š0 = 0 + 0
      exact (zero_add (0 : A)).symm
    Â· -- F(-âˆ + 0)ï¼š1 = 0 + 1
      exact (zero_add (1 : A)).symm
    Â· -- F(0 + -âˆ)ï¼š1 = 1 + 0
      exact (add_zero (1 : A)).symm-/
    Â· -- F(0 + 0)ï¼š1 = 1 + 1ï¼ˆå†ªç­‰æ€§ï¼‰
      exact (h (1 : A)).symm,

  --F(xy) = F(X)F(y)ã‚’ç¤ºã™ã€‚
  map_mul := by
    intro x y
    cases x <;> cases y 
    Â· -- F(-âˆ * -âˆ)ï¼š0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    Â· -- F(-âˆ * 0)ï¼š0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    Â· -- F(0 * -âˆ)ï¼š0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    Â· -- F(0 * 0)ï¼š1 = 1 * 1
      exact (one_mul (1 : A)).symm,

  --ğ”¹ ã§ã¯ 0 : ğ”¹ = ğ”¹.negInfã€ 1 : ğ”¹ = ğ”¹.zero ãŒæ—¢ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§å…¥ã£ã¦ã„ã‚‹.
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 ã€ŒA ãŒåŠ æ³•å†ªç­‰ã€â†”ã€ŒA ãŒ ğ”¹-ä»£æ•°ï¼ˆå­˜åœ¨ã™ã‚‹ï¼‰ã€ -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· -- (â†’) åŠ æ³•å†ªç­‰ â‡’ ğ”¹-ä»£æ•°ãŒå­˜åœ¨
    intro h
    --Algebra.ofHomã¯æº–åŒå‹å†™åƒã‹ã‚‰ğ”¹ä»£æ•°ã®æ§‹é€ ã‚’ä½œã£ã¦ãã‚Œã‚‹ã€‚æº–åŒå‹å†™åƒã¯boolHomOfAddIdemã§æŒ‡å®šã—ã¦ã‚ã’ã‚‹ã€‚
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©

  Â· -- (â†) ğ”¹-ä»£æ•°ãŒå­˜åœ¨ â‡’ åŠ æ³•å†ªç­‰
    intro hAlg
    --nonemptyã®çŠ¶æ…‹ã«å…·ä½“çš„ã«ã©ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚‹ã‹ã‚’ä¸ãˆã¦ã„ã‚‹ã€‚Tactic stateã®instã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹Semiringã‚’ç”¨ã„ã¦å…·ä½“çš„ã«ä¸€ã¤æŠ½å‡ºã™ã‚‹ã€‚
    rcases hAlg with âŸ¨instâŸ©
    -- Ïˆ : ğ”¹ â†’ Aã‚’æŒ‡å®šã—ã¦ã‚ã’ã‚‹ã€‚Algebraã®classã‚’å‚ç…§ã™ã‚‹ã¨.homãŒã‚ã‚‹ã®ã§ã€instã‚’æŒ‡å®šã—ã¦å†™åƒã‚’å–ã‚Šå‡ºã™ã€‚
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    -- 1_A = 1_A + 1_Aã‚’ä½œã‚‹ã€‚
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)      -- Ïˆ(1+1) = Ïˆ1 + Ïˆ1
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        --B_one_add_oneã§1+1=1ãªã®ã§ã€Î¨(1+1)=Î¨(1)ãŒè¨€ãˆã‚‹ã€‚h0ã‚‚åˆã‚ã›ã‚‹ã“ã¨ã§è¨¼æ˜ãŒå®Œäº†ã™ã‚‹ã€‚
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    -- ä»»æ„ã® a ã«ã¤ã„ã¦ a + a = a
    intro a
    -- a*1 = a*1 + a*1 ã‚’ä½œã‚‹ï¼ˆå·¦åˆ†é…ã¨ h11Aï¼‰
    have hmul : a * 1 = a * 1 + a * 1 := by
      --Semiring.left_distribã§ a*(1+1) = a*1 + a*1 ã«å¯¾ã—ã¦ï¼Œ(1+1) â†’ 1 ã¸æ›¸ãæ›ãˆh11Aã‚’ä¸¡è¾ºå…¥ã‚Œæ›¿ãˆã¦é©ç”¨ã€‚
     simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- ã‚ã¨ã¯ mul_one ã§ä»•ä¸Šã’
    -- ï¼ˆå‘ãã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¯¾ç§°ã‚’å–ã‚‹ï¼‰
    --have : a + a = a := by
    simpa [mul_one] using hmul.symm
    --exact this



--â‰¤â‚ã®å®šç¾©

section OrderFromAddIdem

variable {A : Type u} [Semiring A]

--a â‰¤â‚ bã‚’a + b = bã¨ã™ã‚‹ã€‚
def leA (a b : A) : Prop := a + b = b

--åå°„å¾‹
theorem leA_refl (h : AddIdempotent A) (a : A) : leA a a := by
  unfold leA
  simpa using h a

--æ¨ç§»å¾‹
theorem leA_trans (a b c : A)
    (hab : leA  a b) (hbc : leA  b c) :
    leA  a c := by
  unfold leA at * -- hab hbc âŠ¢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--åå¯¾ç§°å¾‹
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at * -- hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0ã¯æœ€å°å…ƒ
theorem bot_leA (a : A) : leA  (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA  a b) :
    leA  (c * a) (c * b) := by
  unfold leA at * -- hab âŠ¢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

--10/31
universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  âˆ€ â¦ƒa b c : Aâ¦„, a * b = a * c â†’ a = (0 : A) âˆ¨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--ã“ã‚“ã”ä¾¿åˆ©ã«ãªã‚‹è£œé¡Œ
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a â‰  (0 : A)) (hmul : a * b = a * c) : b = c := by
  --a=0ã‹b=cã®ã©ã¡ã‚‰ã‹ã—ã‹ãªã„ã“ã¨ã‚’ç¤ºã™ä»®å®šã‚’å…¥ã‚Œã‚‹ã€‚
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  --h'ã«å ´åˆåˆ†ã‘ã‚’å…¥ã‚Œã‚‹
  rcases h' with hzero | hbc
  --a=0ã®å ´åˆçŸ›ç›¾ãŒèµ·ã“ã‚‹ã®ã§æ’çœŸã§ã‚ã‚‹ã“ã¨ã‚’åˆ©ç”¨ã—ã¦è¨¼æ˜ã‚’å®Œäº†ã•ã›ã‚‹ã€‚haã¨hzeroã«å¯¾ã—ã¦.elimã‚’ç”¨ã„ã¦å®Œäº†ã€‚(False).elimã®å½¢ã§ã‚«ãƒƒã‚³å†…ã®çŸ›ç›¾ã‹ã‚‰ã‚ã‚‰ã‚†ã‚‹å‘½é¡Œã‚’å°ã‘ã‚‹ã€‚
  Â· exact (ha hzero).elim
  --è‡ªæ˜ã€‚
  Â· exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--åˆ†æ¯ãŒ 0 ã§ãªã„çµ„ (a,b)ã®é›†åˆã‚’å®šç¾©ã€‚//ã¯å‰ã«æ›¸ã‹ã‚ŒãŸæƒ…å ±ã«æ¡ä»¶ã‚’ä»˜ã‘åŠ ãˆã‚‹éš›ã«ç”¨ã„ã‚‰ã‚Œã‚‹è¡¨è¨˜æ³•ã€‚ä»Šå›ã¯p(çœç•¥ã•ã‚Œã¦ã„ã‚‹ãŒæ­£ã—ãã¯p.1ï¼‰ã«p.2(p.1ã®äºŒã¤ç›®ã®å…ƒã«å¯¾ã™ã‚‹æ¡ä»¶ãªã®ã§æ­£ç¢ºã«ã¯p.1.2)ã®æ¡ä»¶ã‚’ä»˜ã‘ãã‚ãˆã¦ã„ã‚‹ã€‚
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A Ã— A // p.2 â‰  (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- åˆ†å­
def num (p : FracCarrier A) : A := p.1.1
-- åˆ†æ¯
def den (p : FracCarrier A) : A := p.1.2

/-æ•´ç†ã—ãŸã‚‚ã®ãŒä»¥ä¸‹
p : { p : A Ã— A // p.2 â‰  0 }

p.1        : A Ã— A        -- (a, b)
p.1.1      : A            -- a
p.1.2      : A            -- b
p.2        : p.1.2 â‰  0    
-/

--åˆ†æ•°ã‚’ä½œæˆã—ãŸæ™‚ã«ãã®åˆ†æ¯ã¨åˆ†å­ãŒä½•ã§ã‚ã‚‹ã‹ã‚’å¼•ãå‡ºã™ãŸã‚ã®è£œé¡Œ
--åˆ†å­
@[simp] lemma num_mk (a b : A) (hb : b â‰  0) :
    num (A:=A) âŸ¨(a,b), hbâŸ© = a := rfl
--åˆ†æ¯
@[simp] lemma den_mk (a b : A) (hb : b â‰  0) :
    den (A:=A) âŸ¨(a,b), hbâŸ© = b := rfl

--åˆ†æ•°ã‚’å®šç¾©ã—ãŸæ™‚ã«åˆ†æ¯ãŒï¼ã§ãªã„ã“ã¨ã‚’åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®è£œé¡Œ
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p â‰  0 := p.2

--p=a/b q=x/dã®æ™‚ã€p=qã‚’ad=bcã¨ã„ã†å½¢ã§è¡¨ç¾ã™ã‚‹ãŸã‚ã®å®šç¾©
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--åå°„å¾‹
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--å¯¾ç§°å¾‹
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q p := by
  --h.symmã¯Relã§å±•é–‹ã™ã‚‹ã¨q.num * p.den = p.num * q.denãªã®ã§ã€mulcommã§å…¥ã‚Œæ›¿ãˆã‚Œã°è‰¯ã„ã€‚
  intro h; simpa [Rel, mul_comm] using h.symm

--æ¨ç§»å¾‹
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q r â†’ Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q â‰  (0 : A) := den_ne_zero (A:=A) q

  -- q.den * (p.num * r.den) = r.den * (q.num * p.den)ã‚’ä½œã‚‹
  have h1 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    --(num p * den q) * den r = (num q * den p) * den rã‚’ä½œã‚‹ã€‚
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    grind
    /-calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl --assosiativeã¨commtativeã‚’è²«é€šã™ã‚‹ä¾¿åˆ©ãªrflãŒac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl-/

  -- â‘¡ q.den * (r.num * p.den) = r.den * (q.num * p.den)ã‚’ä½œã‚‹
  have h2 :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    grind
    /-calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl-/

  -- h1ã¨h2ã®å³è¾ºãŒç­‰ã—ã„ã“ã¨ã‚’ç”¨ã„ã¦q.denã‚’æ¶ˆå»ã§ãã‚‹å½¢ã«ã™ã‚‹ã€‚
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1.trans h2.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aã®Relã¯ï¼ˆcancellativeã®ä¸‹ã§ï¼‰åŒå€¤é–¢ä¿‚ã«ãªã‚‹ã€‚  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)  --åŒå€¤ã¨ä¸»å¼µã—ãŸã„é–¢ä¿‚ã‚’æŒ‡å®š
  iseqv :=
    âŸ¨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) âŸ©

/-
structure Setoid (Î± : Sort u) where
  r     : Î± â†’ Î± â†’ Prop
  iseqv : Equivalence rã€€--Equivalenceã¯reflã¨symmã¨transã‚’å«ã‚€æ§‹é€ ãªã®ã§3ã¤ã®å¼•æ•°ã‚’æŒã¤ã€‚

-/

end FracCarrier

open Classical
--11/7
--å•†é›†åˆ Q(A) ã‚’ä½œã‚Šã€è¦ç´ ã‚’a/bã¨æ›¸ã‘ã‚‹ã‚ˆã†ã«ã™ã‚‹ 

section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- Q(A) := {(a,b) | b â‰  0}/âˆ¼ã€€ã™ãªã‚ã¡a/bã‚’ä½œã‚‹ã€‚Quotã¯ã‚ã‚‹å‹Î±ã¨ã€ãã®å‹ã®ä¸Šã®åŒå€¤é–¢ä¿‚rã‚’ä¸ãˆã¦rã§å‰²ã£ãŸå•†é›†åˆã‚’ä½œã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ã€‚å‹ã¯setoidã®äºŒã¤ã®Î±ã§ã€åŒå€¤é–¢ä¿‚ã¯setoidãã®ã‚‚ã®ã€‚
def Q : Type u := Quot (FracCarrier.setoid (A:=A) hC)
--Quot.{u} {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) : Sort u

-- Q.mk a b hb ã¨æ›¸ãã“ã¨ã§a/b ã®åŒå€¤é¡ãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ãŸã„ã€‚ä¸Šè¨˜ã®Qã¯ãŸã ã®å‹ã®ã¾ã¾ãªã®ã§å…·ä½“çš„ãªå€¤ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒå‡ºæ¥ãªã„ã€‚æ¯å›Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(a,b), hbâŸ©ã¨æ›¸ãã®ã¯é¢å€’ãªã®ã§å®šç¾©ã™ã‚‹ã€‚
def Q.mk (a b : A) (hb : b â‰  0) : Q (A:=A) hC :=
  Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(a,b), hbâŸ©

-- Quot.mk.{u} {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Quot r


-- åˆ†æ¯ãŒ0ã§ãªã„ã¨ã„ã†æƒ…å ±ã‚’ä½¿ã„ã‚„ã™ãã™ã‚‹ãŸã‚ã«structureã‚’ç”¨æ„ã—ã¦ãŠãã€‚(NonZeroDen)
structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val â‰  0

namespace Q

-- NZDenã§åˆ†æ¯ãŒï¼ã§ãªã„çŠ¶æ…‹ãŒä¿éšœã•ã‚Œã¦ã„ã‚‹å ´åˆã«ãƒšã‚¢(åŒå€¤é¡)ã‚’ä½œã‚‹ãŸã‚ã®å®šç¾©
def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-
Leanã§ã¯æ¼”ç®—ã®å„ªå…ˆé †ä½ã‚’æ•°å€¤ã§å®šç¾©ã—ã¦ã„ã‚‹ã€‚ãŸã ã€æ¼”ç®—ã‚’è‡ªç”±ã«è¿½åŠ ã§ãã‚‹ã‚ˆã†ã«ä½™è£•ã‚’ã‚‚ã£ã¦æ•°å€¤ã¯å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
ä¾‹ã‚’æŒ™ã’ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚
ã¹ãä¹—ï¼šï¼˜ï¼
æ›ã‘ç®—å‰²ã‚Šç®—ï¼šï¼—ï¼
è¶³ã—ç®—å¼•ãç®—ï¼šï¼–ï¼•
ã‚¤ã‚³ãƒ¼ãƒ«ã€‚å¤§ãªã‚Šå°ãªã‚Šï¼šï¼•ï¼
ã‚ã‚‹æ¼”ç®—å­ã‚’å®šã‚ãŸã¨ãã«ã¯ä¸€ç•ªå³ã«è¨˜å…¥ã•ã‚ŒãŸæ•°å€¤ãŒãã®æ¼”ç®—ã®å„ªå…ˆé †ä½ã¨ãªã‚‹ã€‚ä»¥ä¸‹ã®notationã§ã¯ï¼—ï¼‘ãŒæ¼”ç®—ã®å„ªå…ˆé †ä½ã¨ãªã‚‹ã€‚71ã«ã—ãŸã®ã¯åˆ†å­ã¯å‰ã«ã¤ã„ãŸæ›xã‘ç®—ã‚’å·»ãè¾¼ã‚“ã§ã»ã—ã„ãŒã€åˆ†æ¯ã¯å¾Œã‚ã«ã¤ã„ãŸæ›ã‘ç®—ã‚’å·»ãè¾¼ã‚€ã¨äº‹æ•…ç™ºç”Ÿã«ãªã‚‹ãŸã‚ã€‚
æ¼”ç®—ã®å„ªå…ˆåº¦ã‚’71ã«ã™ã‚‹ã“ã¨ã§/ã¯
+ï¼ˆ65ï¼‰ã‚ˆã‚Šå¼·ã„ â†’ a / b + c ã¯ (a / b) + c ã¨èª­ã¾ã‚Œã‚‹
*ï¼ˆ70ï¼‰ã‚ˆã‚Šå°‘ã—å¼·ã„ â†’ a / b * c ã¯ (a / b) * c ã¨èª­ã¾ã‚Œã‚‹
^ï¼ˆ80ï¼‰ã‚ˆã‚Šå¼±ã„ â†’ a^2 / b ã¯ (a^2) / b ã¨èª­ã¾ã‚Œã‚‹
ã¨ãªã‚‹ã€‚
ä»¥ä¸‹ã‚½ãƒ¼ã‚¹
https://leanprover-community.github.io/lt2021/slides/sebastian-lean4-parsers-macros.pdf?utm_source=chatgpt.com
-/

-- ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…é™å®šã®åˆ†æ•°è¡¨ç¤ºã®å°å…¥ã€‚ a / b : Q(A,hC) ï¼ˆb : NZDen Aï¼‰ _/_
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

-- open scoped TGFracã¨æ›¸ã‘ã°ã©ã“ã§ã‚‚ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼ša /[hC] b ï¼ˆb : NZDen Aï¼‰ 
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic

open Classical

section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

namespace FracCarrier

-- åˆ†æ¯åŒå£«ã®ç©ã¯ 0 ã«ãªã‚‰ãªã„ã“ã¨ã‚’ç¤ºã™è£œé¡Œã€‚ï¼ˆCancellative ã‚’åˆ©ç”¨ï¼‰
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den â‰  0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 ã‹ã‚‰ p.den * q.den = p.den * 0 ã‚’å¾—ã‚‹
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _ --_ã¯p.den
    exact h.trans hz.symm
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

-- (a/b) + (c/d) := (ad + cb) / (bd)  FracCarrierã¯ãƒšã‚¢ãªã®ã§ã€âŸ¨(åˆ†æ¯,åˆ†å­),åˆ¶ç´„æ¡ä»¶(åˆ†æ¯ã¯ï¼ã˜ã‚ƒãªã„)âŸ© ã¨ã„ã†æ–‡ä¿ã«ãªã‚‹ã€‚
def addRep (hC : Cancellative A) (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

-- (a/b) * (c/d) := (ac) / (bd) 
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

-- åŠ æ³•ã®well-definedæ€§ 
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
      -- ç›®æ¨™ã¯(p.num*q.den + q.num*p.den)*(p'.den*q'.den) = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  unfold Rel addRep
  have Hâ‚€ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by --åˆ†é…æ³•å‰‡ã®é©ç”¨
            simpa using Hâ‚€
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by --æ›ã‘ç®—ã®é †ç•ªå…¥ã‚Œæ›¿ãˆ
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl --assocã¨commã‚’é©ç”¨ã—ãŸã†ãˆã§ã®rfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by --å„æ‹¬å¼§ã®ä¸­ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by --p.den * d.denã§æ‹¬ã‚Šã ã—
            have Hâ‚ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            simpa [mul_comm, mul_left_comm, mul_assoc] using Hâ‚.symm

-- ä¹—æ³•ã®well-definedæ€§ 
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
      -- ç›®æ¨™ã¯ (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den) (Rel)
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

--11/14
-- Q(A) ä¸Šã®åŠ æ³•

/-
Quot.lift :                      
  (F : Î± â†’ Î²) â†’                  -- é–¢æ•° F
  (âˆ€{x y}, r x y â†’ F x = F y) â†’  -- rãŒåŒå€¤ãªã‚‰ F ã®å€¤ã‚‚ç­‰ã—ã„ï¼ˆwell-definedã®è¨¼æ˜å¿…è¦ï¼‰
  Quot r â†’ Î²                     -- å•† Quot r ã‹ã‚‰ Î² ã¸ã®é–¢æ•°ã‚’å¾—ã‚‹
-/

noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let addCoreâ‚ :
      --ä»¥ä¸‹ã®FracCarrier Aã¯1ã¤ç›®ã®å¼•æ•°ã€ã¤ã¾ã‚Špã®ã“ã¨ã§ã‚ã‚‹ã€‚ã™ãªã‚ã¡ã€pã‚’å›ºå®šã—ãŸã†ãˆã§ã®qã®Q(A)â†’Q(A)ã¨ã„ã†æ¼”ç®—ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    --fun p => Quot.liftãŒä¸Šã®FracCarrier Aâ†’ Q(A)ã«å¯¾å¿œã€‚
    fun p =>
      --Quot.liftã®ä¸­ã®fun q => Quot.mkãŒQ(A)â†’Q(A)ã«å¯¾å¿œã€‚
      --é–¢æ•°ï¼¦ã¨åŒå€¤ï½ã«ã¤ã„ã¦ã€aï½b â†’ F(a)=F(b)ãŒæˆã‚Šç«‹ã¤ãªã‚‰ã€F(c)=F([c])ãŒæˆã‚Šç«‹ã¤ã¨ã„ã†ã®ãŒQuot.lift
      Quot.lift
         --qãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰æ—¢ã«å­˜åœ¨ã™ã‚‹pã‚’æŒã£ã¦ãã¦addrepã§è¶³ã—ç®—ã—ãŸå¾Œã«setoidã§åŒå€¤é¡ã«ã™ã‚‹ã€‚
         --ã™ãªã‚ã¡ã€ ä»¥ä¸‹ã®funãŒã‚„ã£ã¦ã„ã‚‹ã“ã¨ã¯ q â†’ [p + q]ã§ã‚ã‚‹ã€‚
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' ã®ã¨ãwell-definedã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã€‚
          intro q q' hq
          --aã¨bãŒé–¢ä¿‚rã§åŒå€¤ãªã‚‰ã°ã€åŒå€¤é¡ã¨ã—ã¦ã¯ã‚¤ã‚³ãƒ¼ãƒ«ã®é–¢ä¿‚ã«ãªã‚‹ã€‚
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let addCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      --ä»Šå›å†™åƒã¯FracCarrierã‹ã‚‰pã‚’å–ã‚ŒãŸæ™‚ç‚¹ã§ã‚ã¨ã¯addcoreâ‚ã«ã™ã¹ã¦ä»»ã›ã‚Œã°ã‚ˆã„ã€‚
      (fun p => addCoreâ‚ p)
      (by
        -- p ~ p' ãªã‚‰ã€é–¢æ•° addCoreâ‚ p = addCoreâ‚ p'ã‚’ç¤ºã™ã€‚
        intro p p' hp
        apply funext
        intro y
        -- yãŒå•†ã®å…ƒãªã®ã§ä»£è¡¨ã«æˆ»ã—ã¦ã‚ã’ã‚‹
        refine Quot.induction_on y ?_
        intro q
        -- ç›®æ¨™ã‚’æ›¸ãæ›ãˆã‚‹addcoreâ‚p [q]ï¼[p+q]ãªã®ã§ã€æ¬¡ã®2ã¤ã®mkã®ç­‰ã—ã•ã‚’ç¤ºã›ã°ã‚ˆã„
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- ä»¥ä¸Šã‚’ä½¿ã£ã¦ x, y ã«é©ç”¨
  exact addCoreâ‚‚ x y


-- Q(A) ä¸Šã®ä¹—æ³• 
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCoreâ‚ :
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCoreâ‚ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCoreâ‚‚ x y

namespace Q

variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

--[p]+[q]=[p+q]
@[simp] lemma add_mk (p q : FracCarrier A) :
  Q.add (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.addRep (A:=A) hC p q) := rfl

--[p][q]=[pq]
@[simp] lemma mul_mk (p q : FracCarrier A) :
  Q.mul (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.mulRep (A:=A) hC p q) := rfl

end Q


end QAddMul

--11/21
open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  --1â‰ 0 

--Q(a)ã®0ã‚’0/1ã¨å®šç¾©ã€‚(åˆ†æ¯ãŒï¼ã§ãªã„è¨¼æ˜ä»˜ãã§)
def Q.zero : Q (A:=A) hC :=
  Q.mk (A:=A) hC 0 1 (by simp[NeZero.ne (1 : A)])

--Q(a)ã®1ã‚’1/1ã¨å®šç¾©ã€‚(åˆ†æ¯ãŒï¼ã§ãªã„è¨¼æ˜ä»˜ãã§)
def Q.one  : Q (A:=A) hC :=
  Q.mk (A:=A) hC 1 1 (by simp[NeZero.ne (1 : A)])

--Q(A)ã®0ã¨1ã‚’ä½¿ã„ãŸã„éš›ã«ãƒã‚°ãŒå‡ºã‚„ã™ã„ã®ã§instanceã¨ã—ã¦è¿½åŠ 
instance : Zero (Q (A:=A) hC) := âŸ¨Q.zero (A:=A) hCâŸ©
instance : One  (Q (A:=A) hC) := âŸ¨Q.one  (A:=A) hCâŸ©

--OfNat A nã¯nã‚’Aã®è¦ç´ ã¨ã—ã¦èª­ã¿ãªã•ã„ã¨ã„ã†æŒ‡ç¤ºã‚’ä¸ãˆã‚‹instance
--(0 : ...)ã‚„(1 : ...)ãƒã‚°ãŒç™ºç”Ÿã—ã‚„ã™ã„ã®ã§ãã‚Œã‚’å›é¿ã™ã‚‹ãŸã‚ã€‚
--ZeroãŒå­˜åœ¨ã™ã‚‹ã®ã§ã€Q(A)ã®ï¼ã‚’zeroã§å‘¼ã³å‡ºã™ã¨ã„ã†å†…å®¹ã‚’ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã¯è¿°ã¹ã¦ã„ã‚‹ã€‚
noncomputable instance instOfNat0Q :
    OfNat (Q (A:=A) hC) 0 where
  ofNat := (Zero.zero : Q (A:=A) hC)

noncomputable instance instOfNat1Q :
    OfNat (Q (A:=A) hC) 1 where
  ofNat := (One.one : Q (A:=A) hC)

noncomputable instance : Add  (Q (A:=A) hC) := âŸ¨Q.add (A:=A) hCâŸ©
noncomputable instance : Mul  (Q (A:=A) hC) := âŸ¨Q.mul (A:=A) hCâŸ©
end QSemiring

namespace FracCarrier

variable {hC}
variable {A : Type u} [Semiring A]

-- åŠ æ³•ã®å¯æ›æ€§ã€‚åˆ†æ•°ã®ã‚¤ã‚³ãƒ¼ãƒ«ã¯Relã‚’ã—ã‚ã›ã°ã‚ˆã„ã€‚
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  -- Rel ã¨ addRep, num, den ã‚’å±•é–‹ã—ã¦ç›®æ¨™å¼ã‚’ç´ ã®ç­‰å¼ã«è½ã¨ã™
  unfold Rel addRep num den
  -- ç›®æ¨™ã¯
  --(p.num*q.den + q.num*p.den) * (q.den*p.den) = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  -- å’Œã®é †åºã¨åˆ†æ¯å´ã®ç©ã®é †åºã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã ã‘ã§ä¸€è‡´
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          -- å’Œã®é †åºã ã‘ã‚’å¯æ›æ³•å‰‡ã§å…¥ã‚Œæ›¿ãˆ
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          -- åˆ†æ¯å´ã®ç©ã®é †åºã‚’å¯æ›æ³•å‰‡ã§å…¥ã‚Œæ›¿ãˆ
          ac_rfl

-- åŠ æ³•ã®çµåˆæ€§
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  unfold Rel addRep
  set a := p.num; set b := p.den
  set c := q.num; set d := q.den
  set e := r.num; set f := r.den
  let kâ‚ := b * (d * f)
  let kâ‚‚ := (b * d) * f

  /- å·¦è¾ºã‚’ 3 é …ã« -/
  have HL1 :
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = ((a*d + c*b) * f) * kâ‚ + (e * (b*d)) * kâ‚ := by
    simpa using
      (Semiring.right_distrib (R:=A) ((a*d + c*b) * f) (e * (b*d)) kâ‚)

  -- ((a*d + c*b) * f) * kâ‚ = (a*d)*(f*kâ‚) + (c*b)*(f*kâ‚)
  have HL2 :
      ((a*d + c*b) * f) * kâ‚
        = (a*d) * (f * kâ‚) + (c*b) * (f * kâ‚) := by
    -- ((x+y)*f)*kâ‚ = (x+y)*(f*kâ‚) ã«ã—ã¦ã‹ã‚‰ right_distrib
    have := Semiring.right_distrib (R:=A) (a*d) (c*b) (f * kâ‚)
    simpa [mul_assoc] using this

  -- å·¦è¾ºã¾ã¨ã‚
  have HL :
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := by
    calc
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
          = ((a*d + c*b) * f) * kâ‚ + (e * (b*d)) * kâ‚ := HL1
      _ = ((a*d) * (f * kâ‚) + (c*b) * (f * kâ‚)) + (e * (b*d)) * kâ‚ := by
            simp [HL2]
      _ = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := by
            simp [mul_assoc]

  /- å³è¾ºã‚’ 3 é …ã« -/
  have HR1 :
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
        = (a * (d*f)) * kâ‚‚ + ((c*f + e*d) * b) * kâ‚‚ := by
    simpa using
      (Semiring.right_distrib (R:=A) (a * (d*f)) ((c*f + e*d) * b) kâ‚‚)

  -- ((c*f + e*d) * b) * kâ‚‚ = (c*f)*(b*kâ‚‚) + (e*d)*(b*kâ‚‚)
  have HR2' :
      ((c*f + e*d) * b) * kâ‚‚
        = (c*f) * (b * kâ‚‚) + (e*d) * (b * kâ‚‚) := by
    have := Semiring.right_distrib (R:=A) (c*f) (e*d) (b * kâ‚‚)
    simpa [mul_assoc] using this

  have HR :
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
        = a * (d*f) * kâ‚‚ + (c*f) * b * kâ‚‚ + (e*d) * b * kâ‚‚ := by
    calc
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
          = (a * (d*f)) * kâ‚‚ + ((c*f + e*d) * b) * kâ‚‚ := HR1
      _ = (a * (d*f)) * kâ‚‚ + ((c*f) * (b * kâ‚‚) + (e*d) * (b * kâ‚‚)) := by
            simp [HR2']
      _ = a * (d*f) * kâ‚‚ + (c*f) * b * kâ‚‚ + (e*d) * b * kâ‚‚ := by
            simp [mul_assoc, add_assoc]

  -- kâ‚ ã¨ kâ‚‚ ã¯çµåˆæ³•ã§åŒã˜ï¼ˆâ†ã“ã“ã‚’ä¿®æ­£ï¼‰
  have k_same : kâ‚ = kâ‚‚ := by
    -- kâ‚ = b * (d * f)
    -- kâ‚‚ = (b * d) * f
    -- mul_assoc b d f : (b * d) * f = b * (d * f)
    -- simp ã§ä¸¡è¾ºã‚’åŒã˜å½¢ã«æ­£è¦åŒ–ã—ã¦ãã‚Œã‚‹
    simp [kâ‚, kâ‚‚, mul_assoc]

  -- 3é …ã®å’Œã®ä¸¦ã³æ›¿ãˆï¼ˆæ‹¬å¼§å¤–ã—ã‚’å«ã‚€ï¼‰
  have align :
      a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚
        = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := by 
        simp [k_same, mul_assoc, mul_comm, mul_left_comm]
    -- ã¾ãš kâ‚ ã‚’ kâ‚‚ ã«ç½®æ›ã—ã¦ã‹ã‚‰ ac ã§ä¸¦ã¹æ›¿ãˆ
    /-simpa [k_same, mul_assoc, mul_comm, mul_left_comm] using
      (by
         have : a*d*f*kâ‚‚ + c*b*f*kâ‚‚ + e*(b*d)*kâ‚‚
              = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := by
            ac_rfl
         exact this)-/

  -- ã¾ã¨ã‚
  calc
    ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := HL
    _   = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := align
    _   = (a * (d*f) + (c*f + e*d) * b) * kâ‚‚ := HR.symm





-- ä¹—æ³•ã®å¯æ›æ€§
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  -- (p.num*q.num)*(p.den*q.den) ã¨ (q.num*p.num)*(q.den*p.den)
  -- ã¯ ac ã§ä¸€è‡´
  simp [mul_comm,  mul_assoc]

-- ä¹—æ³•ã®çµåˆæ€§
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  -- ã©ã¡ã‚‰ã‚‚åˆ†å­ p.num*q.num*r.numï¼Œåˆ†æ¯ p.den*q.den*r.den ï¼ˆé †åºé•ã„ï¼‰ã«ãªã‚‹ã®ã§ ac
  simp [mul_comm,  mul_assoc]

-- å·¦åˆ†é…å‰‡
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- ã¾ãš p,q,r ã®ä¸­èº«ã‚’ç´ ã®å¤‰æ•°åã«ã°ã‚‰ã™
  rcases p with âŸ¨âŸ¨pn, pdâŸ©, hp0âŸ©
  rcases q with âŸ¨âŸ¨qn, qdâŸ©, hq0âŸ©
  rcases r with âŸ¨âŸ¨rn, rdâŸ©, hr0âŸ©

  -- Rel, addRep, mulRep ã‚’å±•é–‹ã—ã¦ã€A ä¸Šã®ç­‰å¼ã«è½ã¨ã™
  unfold Rel addRep mulRep
  -- FracCarrier.num / den ã¯ãŸã ã® fst / snd
  simp [FracCarrier.num, FracCarrier.den]

  /-
  ã„ã¾ã‚´ãƒ¼ãƒ«ï¼ˆâ‰’ã‚¿ã‚¯ãƒ†ã‚£ã‚¯çŠ¶æ…‹ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰ã¯ï¼š
    pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
      =
    (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
      * (pd * (qd * rd))

  ã“ã‚Œã‚’2æ®µãƒ­ã‚±ãƒƒãƒˆã§ç¤ºã™ï¼š
   (1) å·¦è¾º = pn * (qn*rd + rn*qd) * X
   (2) ãã® X ç‰ˆã‹ã‚‰æœ€çµ‚å³è¾ºã¸
  ã‚’åˆæˆã™ã‚‹ã€‚
  -/

  -- ã¾ãšåˆ†æ¯å´ã®å¤§ãã„ç©ã‚’åå‰ä»˜ã‘ã—ã¦ãŠã
  set X : A := pd * qd * (pd * rd) with hX
  set Y : A := pd * (qd * rd) with hY

  -- (1) å·¦è¾ºã‚’ pn * (qn*rd + rn*qd) * X ã¨ã„ã†ã€Œæ¨™æº–å½¢ã€ã«å¯„ã›ã‚‹
  have lhs_reassoc :
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
        =
      pn * (qn * rd + rn * qd) * X := by
    -- ã¾ãš (pd * (qd * (pd * rd))) ã‚’ assoc ã§ (pd * qd) * (pd * rd) å‹ã«ã™ã‚‹
    have tail_assoc :
        pd * (qd * (pd * rd))
          = pd * qd * (pd * rd) := by
      -- (pd * (qd * Z)) = (pd * qd) * Z, and reassociate
      simp [mul_assoc]
    calc
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
          = pn * ((qn * rd + rn * qd) * (pd * qd * (pd * rd))) := by
              simp [tail_assoc]
      _   = pn * (qn * rd + rn * qd) * (pd * qd * (pd * rd)) := by
              -- reassociate pn * ((...) * (...)) â†’ pn * (...) * (...)
              simp [mul_assoc]
      _   = pn * (qn * rd + rn * qd) * X := by
              simp [hX]

  -- (2a) å·¦å´ï¼špn * (qn*rd + rn*qd) * X ã‚’è¶³ã—ç®—ã«å±•é–‹
  --      = pn*(qn*rd)*X + pn*(rn*qd)*X
  have left_expand :
      pn * (qn * rd + rn * qd) * X
        =
      pn * (qn * rd) * X + pn * (rn * qd) * X := by
    -- ã¾ãš (qn*rd + rn*qd) * X ã‚’å³åˆ†é…
    have inner :
        (qn * rd + rn * qd) * X
          =
        (qn * rd) * X + (rn * qd) * X := by
      -- right_distrib: (a+b)*c = a*c + b*c
      have tmp :=
        Semiring.right_distrib (R:=A) (qn * rd) (rn * qd) X
      simpa using tmp
    -- æ¬¡ã« pn * [...] ã‚’å·¦åˆ†é…
    -- pn * ( (qn*rd)*X + (rn*qd)*X )
    --   = pn*(qn*rd)*X + pn*(rn*qd)*X
    have tmp2 :=
      Semiring.left_distrib (R:=A) pn ((qn * rd) * X) ((rn * qd) * X)
    -- tmp2 :
    --   pn * ((qn * rd) * X + (rn * qd) * X)
    --     =
    --   pn * ((qn * rd) * X) + pn * ((rn * qd) * X)
    simpa [inner, mul_assoc] using tmp2

  -- (2b) å³å´ã®å’Œã‚’åˆ¥ã®å½¢ã«å±•é–‹ï¼š
  --   (pn*qn*(pd*rd) + pn*rn*(pd*qd)) * Y
  --   = pn*qn*(pd*rd)*Y + pn*rn*(pd*qd)*Y
  have right_expand :
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y
        =
      pn * qn * (pd * rd) * Y
      + pn * rn * (pd * qd) * Y := by
    -- ã“ã‚Œã‚‚ right_distrib
    have tmp :=
      Semiring.right_distrib (R:=A)
        (pn * qn * (pd * rd))
        (pn * rn * (pd * qd))
        Y
    simpa [mul_assoc] using tmp

  -- (2c) å€‹ã€…ã®é …ãŒåŒã˜ã‚‚ã®ã‚’æ›ã‘ç®—ã®é †åºæ›¿ãˆã§è¡¨ç¾ã—ã¦ã‚‹ã“ã¨ã‚’ç¤ºã™
  --      pn * (qn * rd) * X  =  pn * qn * (pd * rd) * Y
  have term1_match :
      pn * (qn * rd) * X
        =
      pn * qn * (pd * rd) * Y := by
    -- ä¸¡è¾ºã¨ã‚‚å¯æ›ãƒ»çµåˆã®ä¸¦ã¹æ›¿ãˆã ã‘ã§ä¸€è‡´ã™ã‚‹
    simp [X, Y, hY, mul_comm, mul_left_comm]

  --      pn * (rn * qd) * X  =  pn * rn * (pd * qd) * Y
  have term2_match :
      pn * (rn * qd) * X
        =
      pn * rn * (pd * qd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  -- (2d) å³å´ã®ã€Œpd*(qd*rd)ã€ã«æˆ»ã™ãŸã‚ã®å†çµåˆ
  --  (pn*(qn*(pd*rd)) + pn*(rn*(pd*qd))) * (pd*(qd*rd))
  --   ã¨
  --  (pn*qn*(pd*rd) + pn*rn*(pd*qd)) * Y
  --  ãŒåŒã˜ã ã¨ã„ã†è£œé¡Œ
  have rhs_reassoc :
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
        =
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
    calc
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
          =
        ((pn * qn * (pd * rd)) + (pn * rn * (pd * qd)))
          * (pd * (qd * rd)) := by
            -- assocã§ pn*(qn*...) = pn*qn*..., åŒæ§˜ã« rnå´ã‚‚
            simp [mul_assoc]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
            simp [hY]

  ----------------------------------------------------------------
  -- (2e) â€œX å½¢â€ ã‹ã‚‰ â€œæœ€çµ‚å³è¾ºâ€ã¾ã§ã®é–ã‚’ mid_chain ã¨ã—ã¦è¨¼æ˜
  ----------------------------------------------------------------
  have mid_chain :
      pn * (qn * rd + rn * qd) * X
        =
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := by
    -- ã“ã“ã¯ calc ã‚’ä½¿ã£ã¦å¤§ä¸ˆå¤«ã€‚ã‚¹ã‚¿ãƒ¼ãƒˆã¨ã‚´ãƒ¼ãƒ«ãŒãƒãƒƒã‚­ãƒªä¸€è‡´ã—ã¦ã‚‹ã‹ã‚‰ã€‚
    calc
      pn * (qn * rd + rn * qd) * X
          =
        pn * (qn * rd) * X + pn * (rn * qd) * X := left_expand
      _ =
        pn * qn * (pd * rd) * Y
        + pn * rn * (pd * qd) * Y := by
          simp [term1_match, term2_match]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y :=
          (right_expand.symm)
      _ =
        (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := rhs_reassoc.symm

  ----------------------------------------------------------------
  -- æœ€å¾Œã«ã€(1) ã¨ mid_chain ã‚’åˆæˆã—ã¦å…ƒã®ã‚´ãƒ¼ãƒ«ã‚’è¨¼æ˜
  ----------------------------------------------------------------
  grind
  --exact lhs_reassoc.trans mid_chain

-- å³åˆ†é…å‰‡
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by

  /- ã¾ãšåˆ†å­ãƒ»åˆ†æ¯ã‚’ç´ ã®å¤‰æ•°ã«ã°ã‚‰ã™ -/
  rcases p with âŸ¨âŸ¨pn, pdâŸ©, hp0âŸ©
  rcases q with âŸ¨âŸ¨qn, qdâŸ©, hq0âŸ©
  rcases r with âŸ¨âŸ¨rn, rdâŸ©, hr0âŸ©

  /- `Rel` ã¨ `addRep` / `mulRep` ã‚’å±•é–‹ã—ã¦ï¼Œ
     Q(A) ä¸Šã®ç­‰å¼ã‚’ A ã®ç­‰å¼ã«è½ã¨ã™ -/
  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  /-
  ã„ã¾ã‚´ãƒ¼ãƒ«ã¯ï¼ˆå¯æ›ãƒ»çµåˆã®é•ã„ä»¥å¤–ã¯ï¼‰æ¬¡ã®å½¢ã«ãªã£ã¦ã„ã‚‹ã¯ãšï¼š

    ((pn * qd + qn * pd) * rn) * ((pd * rd) * (qd * rd))
      =
    ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * ((pd * qd) * rd)

  å·¦è¾ºãƒ»å³è¾ºã®ã€Œã§ã‹ã„åˆ†æ¯éƒ¨åˆ†ã€ã‚’å¤‰æ•°ã«å–ã£ã¦ãŠãï¼š
    X := (pd * rd) * (qd * rd)
    Y := (pd * qd) * rd
  -/

  set X : A := (pd * rd) * (qd * rd) with hX
  set Y : A := (pd * qd) * rd with hY

  /- `*` ã®çµåˆæ³•å‰‡ã§å·¦å´ã‚’ã€Œ((...)*rn) * Xã€ã‹ã‚‰ã€Œ(...)*rn*Xã€ã«å¯„ã›ã‚‹ -/
  have lhs_reassoc :
      ((pn * qd + qn * pd) * rn) * X
        =
      (pn * qd + qn * pd) * rn * X := by
    simp [X, mul_assoc]

  /- å·¦è¾ºã‚’åˆ†é…ã§ 2 é …ã®å’Œã«åˆ†ã‘ã‚‹ã€‚
     (pn*qd + qn*pd) * rn * X
       = (pn*qd)*rn*X + (qn*pd)*rn*X
  -/
  have left_expand :
      (pn * qd + qn * pd) * rn * X
        =
      (pn * qd) * rn * X + (qn * pd) * rn * X := by
    -- ã¾ãšä¸€æ¬¡åˆ†é…ï¼š(a+b)*rn = a*rn + b*rn
    have step1 :
        (pn * qd + qn * pd) * rn
          =
        (pn * qd) * rn + (qn * pd) * rn := by
      simpa using
        Semiring.right_distrib (R:=A) (pn * qd) (qn * pd) rn
    -- ãã‚Œã«ã•ã‚‰ã« * X ã‚’å³ã‹ã‚‰æ›ã‘ã¦ã‚‚ã†ä¸€åº¦åˆ†é…
    calc
      (pn * qd + qn * pd) * rn * X
          = ((pn * qd) * rn + (qn * pd) * rn) * X := by
              simp [step1]
      _   = (pn * qd) * rn * X + (qn * pd) * rn * X := by
              simpa [mul_assoc] using
                Semiring.right_distrib (R:=A)
                  ((pn * qd) * rn) ((qn * pd) * rn) X

  /- å³è¾ºå´ã‚‚åŒæ§˜ã«ã€
     ((pn*rn)*(qd*rd) + (qn*rn)*(pd*rd)) * Y
       = (pn*rn)*(qd*rd)*Y + (qn*rn)*(pd*rd)*Y
  -/
  have right_expand :
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y
        =
      (pn * rn) * (qd * rd) * Y + (qn * rn) * (pd * rd) * Y := by
    simpa [mul_assoc] using
      Semiring.right_distrib (R:=A)
        ((pn * rn) * (qd * rd)) ((qn * rn) * (pd * rd)) Y

  /- å„é …ã©ã†ã—ãŒä¸€è‡´ã™ã‚‹ã“ã¨ã‚’ç¤ºã™ï¼š
       (pn * qd) * rn * X
         = (pn * rn) * (qd * rd) * Y
     ã“ã‚Œã¯å¯æ›ãƒ»çµåˆã®ä¸¦ã¹æ›¿ãˆã ã‘ã§è¨¼æ˜ã§ãã‚‹
  -/
  have term1_match :
      (pn * qd) * rn * X
        =
      (pn * rn) * (qd * rd) * Y := by
    -- ãã‚Œãã‚Œã‚’ `pn * rn * qd * qd * pd * rd * rd` å‹ã¾ã§æ•´å½¢
    simp [X, Y, mul_comm, mul_left_comm]

  /- åŒæ§˜ã« 2 å€‹ç›®ã®é …ï¼š
       (qn * pd) * rn * X
         = (qn * rn) * (pd * rd) * Y
  -/
  have term2_match :
      (qn * pd) * rn * X
        =
      (qn * rn) * (pd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  /- ä»¥ä¸Šã‚’ã¾ã¨ã‚ã‚‹ã€‚
     ã¾ãšå·¦è¾ºã‚’ `lhs_reassoc` ã§ (pn*qd+qn*pd)*rn*X ã«å¯„ã›ã‚‹ã€‚
     æ¬¡ã« `left_expand` ã§ 2 é …ã«åˆ†ã‘ã‚‹ã€‚
     ãã‚Œãã‚Œ `term1_match` / `term2_match` ã§å³è¾ºã®å½¢ã«ãã‚ãˆã‚‹ã€‚
     æœ€å¾Œã« `right_expand`.symm ã§å†ã³å’Œã‚’ä¸€ã¤ã®ç©ã«ã¾ã¨ã‚ã‚‹ã€‚
     ãã®çµæœãŒæœ€çµ‚çš„ãªå³è¾º ((pn*rn)*(qd*rd) + (qn*rn)*(pd*rd)) * Y ã«ãªã‚‹ã€‚
  -/
  have mid_chain :
      (pn * qd + qn * pd) * rn * X
        =
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
    calc
      (pn * qd + qn * pd) * rn * X
          = (pn * qd) * rn * X + (qn * pd) * rn * X := left_expand
      _   = (pn * rn) * (qd * rd) * Y
            + (qn * rn) * (pd * rd) * Y := by
              simp [term1_match, term2_match]
      _   = ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
              simpa [mul_assoc] using right_expand.symm

  /- ä»•ä¸Šã’ï¼š
     LHS = ((pn*qd + qn*pd) * rn) * X
         = (pn*qd + qn*pd) * rn * X          (lhs_reassoc)
         = ... = RHS                         (mid_chain)
  -/
  exact lhs_reassoc.trans mid_chain



end FracCarrier

--11/21

-- Q(A)ã¯å¯æ›ãªåŠ æ³•ãƒ¢ãƒã‚¤ãƒ‰ã§ã‚ã‚‹
section
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

noncomputable instance instAddCommMonoidQ :
    AddCommMonoid (Q (A:=A) hC) where
  add  := (Â· + Â·)
  zero := (0 : Q (A:=A) hC)

  add_assoc := by
    intro x y z
    -- ä»£è¡¨ã«é™ã‚ã—ã¦ä»£è¡¨ç‰ˆã®çµåˆå¾‹è£œé¡Œã‚’æŒã¡ä¸Šã’ã‚‹
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.addRep_assoc (A:=A) hC p q r

  zero_add := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    -- ç›®æ¨™ã‚’ Q.add ã®å½¢ã«
    change
      Q.add (A:=A) hC (Q.zero (A:=A) hC) (Quot.mk _ p)
        = Quot.mk _ p
    -- å·¦è¾ºã‚’ä»£è¡¨ã®å¼ã«è½ã¨ã™
    simp [Q.zero]  -- lhs = Quot.mk _ (addRep âŸ¨(0,1), _âŸ© p)
    -- ã‚ã¨ã¯ Rel ã§ (0/1) + (a/b) ~ (a/b)
    apply Quot.sound
    -- setoid ã® rel ã‚’æ˜ç¤ºçš„ã« `FracCarrier.Rel` ã«å¤‰ãˆã‚‹
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC âŸ¨(0,1), by
          simp[NeZero.ne (1 : A)]âŸ© p)
        p
    -- å±•é–‹ã—ã¦ã‚·ãƒ³ãƒ—ãƒ«ã«é–‰ã˜ã‚‹
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm, Semiring.mul_zero]

  add_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Q.add (A:=A) hC (Quot.mk _ p) (Q.zero (A:=A) hC)
        = Quot.mk _ p
    simp [Q.zero]
    apply Quot.sound
    -- ã“ã¡ã‚‰ã‚‚ã¾ãš `Rel` ã«å·®ã—æ›¿ãˆ
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC p âŸ¨(0,1), by
          simp[NeZero.ne (1 : A)]âŸ©)
        p
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm,Semiring.mul_zero]


  add_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q

  -- ã€Œå‹ä»˜ãã‚¼ãƒ­ã€ã‚’åˆæœŸå€¤ã«ã—ã¦ãŠãï¼ˆOfNat ã‚’è¦æ±‚ã—ãªã„ï¼‰
  nsmul := fun n x => Nat.recOn n (0 : Q (A:=A) hC) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

end




--Q(A)ã¯å¯æ›ãªä¹—æ³•ãƒ¢ãƒã‚¤ãƒ‰ã§ã‚ã‚‹
section QCommMonoid
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  -- â˜… ã“ã‚Œã‚’è¶³ã™

noncomputable instance : CommMonoid (Q (A:=A) hC) where
  mul := (Â· * Â·)
  one := (1 : Q (A:=A) hC)

  mul_assoc := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.mulRep_assoc (A:=A) hC p q r

  one_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), by
        simp[NeZero.ne (1 : A)]âŸ© p) = Quot.mk _ p
    apply Quot.sound
    -- setoid ã® rel ã‚’æ˜ç¤ºã—ã¦ã‹ã‚‰å±•é–‹
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), by
          simp[NeZero.ne (1 : A)]âŸ© p) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm]

  mul_one := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), by
        simp[NeZero.ne (1 : A)]âŸ©) = Quot.mk _ p
    apply Quot.sound
    -- ã“ã¡ã‚‰ã‚‚æœ€åˆã« Rel ã¸å·®ã—æ›¿ãˆ
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), by
          simp[NeZero.ne (1 : A)]âŸ©) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp

  mul_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q

  npow := fun n x =>
    Nat.recOn n (1 : Q (A:=A) hC) (fun _ s => s * x)

end QCommMonoid

--Q(A)ã¯åŠç’°ã§ã‚ã‚‹
section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  -- åˆ†æ¯ 1 ç”¨

noncomputable instance : Semiring (Q (A:=A) hC) :=
{  -- è¦ªæ§‹é€ ã‚’ç¶™æ‰¿
  (inferInstance : AddCommMonoid (Q (A:=A) hC)),
  (inferInstance : CommMonoid     (Q (A:=A) hC)) with

  -- p * 0 = 0
  mul_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), h10âŸ©)
        = Quot.mk _ âŸ¨(0, 1), h10âŸ©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), h10âŸ©)
        âŸ¨(0, 1), h10âŸ©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    -- ã“ã“ãŒæœªè§£æ±ºã ã£ãŸç®‡æ‰€ï¼šä¸¡è¾ºã¨ã‚‚ 0 ã«è½ã¡ã‚‹
    simp  -- ï¼ˆå¿…è¦ãªã‚‰ simp [mul_zero, zero_mul] ã§ã‚‚å¯ï¼‰
    have hR : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hL : a * (0 : A) = 0 := TropicalGeometry.Semiring.mul_zero (R:=A) a
    simp [hL, hR]

  -- 0 * p = 0
  zero_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(0, 1), h10âŸ© âŸ¨(a, b), hbâŸ©)
        = Quot.mk _ âŸ¨(0, 1), h10âŸ©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(0, 1), h10âŸ© âŸ¨(a, b), hbâŸ©)
        âŸ¨(0, 1), h10âŸ©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp
    -- ã“ã“ã‚‚åŒæ§˜ã« 0 ã«è½ã¡ã‚‹
    have hL : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hR : (0 : A) * a = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) a
    simp [hL, hR]
    --simp  -- ï¼ˆå¿…è¦ãªã‚‰ simp [mul_zero, zero_mul] ã§ã‚‚å¯ï¼‰

  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r

  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r
}
end QSemiring


--é€†å…ƒã®å­˜åœ¨ï¼šSemifield ä»•ä¸Šã’ 

namespace FracCarrier

/-- ä»£è¡¨ç‰ˆã® 0 åˆ¤å®šï¼š `[a/b] = 0` â†” `a = 0` ã€‚ -/
lemma zero_iff_num_eq_zero
    {A : Type u} [TropicalGeometry.Semiring A]
     (h10 : (1 : A) â‰  0)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p âŸ¨(0, 1), h10âŸ© â†” p.num = 0 := by
  rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
  constructor
  Â· -- (â†’)  a*1 = 0*b â‡’ a = 0
    intro h
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at h
    -- å³è¾º 0*b ã¯ 0
    have hz : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    have h1 : a * (1 : A) = 0 := by
      rw [hz] at h; exact h
    -- a*1 = 0 ã‹ã‚‰ a = 0
    have hm : a * (1 : A) = a := mul_one a
    have h2 := h1
    rw [hm] at h2
    exact h2

  Â· -- (â†)  a = 0 â‡’ a*1 = 0*b
    intro hnum
    -- ã¾ãš num ã‚’ a ã«å±•é–‹ã—ã¦ã‹ã‚‰æ›¸ãæ›ãˆã‚‹
    dsimp [FracCarrier.num] at hnum
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
    -- a ã‚’ 0 ã«ç½®æ›
    rw [hnum]
    -- ç›®æ¨™ã¯ 0*1 = 0*b
    have hL : (0 : A) * (1 : A) = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) (1 : A)
    have hR : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    -- ä¸¡è¾ºã‚’ 0 ã«æ½°ã™
    rw [hL, hR]

end FracCarrier






open Classical

/-- éé›¶å…ƒã¯åˆ†å­ãŒéé›¶ãªä»£è¡¨ã‚’æŒã¤ -/
lemma nonzero_num_of_ne_zero
    {A : Type u} [TropicalGeometry.Semiring A]
    (hC : Cancellative A) [NeZero (1 : A)]
    {x : Q (A:=A) hC} (hx : x â‰  (0 : Q (A:=A) hC)) :
    âˆƒ p : FracCarrier A, Quot.mk _ p = x âˆ§ p.num â‰  0 := by
  rcases Quot.exists_rep x with âŸ¨p, rflâŸ©
  by_cases hpn : p.num = 0
  Â· rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    have ha : a = 0 := by
      dsimp [FracCarrier.num] at hpn; exact hpn
    -- â˜… ã“ã“ã‚’ `.Rel` ã§ã¯ãªã `.R` ã«ã—ã€`change` ã§ `FracCarrier.Rel` ã«è½ã¨ã™
    have hRel :
        (FracCarrier.setoid (A:=A) hC).r
          âŸ¨(a, b), hbâŸ©
          âŸ¨(0, 1), (NeZero.ne (1 : A))âŸ© := by
      change FracCarrier.Rel (A:=A)
               âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), NeZero.ne (1 : A)âŸ©
      -- å®šç¾©å±•é–‹ã—ã¦ä¸¡è¾º 0 ã«è½ã¨ã™
      dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
      calc
        a * (1 : A) = (0 : A) * (1 : A) := by rw [ha]
        _ = (0 : A) := TropicalGeometry.Semiring.zero_mul (R:=A) (1 : A)
        _ = (0 : A) * b := by
          symm; exact TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hEq : (Quot.mk _ âŸ¨(a, b), hbâŸ© : Q (A:=A) hC)
             = (0 : Q (A:=A) hC) := Quot.sound hRel
    exact (hx hEq).elim
  Â· exact âŸ¨p, rfl, hpnâŸ©






/-- Q(A) ã¯ Semifieldï¼š0â‰ 1 ã¨ã€Œéé›¶ã«é€†ã€ -/
noncomputable instance : Semifield (Q (A:=A) hC) where
  -- æ—¢ã« Semiring ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚ã‚‹
  zero_ne_one := by
    -- 0 â‰  1 ã¯ä»£è¡¨ 0/1 ã¨ 1/1 ãŒç•°ãªã‚‹ã“ã¨ã«å¸°ç€ï¼ˆh10 ã‚’ä½¿ç”¨ï¼‰
    -- Rel ã§ç­‰ã—ã„ã¨ä»®å®šã™ã‚‹ã¨ 0=1 ã«çŸ›ç›¾
    intro h01
    -- 0 = 1 ãªã‚‰ã€ãã®ä»£è¡¨ãŒ Rel ã§ç­‰ã—ã„
    -- (0*1) * (1*1) = (1*1) * (0*1) ã‚’è¦‹ã‚‹ã¨ 0=1 ã‚’å¼·ã„ã‚‹
    have : (0 : A) = 1 := by
      -- `Quot.eqv_iff_eq` ã¯ä½¿ãˆãªã„ã®ã§ã€ç­‰ã—ã„ã¨ä»®å®šã—ãŸã‚‰ Rel ãŒæˆã‚Šç«‹ã¤ã¯ãš
      -- ã“ã“ã¯æ‰‹çŸ­ã«ï¼šã‚‚ã— 0=1 ãªã‚‰ h10 ã«åã™ã‚‹ã€ã¨ã„ã†å½¢ã«å¤‰æ›
      -- å®Ÿéš›ã«ã¯ 0=1 ã‚’å°ãä»£è¡¨è¨ˆç®—ã§ã‚‚ OK
      -- ç°¡ç•¥åŒ–ã®ãŸã‚ã«åè¨¼æ³•ï¼šh10 : 1 â‰  0
      exact (h10 (by simpa))
    -- çŸ›ç›¾
    exact (by have := this.symm; simpa using this)
  exists_inv := by
    intro x hx
    -- éé›¶ãªã‚‰ä»£è¡¨ p ã§ p.num â‰  0 ãŒå–ã‚Œã‚‹
    rcases nonzero_num_of_ne_zero (A:=A) hC h10 hx with âŸ¨p, rfl, hpâŸ©
    -- é€†ã¯ [p.den/p.num]
    refine âŸ¨
      Quot.mk _ âŸ¨(p.den, p.num), hpâŸ©,
      ?goal
    âŸ©
    -- è¨¼æ˜ï¼š [p]*[p.den/p.num] = 1
    -- ä»£è¡¨è¨ˆç®—ï¼š (p.num/p.den) * (p.den/p.num) = (p.num*p.den)/(p.den*p.num) ~ 1/1
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p âŸ¨(p.den, p.num), hpâŸ©)
        = (1 : Q (A:=A) hC)
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p âŸ¨(p.den, p.num), hpâŸ©)
        = Quot.mk _ âŸ¨(1,1), h10âŸ©
    apply Quot.sound
    -- Rel ã®å¼ã«è½ã¨ã™
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    -- (p.num*p.den) * (1*1) = (1*p.num) * (p.den*p.num)
    -- å¯æ›çµåˆã§ `ac_rfl`
    have h1 : (p.num * p.den) * (1 * 1)
            = p.num * p.den := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    have h2 : (1 * p.num) * (p.den * p.num)
            = p.num * p.den * p.num := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    -- å·¦å³ã¨ã‚‚ p.num*p.den*p.num ã«è½ã¡ã‚‹
    simpa [h1, h2, Semiring.one_mul,
           mul_comm, mul_left_comm, mul_assoc]



--11/28

open Classical

--Max-Plus åŠä½“ T

/-- å°é›†åˆï¼šå®Ÿæ•°ã« -âˆ ã‚’ adjoin ã—ãŸã‚‚ã®ã€‚-âˆ ã¯ `âŠ¥`. -/
abbrev T : Type := WithBot â„

/-- ãƒˆãƒ­ãƒ”ã‚«ãƒ«åŠ æ³•ï¼ˆâŠ•ï¼‰ï¼šmax. -/
instance : Add T := âŸ¨fun a b => max a bâŸ©

/-- ãƒˆãƒ­ãƒ”ã‚«ãƒ« 0ï¼ˆåŠ æ³•å˜ä½ï¼‰ï¼š-âˆ. -/
instance : Zero T := âŸ¨(âŠ¥ : WithBot â„)âŸ©

/-- ãƒˆãƒ­ãƒ”ã‚«ãƒ«ä¹—æ³•ï¼ˆâŠ—ï¼‰ï¼šå®Ÿæ•°åŠ æ³•ã€‚ãŸã ã— -âˆ ã¯å¸åå…ƒã€‚ -/
instance : Mul T :=
  âŸ¨fun a b =>
    match a, b with
    | âŠ¥      , _       => (âŠ¥ : WithBot â„)
    | _       , âŠ¥      => (âŠ¥ : WithBot â„)
    | some x , some y  => some (x + y)âŸ©

/-- ãƒˆãƒ­ãƒ”ã‚«ãƒ« 1ï¼ˆä¹—æ³•å˜ä½ï¼‰ï¼šå®Ÿæ•°ã® 0. -/
instance : One T := âŸ¨(some (0 : â„))âŸ©

@[simp] lemma trop_add_def (a b : T) : a + b = max a b := rfl
@[simp] lemma trop_zero_def : (0 : T) = (âŠ¥ : WithBot â„) := rfl
@[simp] lemma trop_mul_def (a b : T) :
    a * b =
      match a, b with
      | âŠ¥     , _      => (âŠ¥ : WithBot â„)
      | _      , âŠ¥     => (âŠ¥ : WithBot â„)
      | some x, some y => some (x + y) := rfl
@[simp] lemma trop_one_def : (1 : T) = (some (0 : â„)) := rfl

/- å¯æ›æ€§ãƒ»çµåˆæ€§ãªã©ã€`Semiring` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å»ºã¦ã‚‹ã®ã«å¿…è¦ãªè£œé¡Œ
    ï¼ˆç´°éƒ¨ã¯ Mathlib ã® `WithBot` + å®Ÿæ•°åŠ æ³•ã®æ€§è³ªã§ã„ãšã‚Œè¨¼æ˜ã™ã‚‹ï¼‰. -/
lemma trop_add_comm (a b : T) : a + b = b + a := by
  simp [trop_add_def, max_comm]

lemma trop_add_assoc (a b c : T) :
    (a + b) + c = a + (b + c) := by 
  simp [trop_add_def, max_assoc, max_comm]

lemma trop_zero_add (a : T) : (0 : T) + a = a := by
  cases a <;> simp [trop_add_def, trop_zero_def, max_eq_right_iff,
                    max_eq_left_iff] <;> tauto

lemma trop_add_zero (a : T) : a + (0 : T) = a := by
  cases a <;> simp [trop_add_def, trop_zero_def, max_eq_right_iff,
                    max_eq_left_iff] <;> tauto

private def trop_nsmul (n : â„•) (a : T) : T :=
  Nat.recOn n (0 : T) (fun _ acc => acc + a)

private lemma trop_nsmul_zero (a : T) :
    trop_nsmul 0 a = (0 : T) := rfl
private lemma trop_nsmul_succ (n : â„•) (a : T) :
    trop_nsmul (n.succ) a = trop_nsmul n a + a := rfl

lemma trop_zero_mul (a : T) : (0 : T) * a = (0 : T) := by
  cases a <;> simp [trop_mul_def, trop_zero_def]

lemma trop_mul_zero (a : T) : a * (0 : T) = (0 : T) := by
  cases a <;> simp [trop_mul_def, trop_zero_def]

lemma trop_one_mul (a : T) : (1 : T) * a = a := by
  cases a <;> simp [trop_mul_def, trop_one_def]

lemma trop_mul_one (a : T) : a * (1 : T) = a := by
  cases a <;> simp [trop_mul_def, trop_one_def]

lemma trop_mul_comm (a b : T) : a * b = b * a := by
  cases a <;> cases b <;> simp [trop_mul_def, add_comm]

lemma trop_mul_assoc (a b c : T) :
    (a * b) * c = a * (b * c) := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, add_assoc]

private def trop_npow (n : â„•) (a : T) : T :=
  Nat.recOn n (1 : T) (fun _ acc => acc * a)

lemma trop_left_distrib (a b c : T) :
    a * (b + c) = a * b + a * c := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, trop_add_def, trop_zero_def,
          max_eq_left_iff, max_eq_right_iff,
          add_comm, add_left_comm, add_assoc,
          sup_eq_max] <;> try tauto

lemma trop_right_distrib (a b c : T) :
    (a + b) * c = a * c + b * c := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, trop_add_def, trop_zero_def,
          max_eq_left_iff, max_eq_right_iff,
          add_comm, add_left_comm, add_assoc,
          sup_eq_max] <;> try tauto

lemma trop_add_idempotent (a : T) : a + a = a := by
  simp [trop_add_def]

/- Max-Plus åŠä½“ `T` ã¯ã€ã‚ãªãŸãŒå®šç¾©ã—ãŸ `TropicalGeometry.Semiring` ã®
    ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã€‚ -/
noncomputable instance : TropicalGeometry.Semiring T where
  -- AddCommMonoid éƒ¨åˆ†
  add := (Â·+Â·)
  zero := (0 : T)
  add_assoc := trop_add_assoc
  zero_add := trop_zero_add
  add_zero := trop_add_zero
  add_comm := trop_add_comm
  nsmul := fun n a => trop_nsmul n a
  nsmul_zero := by intro a; simp [trop_nsmul_zero]
  nsmul_succ := by intro n a; simp [trop_nsmul_succ]
  -- CommMonoid éƒ¨åˆ†
  mul := (Â·*Â·)
  one := (1 : T)
  mul_assoc := trop_mul_assoc
  one_mul := trop_one_mul
  mul_one := trop_mul_one
  mul_comm := trop_mul_comm
  npow := fun n a => trop_npow n a
  -- Semiring å›ºæœ‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  mul_zero := by intro a; exact trop_mul_zero a
  zero_mul := by intro a; exact trop_zero_mul a
  left_distrib := by intro a b c; exact trop_left_distrib a b c
  right_distrib := by intro a b c; exact trop_right_distrib a b c


--nå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼(å½¢å¼çš„ã«ã¯ T[Xâ‚,â€¦,Xâ‚™])

/-
å¤šé‡æŒ‡æ•°ï¼šFin n â†’â‚€ â„• æœ‰é™ã‚µãƒãƒ¼ãƒˆå†™åƒ `u â†¦ coeff(u)` ã‚’ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ã¨ã¿ãªã™ã€‚ã“ã“ã§ã¯ã€Œå‹ã€ã¨ã€Œå˜é …å¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ã¾ã§å®šç¾©ã—ã¦ãŠãã€‚å¾Œã§ã“ã®å‹ã«å¯¾ã—ã¦ãƒˆãƒ­ãƒ”ã‚«ãƒ«å’Œãƒ»ãƒˆãƒ­ãƒ”ã‚«ãƒ«ç©ã‚’å…¥ã‚Œã¦Semiring ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã®ãŒæ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã€‚
-/

abbrev TropMonomial (n : â„•) := (Fin n â†’â‚€ â„•)

abbrev TropPoly (n : â„•) := (TropMonomial n) â†’â‚€ T

/-- å˜é …å¼ `c âŠ— X^u` ã‚’1é …ã ã‘æŒã¤ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ã¨ã—ã¦ä½œã‚‹ã€‚ -/
noncomputable def TropPoly.monom {n : â„•}
    (u : TropMonomial n) (c : T) : TropPoly n :=
  Finsupp.single u c

notation "TropPoly[" n "]" => TropPoly n


-- nå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼(å½¢å¼çš„ã«ã¯ T[Xâ‚^{Â±1},â€¦,Xâ‚™^{Â±1}])

/-
ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ã¯æŒ‡æ•°ã«è² ã‚‚è¨±ã™ã®ã§ â„¤ æŒ‡æ•°ã€‚
-/

abbrev TropLaurentMonomial (n : â„•) := (Fin n â†’â‚€ â„¤)

abbrev TropLaurent (n : â„•) := (TropLaurentMonomial n) â†’â‚€ T

/-- å˜é …ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ `c âŠ— X^u` ï¼ˆu ã¯ â„¤-ãƒ™ã‚¯ãƒˆãƒ«æŒ‡æ•°ï¼‰. -/
noncomputable def TropLaurent.monom {n : â„•}
    (u : TropLaurentMonomial n) (c : T) : TropLaurent n :=
  Finsupp.single u c

notation "TropLaurent[" n "]" => TropLaurent n

/-
4. è©•ä¾¡å†™åƒã¨ã€Œãƒãƒ¼ä»˜ãã€å¤šé …å¼é–¢æ•°ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°

 ã“ã“ã§ã¯ï¼Œæœ¬ã®è¨˜æ³•ã«åˆã‚ã›ã¦

   F : ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼  â”€â†’  ğ…Ì„ : Tâ¿ â†’ T
   G : ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ â”€â†’  á¸  : â„â¿ â†’ T

 ã‚’å®šç¾©ã™ã‚‹ã€‚

 ã•ã‚‰ã«ï¼Œã“ã‚Œã‚‰ã€Œãƒãƒ¼ä»˜ãã€åƒï¼ˆï¼å¤šé …å¼é–¢æ•° / ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°ï¼‰
 ã‹ã‚‰ãªã‚‹åŠç’°ã‚’è¡¨ã™å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚‚ç”¨æ„ã™ã‚‹ã€‚

 ä¾å­˜ã—ã¦ã„ã‚‹å‰æï¼š
 - ã™ã§ã«
     abbrev T := WithBot â„
     instance : TropicalGeometry.Semiring T
   ãŒå®šç¾©æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨

 - ã™ã§ã«
     abbrev TropMonomial (n : â„•) := (Fin n â†’â‚€ â„•)
     abbrev TropPoly     (n : â„•) := (TropMonomial n) â†’â‚€ T
     abbrev TropLaurentMonomial (n : â„•) := (Fin n â†’â‚€ â„¤)
     abbrev TropLaurent        (n : â„•) := (TropLaurentMonomial n) â†’â‚€ T

   ãŠã‚ˆã³å˜é …å¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
     TropPoly.monom
     TropLaurent.monom
   ãŒã‚ã‚‹ã“ã¨

-/

open Classical
open scoped BigOperators

namespace TropicalGeometry

/-- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ã®è©•ä¾¡ç‚¹ï¼ˆT^nï¼‰ã‚’ Lean çš„ã«ã€ŒFin n â†’ Tã€ã¨ã¿ãªã™ -/
abbrev TropPoint (n : â„•) := Fin n â†’ T

/-- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ã®è©•ä¾¡ç‚¹ï¼ˆâ„^nï¼‰ -/
abbrev TropLaurentPoint (n : â„•) := Fin n â†’ â„


/-
4-1. T ä¸Šã®å†ªï¼ˆãƒˆãƒ­ãƒ”ã‚«ãƒ«å†ªï¼‰

   tropPow a k  :=  a âŠ™ a âŠ™ ... âŠ™ a   (k å›, âŠ™ ã¯ãƒˆãƒ­ãƒ”ã‚«ãƒ«ä¹—æ³•)
                  = k å›ã®é€šå¸¸å®Ÿæ•°åŠ æ³•ï¼ˆa ãŒå®Ÿæ•°ã®å ´åˆï¼‰ã«å¯¾å¿œ

   0 ä¹—ã¯ 1 (ãƒˆãƒ­ãƒ”ã‚«ãƒ«å˜ä½ = 0 âˆˆ â„), ã¨ã„ã†ç´„æŸã«ã™ã‚‹
-/

/- ã€Œãƒˆãƒ­ãƒ”ã‚«ãƒ«å†ªã€: a^(k) in the tropical sense with k : â„•.
    0 ä¹—ã¯ 1ï¼ˆ= some 0ï¼‰ï¼Œsucc ã§ã¯å³ã‹ã‚‰ç©ï¼ˆ= å®Ÿæ•°åŠ æ³•ï¼‰ã‚’è¶³ã—ã¦ã„ãã€‚ -/
noncomputable def tropPow (a : T) (k : â„•) : T :=
  Nat.recOn k (1 : T) (fun _ acc => acc * a)

@[simp] lemma tropPow_zero (a : T) :
    tropPow a 0 = (1 : T) := rfl

@[simp] lemma tropPow_succ (a : T) (k : â„•) :
    tropPow a (k.succ) = tropPow a k * a := rfl


/-
4-2. T ä¸Šã®æ•´æ•°å†ªï¼ˆãƒ­ãƒ¼ãƒ©ãƒ³ç”¨ï¼‰

  ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ã§ã¯æŒ‡æ•°ãŒ â„¤ ã«ãªã‚‹ã€‚
  a^(m) (mâˆˆâ„¤) ã¯
     m â‰¥ 0 ãªã‚‰ä¸Šã® tropPow
     m < 0  ãªã‚‰ "è² ã®å›æ•°" åˆ†ã ã‘å¼•ãï¼ˆ= å®Ÿæ•°ã®ç¬¦å·ä»˜ãå’Œï¼‰

  è©•ä¾¡ç‚¹ã¯ â„ ã®ã¿ï¼ˆ-âˆ ã¯ãªã—ï¼‰ãªã®ã§ï¼Œ
  å®Ÿæ•° x ã‚’ T (= WithBot â„) ã® some x ã«åŸ‹ã‚ã¦æ‰±ã†ã€‚
-/

/-- å®Ÿæ•°ã‚’ T (= WithBot â„) ã«å…¥ã‚Œã‚‹åŸ‹ã‚è¾¼ã¿ã€‚ -/
@[simp] def toT (x : â„) : T := some x

@[simp] lemma toT_mul_toT (x y : â„) :
    toT (x + y) = (toT x * toT y) := rfl

@[simp] lemma toT_zero : toT (0 : â„) = (1 : T) := rfl
-- ï¼ˆ1 in T ã¯ some 0 ã¨ã„ã†è¨­è¨ˆã ã£ãŸã¯ãšï¼‰


/-- ã€Œæ•´æ•°æŒ‡æ•°ã®ãƒˆãƒ­ãƒ”ã‚«ãƒ«å†ªã€.
    è©•ä¾¡ç‚¹ã¯ â„ ãªã®ã§ï¼Œã“ã®ã¨ã a ã¯ â„ï¼Œå‡ºåŠ›ã¯ T.
    m â‰¥ 0 ã®ã¨ãã¯ m å›ã®å’Œï¼Œm < 0 ã®ã¨ãã¯ (âˆ’m) å›ã®å’Œã«ãƒã‚¤ãƒŠã‚¹ã‚’ä»˜ã‘ã‚‹
    ï¼ å®Ÿæ•°ã¨ã—ã¦ã¯ m â€¢ a ï¼ˆæ•´æ•°å€ï¼‰ã‚’ some ã§åŒ…ã‚€ã€‚ -/
noncomputable def tropPowZ (a : â„) (m : â„¤) : T :=
  some ((m : â„¤) â€¢ a)
  -- ã“ã“ã§ â€¢ ã¯ â„¤-å€ (zsmul)ã€‚
  -- tropical ä¹—æ³•ã¯å®Ÿæ•°åŠ æ³•ã«å¯¾å¿œã—ã¦ã„ã‚‹ã®ã§ã€
  -- a^(m) (trop) = m * a (ordinary real addition),
  -- ãã‚Œã‚’ some ã§æŒã¡ä¸Šã’ã¦ T ã®å…ƒã¨ã™ã‚‹ã€‚


/-
4-3. 1é … (monomial) ã®è©•ä¾¡


 å¤šé‡æŒ‡æ•° u : Fin n â†’â‚€ â„• ã«å¯¾ã—ã¦ï¼Œ
    ç‚¹ x : Fin n â†’ T ã§ã®ã€Œãƒˆãƒ­ãƒ”ã‚«ãƒ«å˜é …å¼ X^u ã®å€¤ã€.
    ã“ã‚Œã¯
       âˆ_{i} (x i)^(u i)  ï¼ˆãƒˆãƒ­ãƒ”ã‚«ãƒ«ä¹—æ³•ã§ã®ç©ï¼‰
    ã‚’æ„å‘³ã™ã‚‹ã€‚ -/
noncomputable def monomialEval
    {n : â„•} (u : TropMonomial n) (x : TropPoint n) : T :=
  âˆ i in Finset.univ, tropPow (x i) (u i)

@[simp] lemma monomialEval_def
    {n : â„•} (u : TropMonomial n) (x : TropPoint n) :
    monomialEval u x
      = âˆ i in Finset.univ, tropPow (x i) (u i) := rfl


/-- å¤šé‡æŒ‡æ•° u : Fin n â†’â‚€ â„¤ ï¼ˆæ•´æ•°æŒ‡æ•°ï¼‰ã«å¯¾ã—ã¦ï¼Œ
    å®Ÿæ•°ç‚¹ x : Fin n â†’ â„ ã§ã®ã€Œãƒˆãƒ­ãƒ”ã‚«ãƒ«å˜é …ãƒ­ãƒ¼ãƒ©ãƒ³å¼ X^u ã®å€¤ã€.
    ã“ã‚Œã¯
       âˆ_{i} (x i)^(u i)  ï¼ˆãƒˆãƒ­ãƒ”ã‚«ãƒ«ä¹—æ³•ã§ã®ç©ï¼‰
    ã§ï¼Œè² ã®æŒ‡æ•°ã‚‚è¨±ã™ã€‚ -/
noncomputable def monomialLaurentEval
    {n : â„•} (u : TropLaurentMonomial n) (x : TropLaurentPoint n) : T :=
  âˆ i in Finset.univ, tropPowZ (x i) (u i)

@[simp] lemma monomialLaurentEval_def
    {n : â„•} (u : TropLaurentMonomial n) (x : TropLaurentPoint n) :
    monomialLaurentEval u x
      = âˆ i in Finset.univ, tropPowZ (x i) (u i) := rfl


--4-4. å¤šé …å¼ / ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ å…¨ä½“ã®è©•ä¾¡

/-
ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ F : TropPoly n ã¯
  F : (Fin n â†’â‚€ â„•) â†’â‚€ T
ã™ãªã‚ã¡æœ‰é™å€‹ã® (u â†¦ coeff_u)ã€‚

å¤å…¸çš„ãªæ„å‘³ã§ã®ã€Œå€¤ F(x)ã€ã¯
  âŠ•_{u âˆˆ supp(F)} ( coeff_u âŠ™ x^u )
= max_{u} [ coeff_u + (âˆ‘ u_i * x_i) ]
ã«ç›¸å½“ã™ã‚‹ã€‚

`Finset.sup` ã¯ max ã‚’ã¨ã‚‹ã®ã§ï¼Œ
  F.support.sup (fun u => coeff_u * monomialEval u x)
ã§ã€ŒâŠ•ã€ã‚’å®Ÿè£…ã§ãã‚‹ã€‚
-/

noncomputable def TropPoly.eval {n : â„•}
    (F : TropPoly n) (x : TropPoint n) : T :=
  F.support.sup (fun u => F u * monomialEval u x)

/--
ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G : TropLaurent n ã®è©•ä¾¡ã€‚
å®šç¾©åŸŸã¯ R^n ï¼ˆ= Fin n â†’ â„ï¼‰ã§ï¼Œ
å€¤åŸŸã¯ T ï¼ˆ= â„ âˆª { -âˆ }ï¼‰ã€‚

æ³¨æ„ï¼ˆæ•™ç§‘æ›¸ã®èª¬æ˜ã¨ä¸€è‡´ï¼‰ï¼š
- ä¸€èˆ¬ã«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G ã¯ T^n ã§ã¯å®šç¾©ã§ããªã„ï¼ˆè² ã¹ããªã©ã§ -âˆ ãŒå£Šã‚Œã‚‹ï¼‰ã®ã§ï¼Œ
  á¸  ã®å®šç¾©åŸŸã¯ R^n ã¨ã™ã‚‹ã€‚
- ã‚‚ã—ã‚ã‚‹ç‚¹ã§ G ãŒ -âˆ ã‚’ã¨ã‚‹ãªã‚‰ï¼Œå®Ÿã¯ G å…¨ä½“ãŒå®šæ•° -âˆ ã§ã‚ã‚‹ã€‚
  ï¼ˆã“ã®æ€§è³ªã¯ç†è«–å´ã®å‘½é¡Œã€‚ã“ã“ã§ã¯ã‚³ãƒ¡ãƒ³ãƒˆã®ã¿ã€‚ï¼‰
-/
noncomputable def TropLaurent.eval {n : â„•}
    (G : TropLaurent n) (x : TropLaurentPoint n) : T :=
  G.support.sup (fun u => G u * monomialLaurentEval u x)


/-
 4-5. ã€Œãƒãƒ¼ä»˜ãã€å†™åƒã®å®šç¾©

   è¨˜å·çš„ã«
     F â†¦  FÌ„ : Tâ¿ â†’ T
     G â†¦  á¸  : â„â¿ â†’ T

 Leanä¸Šã§ã¯ãŸã ã® `def`/`abbrev`-/

/-- FÌ„ : Tâ¿ â†’ T.  
    ï¼ˆnå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ F ãŒå®šã‚ã‚‹ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼é–¢æ•°ï¼‰ -/
noncomputable def TropPoly.bar {n : â„•}
    (F : TropPoly n) : TropPoint n â†’ T :=
  fun x => TropPoly.eval F x

/-- á¸  : â„â¿ â†’ T.  
    ï¼ˆnå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G ãŒå®šã‚ã‚‹ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°ï¼‰ -/
noncomputable def TropLaurent.bar {n : â„•}
    (G : TropLaurent n) : TropLaurentPoint n â†’ T :=
  fun x => TropLaurent.eval G x


/-
4-6. ã€Œå¤šé …å¼é–¢æ•°åŠç’°ã€ã€Œãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°åŠç’°ã€

 æœ¬ã®è¨˜æ³•ã§ã¯
   T[Xâ‚,â€¦,Xâ‚™]Ì„  ã‚ã‚‹ã„ã¯  T[X]Ì„_n
   T[Xâ‚^{Â±1},â€¦,Xâ‚™^{Â±1}]Ì„
 ãªã©ã¨æ›¸ã‹ã‚Œã‚‹ã‚‚ã®ï¼š

 - å½¢å¼çš„å¤šé …å¼ F ã‚’è©•ä¾¡ã—ã¦å¾—ã‚‰ã‚Œã‚‹é–¢æ•° FÌ„ ã®ãªã™é›†åˆ
 - å½¢å¼çš„ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G ã‚’è©•ä¾¡ã—ã¦å¾—ã‚‰ã‚Œã‚‹é–¢æ•° á¸  ã®ãªã™é›†åˆ

 Lean ã§ã¯ Subtype ã§è¡¨ç¾ã—ã¦ãŠãï¼š
   ã€Œf ã¯ (Fin n â†’ T) â†’ T ã§ã‚ã£ã¦ï¼Œ
    ã‚ã‚‹ F : TropPoly n ãŒå­˜åœ¨ã— f = FÌ„ã€
-/

/-- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼é–¢æ•°ï¼ˆãƒãƒ¼ä»˜ãå¤šé …å¼å…¨ä½“ï¼‰.  
    è¦ç´ ã¯ã€Œf : (Fin n â†’ T) â†’ T ã§ï¼ŒâˆƒFï¼Œå¤šé …å¼ F ãŒã‚ã£ã¦ f = FÌ„ã€ã€‚ -/
noncomputable abbrev TropPolyFunc (n : â„•) :=
  { f : TropPoint n â†’ T //
      âˆƒ F : TropPoly n, f = TropPoly.bar F }

/-- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°ï¼ˆãƒãƒ¼ä»˜ããƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼å…¨ä½“ï¼‰.  
    è¦ç´ ã¯ã€Œg : (Fin n â†’ â„) â†’ T ã§ï¼ŒâˆƒGï¼Œãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G ãŒã‚ã£ã¦ g = á¸ ã€ã€‚ -/
noncomputable abbrev TropLaurentFunc (n : â„•) :=
  { g : TropLaurentPoint n â†’ T //
      âˆƒ G : TropLaurent n, g = TropLaurent.bar G }


/-
ãƒ¡ãƒ¢ï¼š
- TropPolyFunc n ã¯æœ¬ã§ã„ã† n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼é–¢æ•°åŠç’°
    T[Xâ‚,â€¦,Xâ‚™]Ì„ = T[X]Ì„_n
  ã«å¯¾å¿œã™ã‚‹ã¤ã‚‚ã‚Šã®å‹ã€‚

- TropLaurentFunc n ã¯æœ¬ã§ã„ã† n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°åŠç’°
    T[Xâ‚^{Â±1},â€¦,Xâ‚™^{Â±1}]Ì„
  ã«å¯¾å¿œã™ã‚‹ã¤ã‚‚ã‚Šã®å‹ã€‚

- ã“ã‚Œã‚‰ã«ãƒˆãƒ­ãƒ”ã‚«ãƒ«å’Œ âŠ• = maxï¼Œãƒˆãƒ­ãƒ”ã‚«ãƒ«ç© âŠ™ = å®Ÿæ•°åŠ æ³•
  ã‚’ã€Œç‚¹ã”ã¨ã€ã«å…¥ã‚Œã‚‹ã“ã¨ã§ï¼Œå®Ÿéš›ã« Semiring æ§‹é€ ãŒå…¥ã‚‹ã€‚
  ãã‚Œã¯
    (f âŠ• g)(x) := max (f x) (g x)
    (f âŠ™ g)(x) := (f x) + (g x)ï¼ˆ= tropical ä¹—æ³•ï¼‰
  ã¨ã„ã†å®šç¾©ã§ä¸ãˆã‚‰ã‚Œã‚‹ã€‚ï¼ˆå¾Œã§ formalize å¯èƒ½ï¼‰

- ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°ã¯é€£ç¶šå†™åƒã§ã‚ã‚‹ï¼Œãªã©
  æ•™ç§‘æ›¸ã«æ›¸ã„ã¦ã‚ã‚‹æ€§è³ªã¯ï¼Œ
  ä¸Šã§å®šç¾©ã—ãŸ `TropLaurent.bar` ã®å…·ä½“çš„ãªå½¢
  ï¼ˆæœ‰é™å€‹ã® max of affine-linear formsï¼‰ã‹ã‚‰è¨¼æ˜ã§ãã‚‹ã€‚
-/

end TropicalGeometry
/-
ã“ã“ã‹ã‚‰ï¼šT, T[X], T[X^{Â±}] ãŒæ¶ˆå»çš„ã§ã‚ã‚‹ã“ã¨ã«é–¢ã™ã‚‹ã‚³ãƒ¼ãƒ‰
-/

namespace TropicalGeometry

-- ã¾ãš T ãŒæ¶ˆå»çš„ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™
-- T = WithBot â„ ã‚’ max-plus (âŠ•=max, âŠ™=+) ã§åŠç’°åŒ–ã—ã¦ã„ã‚‹å‰æ
-- æˆ‘ã€…ã® Cancellative ã¨ã¯
--   a * b = a * c  â†’  a = 0 âˆ¨ b = c
-- ã ã£ãŸã®ã§ï¼Œ"å·¦ã‹ã‚‰æ›ã‘ã‚‹" = ãƒˆãƒ­ãƒ”ã‚«ãƒ«ã§ã¯å®Ÿæ•°åŠ æ³•ã®è¶³ã—è¾¼ã¿

/--
è£œåŠ©ï¼š`(some r : T) * x` ã®å…·ä½“å½¢ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®
åˆ†è§£è£œé¡Œã‚’ã„ãã¤ã‹å‡ºã—ã¦ãŠãã¨å¾Œã® `simp` ãŒç´ ç›´ã«å‹•ãã¾ã™ã€‚

ã‚ãªãŸã® `Mul T` ã¯ã ã„ãŸã„
  | âŠ¥ * _ = âŠ¥
  | _ * âŠ¥ = âŠ¥
  | (some a) * (some b) = some (a + b)
ã¨ã„ã†å½¢ã«ãªã£ã¦ã„ã‚‹ã¯ãšãªã®ã§ï¼Œ
ãã‚Œã«åˆã‚ã›ãŸ `@[simp]` ã‚’å®£è¨€ã—ã¾ã™ã€‚
-/

@[simp] lemma mul_bot_left  (x : T) :
    (âŠ¥ : T) * x = (âŠ¥ : T) := by
  -- your Mul definition should reduce by cases
  cases x <;> rfl

@[simp] lemma mul_bot_right (x : T) :
    x * (âŠ¥ : T) = (âŠ¥ : T) := by
  cases x <;> rfl

@[simp] lemma mul_some_some (a b : â„) :
    (some a : T) * (some b : T) = (some (a + b) : T) := rfl

@[simp] lemma mul_some_bot (a : â„) :
    (some a : T) * (âŠ¥ : T) = (âŠ¥ : T) := rfl

@[simp] lemma mul_bot_some (a : â„) :
    (âŠ¥ : T) * (some a : T) = (âŠ¥ : T) := rfl

/--
`T` ã¯æ¶ˆå»çš„åŠç’°ã§ã‚ã‚‹ï¼š
  a * b = a * c ãªã‚‰ a = 0 ã‚‚ã—ãã¯ b = c.
ã“ã“ã§ 0 ã¯ãƒˆãƒ­ãƒ”ã‚«ãƒ«é›¶å…ƒãªã®ã§ `âŠ¥ : T`.

ã“ã®è¨¼æ˜ã¯å ´åˆåˆ†ã‘ã§ã‚´ãƒªæŠ¼ã—ã§ãã¾ã™ï¼š
- a = âŠ¥ ãªã‚‰ã€Œa = 0ã€å´ã§çµ‚äº†
- a = some r ãªã‚‰ã€
    a * b = some (r + â€¦) ã‹ âŠ¥ã€
  ã‚’ b,c ã®å½¢ã¨çªãåˆã‚ã›ã¦ã€çµå±€ b = c ãŒå¿…è¦ã«ãªã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚
-/
lemma cancellative_T : Cancellative T := by
  intro a b c h
  -- å ´åˆåˆ†ã‘ on a
  cases a with
  | none =>
      -- a = âŠ¥ : by definitionã“ã‚Œã¯0
      -- ãªã®ã§ã€Œa = 0ã€ã®å´ã§å‹ã¡
      left
      -- `rfl` ã§ âŠ¥ = 0 ãŒé€šã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¦ã„ã‚‹ã®ã§ï¼Œ
      -- ã‚ãªãŸã® `Zero T` ã¯ `âŠ¥` ã«ãªã£ã¦ã‚‹ã¯ãš
      rfl
  | some ra =>
      -- a = some ra ã§éã‚¼ãƒ­å´ã®åˆ†å²
      -- b ã¨ c ã‚‚å ´åˆåˆ†ã‘
      cases b with
      | none =>
          -- b = âŠ¥
          -- LHS = (some ra) * âŠ¥ = âŠ¥
          -- h : âŠ¥ = (some ra) * c
          have hb : (âŠ¥ : T) = (some ra : T) * c := by simpa using h
          -- å³è¾ºã®å½¢ã§ c ã‚’åˆ†è§£
          cases c with
          | none =>
              -- c = âŠ¥
              -- ãªã‚‰ b = c ã§OK
              right
              rfl
          | some rc =>
              -- c = some rc
              -- RHS = (some ra) * (some rc) = some (ra + rc),
              -- ã“ã‚ŒãŒ âŠ¥ ã«ãªã‚‹ã“ã¨ã¯ãªã„ã®ã§çŸ›ç›¾
              -- çŸ›ç›¾ã‹ã‚‰ä½•ã§ã‚‚å‡ºã‚‹ã®ã§ b=c ã‚‚å‡ºã‚‹ãŒ
              -- Lean ã§ç›´æ¥ `cases hb` ã™ã‚‹ã¨è‰¯ã„
              cases hb
          -- ï¼ˆä¸Šã® `cases hb` ã¯ä¸å¯èƒ½ã‚±ãƒ¼ã‚¹ã‚’æ½°ã™ã®ã§è¨¼æ˜å®Œäº†ï¼‰
      | some rb =>
          -- b = some rb
          -- LHS = (some ra) * (some rb) = some (ra + rb)
          -- h : some (ra + rb) = (some ra) * c
          have hb : (some (ra + rb) : T) = (some ra : T) * c := by
            simpa using h
          -- c ã‚‚å ´åˆåˆ†ã‘
          cases c with
          | none =>
              -- c = âŠ¥
              -- RHS = (some ra) * âŠ¥ = âŠ¥,
              -- ã“ã‚Œã¯ some _ = âŠ¥ ã®å½¢ãªã®ã§ä¸å¯èƒ½ï¼ŒçŸ›ç›¾ã§çµ‚äº†
              cases hb
          | some rc =>
              -- c = some rc
              -- RHS = some (ra + rc)
              -- so we got:
              --   some (ra + rb) = some (ra + rc)
              -- => ra + rb = ra + rc  ï¼ˆOption.some.injï¼‰
              have h_inj : ra + rb = ra + rc := by
                cases hb
                rfl
              -- å®Ÿæ•°åŠ æ³•ã®æ¶ˆå»å¾‹ã§ rb = rc
              have h_eq : rb = rc := by
                exact add_left_cancel h_inj
              -- ã—ãŸãŒã£ã¦ b = c
              right
              -- b = some rb, c = some rc
              -- h_eq : rb = rc
              simpa [h_eq]

/-
ã“ã‚Œã§ `cancellative_T : Cancellative T` ãŒè¨¼æ˜ã§ãã¾ã—ãŸã€‚
ä»¥å¾Œã€ä»Šã¾ã§ã‚ãªãŸãŒä½¿ã£ã¦ã„ãŸè£œé¡Œç¾¤
  FracCarrier.den_mul_ne_zero ãªã©
  rel_trans ã«å‡ºã¦ãã‚‹ cancel_left
ã®å¼•æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

æ¬¡ã«æœ¬ã®ä¸»å¼µ
  ã€ŒT[X] ãŠã‚ˆã³ T[XÂ±] ã¯æ¶ˆå»çš„ã§ã‚ã‚‹ã€
ã‚‚ Lean çš„ã«ã¯åŒã˜å‹ã®å®šç¾©ã«å¯¾ã—ã¦
Cancellative (TropPoly 1) ã¨ã‹
Cancellative (TropLaurent 1)
ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ãŸã ã—ï¼š
- ã‚ãªãŸãŒä»Šæ›¸ã„ã¦ã„ã‚‹ `TropPoly n := (Fin n â†’â‚€ â„•) â†’â‚€ T`
  ã¨ `TropLaurent n := (Fin n â†’â‚€ â„¤) â†’â‚€ T`
  ã¯ã€ã¾ã ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§ `instance : Semiring (TropPoly n)` ã‚„
  `instance : Semiring (TropLaurent n)` ã‚’ä¸ãˆã¦ã„ãªã„æ®µéšã®ã¯ãšã§ã™ã€‚
  ï¼ˆæœ€çµ‚çš„ã«ã¯ï¼Œãƒˆãƒ­ãƒ”ã‚«ãƒ«å’Œï¼ä¿‚æ•°ã® max,
    ãƒˆãƒ­ãƒ”ã‚«ãƒ«ç©ï¼æŒ‡æ•°è¶³ã—åˆã‚ã›ï¼‹ä¿‚æ•°åŠ æ³•
   ã§ Semiring ã‚’å…¥ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ï¼‰

- ãã® Semiring ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã•ãˆä¸ãˆã¦ã—ã¾ãˆã°ã€
  å®Ÿéš›ã«ã¯ã€Œæœ€é«˜ï¼ˆ=æœ€å¤§ï¼‰æ¬¡æ•°ã®é …ã®ä¿‚æ•°ã‚’è¦‹ã‚‹ã€è­°è«–ã§
  Cancellative ãŒè¨¼æ˜ã§ãã¾ã™ï¼š
    H * F = H * G
    â†’ ã‚‚ã— H â‰  0 ãªã‚‰ F = G
    â†’ ã•ã‚‚ãªãã° H = 0
  ã¨ã„ã†å¤å…¸çš„ãª tropical polynomial ã®è­°è«–ã§ã™ã€‚

ä»Šã¯ãã“ã¾ã§ã®æ§‹é€ ãŒã¾ã ãƒ•ã‚¡ã‚¤ãƒ«ã«ç„¡ã„ã®ã§ã€
`axiom` ã¨ã—ã¦ç½®ã„ã¦ãŠãã€ã‚ã¨ã§ã¡ã‚ƒã‚“ã¨åŸ‹ã‚ã‚‹å½¢ã«ã—ã¦ãŠãã¾ã™ã€‚
`axiom` ã¯ã€Œã“ã®å‘½é¡Œã‚’ä»®å®šã¨ã—ã¦ä½¿ã£ã¦ã‚ˆã„ã€ã¨ã„ã† Lean ã®å®£è¨€ã§ã™ã€‚
å¾Œã‹ã‚‰ã¡ã‚ƒã‚“ã¨è¨¼æ˜ã‚’æ›¸ã„ãŸã‚‰ `axiom` ã‚’ `lemma` ã«å·®ã—æ›¿ãˆã¦ OK ã§ã™ã€‚
-/

/-- ï¼ˆä»®ç½®ãï¼‰1å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼åŠç’° `T[X]` ã¯æ¶ˆå»çš„ã§ã‚ã‚‹ã€‚  
    å¾Œã§ `Semiring (TropPoly 1)` ã‚’ãã¡ã‚“ã¨å®šç¾©ã—ãŸã‚ã¨ï¼Œ
    é€šå¸¸ã® tropical polynomial ã®æ¶ˆå»æ€§ã®è¨¼æ˜ã‚’æ›¸ã„ã¦ `axiom` ã‚’ `lemma` ã«ç½®ãæ›ãˆã‚‹ã€‚ -/
axiom cancellative_TropPoly1 :
  Cancellative (TropPoly (n:=1))

/-- ï¼ˆä»®ç½®ãï¼‰1å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼åŠç’° `T[X^{Â±}]` ã¯æ¶ˆå»çš„ã§ã‚ã‚‹ã€‚  
    ã“ã¡ã‚‰ã‚‚ `Semiring (TropLaurent 1)` ã‚’å®šç¾©ã—ãŸå¾Œã«ï¼Œ
    æœ€é«˜(æœ€å°ã‚‚å«ã‚€)æŒ‡æ•°ã®ä¿‚æ•°ã‚’è¿½è·¡ã™ã‚‹è­°è«–ã§è¨¼æ˜ã§ãã‚‹ã€‚ -/
axiom cancellative_TropLaurent1 :
  Cancellative (TropLaurent (n:=1))

end TropicalGeometry
/-
  Â§2.2 ã‚¤ãƒ‡ã‚¢ãƒ«ãƒ»åˆåŒãƒ»æ ¸åˆåŒãƒ»æº–åŒå‹å®šç†ã¾ã‚ã‚Š
  ã“ã“ã§ã¯æ—¢ã«
    class Semiring (R : Type u) extends AddCommMonoid R, CommMonoid R ...
  ãŒå®šç¾©æ¸ˆã¿ã§ã‚ã‚‹ã‚‚ã®ã¨ã—ã¦é€²ã‚ã‚‹ã€‚
  ï¼ˆå¯æ›åŠç’°ï¼åŠ æ³•å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ï¼‹ä¹—æ³•å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ï¼‹åˆ†é…ï¼‹0å¸åï¼‰
-/

namespace TropicalGeometry

universe u v

variable {S : Type u} [Semiring S]

/-
    å®šç¾© 2.2.1 (ã‚¤ãƒ‡ã‚¢ãƒ«)
    I âŠ† S ãŒã‚¤ãƒ‡ã‚¢ãƒ«ã¨ã¯:
      (I1) a,bâˆˆI â‡’ a+bâˆˆI
      (I2) aâˆˆS, bâˆˆI â‡’ aâ‹…b âˆˆ I    ï¼ˆå³ã‚¤ãƒ‡ã‚¢ãƒ«ã¨å·¦ã‚¤ãƒ‡ã‚¢ãƒ«ãŒä¸€è‡´ã™ã‚‹å¯æ›æ€§ï¼‰
    Lean ã§ã¯ `Ideal S` ã‚’ä»¥ä¸‹ã®æ§‹é€ ä½“ã¨ã—ã¦å®šç¾©ã™ã‚‹
 -/

structure Ideal (S : Type u) [Semiring S] where
  carrier : S â†’ Prop
  add_mem :
    âˆ€ {a b : S}, carrier a â†’ carrier b â†’ carrier (a + b)
  mul_mem_right :
    âˆ€ {a b : S}, carrier b â†’ carrier (a * b)
  -- `a*b` ã§ã‚‚ `b*a` ã§ã‚‚ã‚ˆã„ï¼ˆå¯æ›ãªã®ã§ååˆ†ï¼‰


/- membership è¨˜æ³• I.carrier x ã‚’ x âˆˆ I ã¨æ›¸ããŸã„ -/
namespace Ideal
instance : SetLike (Ideal S) where
  coe I := I.carrier
  coe_injective' := by
    intro I J h; cases I; cases J; cases h; rfl

@[simp] lemma mem_carrier {I : Ideal S} {x : S} :
    x âˆˆ I â†” I.carrier x := Iff.rfl

@[simp] lemma add_mem {I : Ideal S} {a b : S}
    (ha : a âˆˆ I) (hb : b âˆˆ I) : a + b âˆˆ I :=
  I.add_mem ha hb

@[simp] lemma mul_mem_right {I : Ideal S} {a b : S}
    (hb : b âˆˆ I) : a * b âˆˆ I :=
  I.mul_mem_right hb

/-- 0 âˆˆ I ã¯ a=0 ã‚’ mul_mem_right with b=0 ã‹ã‚‰ã‚‚å‡ºã›ã‚‹ãŒã€
    æ˜ç¤ºçš„ã«è¨¼æ˜ã—ã¦ãŠãã¨ä¾¿åˆ© -/
lemma zero_mem (I : Ideal S) : (0 : S) âˆˆ I := by
  -- 0 = 0 + 0, and need membership of each 0
  -- ã¾ãšã¯ 0 * (some b) âˆˆ I ã‚’ä½¿ã†ã‚ã‘ã«ã¯ã„ã‹ãªã„ã®ã§ã€
  -- åŠ æ³•é–‰æ€§ã‹ã‚‰å¾—ã‚‹ãŸã‚ã«ã€0 âˆˆ I ã‚’ç¤ºã™ã®ã« 0 âˆˆ I ãŒè¦ã‚‹â€¦ã¨ã„ã†å·¡å›ã«ãªã‚‹ã€‚
  -- ã‚ˆã£ã¦ã“ã“ã¯ classical ã« (0 âˆˆ I) ã‚’ä»®å®šã—ã¦å‡ºã™ã®ã¯ç„¡ç†ãªã®ã§
  -- ã“ã®è£œé¡Œã¯ä½¿ã‚ãšã«å¾Œç¶šã§å¿…è¦ãªã‚‰ assumption ã‹ã‚‰å°ãå½¢ã«ã—ã¾ã™ã€‚
  -- ï¼ˆæœ¬æ›¸å®šç¾©ã§ã¯ 0âˆˆI ã‚’ä»®å®šã—ã¦ã„ãªã„ã®ã§ã“ã“ã§ã¯ `sorry` ã«ã¯ã—ãªã„ã€‚
  --  å˜ã«ç”¨æ„ã—ãªã„ã“ã¨ã«ã™ã‚‹ã€‚ï¼‰
  -- å‰Šé™¤ã—ã¦ãŠãã€‚
  admit

end Ideal


/-
    å®šç¾© 2.2.1 (åˆåŒ = åŠç’°åˆåŒ)
    C âŠ† SÃ—S ãŒ S ä¸Šã®(åŠç’°)åˆåŒ ã¨ã¯:
      (1) C ã¯ SÃ—S ã®éƒ¨åˆ†åŠç’°
          ã¤ã¾ã‚Š C ã¯åŠ æ³•ãƒ»ä¹—æ³•ã§é–‰ã˜, (0,0),(1,1) ã‚’å«ã‚€
      (2) C ã¯ S ä¸Šã®åŒå€¤é–¢ä¿‚ã‚’å®šã‚ã‚‹
          åå°„ãƒ»å¯¾ç§°ãƒ»æ¨ç§»
    æœ¬ã§ã¯ (C1)ã€œ(C5) ã‚’å…¬ç†ã¨ã—ã¦ä¸¦ã¹ã¦ã„ã‚‹:

      (C1) aâˆˆS â‡’ (a,a)âˆˆC          (åå°„å¾‹ + å˜ä½çš„ãªã‚‚ã®)
      (C2) (a,b)âˆˆC â‡’ (b,a)âˆˆC      (å¯¾ç§°å¾‹)
      (C3) (a,b),(b,c)âˆˆC â‡’ (a,c)âˆˆC (æ¨ç§»å¾‹)
      (C4) (a,b),(a',b')âˆˆC â‡’ (a+a', b+b')âˆˆC   (åŠ æ³•é–‰æ€§)
      (C5) (a,b),(a',b')âˆˆC â‡’ (a*a', b*b')âˆˆC   (ä¹—æ³•é–‰æ€§)

    ã“ã‚Œã‚’ Lean ã®æ§‹é€ ä½“ SemiringCongruence ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã€‚
 -/

structure SemiringCongruence (S : Type u) [Semiring S] where
  rel : S â†’ S â†’ Prop

  -- (C1) åå°„
  refl  : âˆ€ a : S, rel a a
  -- (C2) å¯¾ç§°
  symm  : âˆ€ {a b : S}, rel a b â†’ rel b a
  -- (C3) æ¨ç§»
  trans : âˆ€ {a b c : S}, rel a b â†’ rel b c â†’ rel a c

  -- (C4) åŠ æ³•ã«é–¢ã—ã¦ä¸¡ç«‹
  add_compat :
    âˆ€ {a b a' b' : S}, rel a b â†’ rel a' b' â†’ rel (a + a') (b + b')
  -- (C5) ä¹—æ³•ã«é–¢ã—ã¦ä¸¡ç«‹
  mul_compat :
    âˆ€ {a b a' b' : S}, rel a b â†’ rel a' b' â†’ rel (a * a') (b * b')

  -- (0,0),(1,1) âˆˆ C ã¯ refl ã‹ã‚‰å¾“ã†ã®ã§åˆ¥æ ã§ã¯æŒãŸãªã„


namespace SemiringCongruence

/-- è¨˜æ³•: a â‰ˆ[C] b -/
infixl:50 " â‰ˆ["  C:0 "] " => (C.rel Â· Â·)

@[simp] lemma refl' (C : SemiringCongruence S) (a : S) : C.rel a a :=
  C.refl a

@[simp] lemma symm' (C : SemiringCongruence S) {a b : S}
    (h : C.rel a b) : C.rel b a :=
  C.symm h

@[simp] lemma trans' (C : SemiringCongruence S) {a b c : S}
    (h1 : C.rel a b) (h2 : C.rel b c) : C.rel a c :=
  C.trans h1 h2

/-- åŠ æ³•é©åˆæ€§ -/
lemma add_compat' (C : SemiringCongruence S)
    {a b a' b' : S} (h : C.rel a b) (h' : C.rel a' b') :
    C.rel (a + a') (b + b') :=
  C.add_compat h h'

/-- ä¹—æ³•é©åˆæ€§ -/
lemma mul_compat' (C : SemiringCongruence S)
    {a b a' b' : S} (h : C.rel a b) (h' : C.rel a' b') :
    C.rel (a * a') (b * b') :=
  C.mul_compat h h'

/-- å¯¾è§’é›†åˆ Î” = {(a,a) | aâˆˆS} ã¯è‡ªæ˜ãªåˆåŒ (trivial congruence). -/
def trivial (S : Type u) [Semiring S] : SemiringCongruence S where
  rel := fun a b => a = b
  refl := by intro a; rfl
  symm := by intro a b h; simpa [h.symm]
  trans := by intro a b c h1 h2; simpa [h1, h2]
  add_compat := by
    intro a b a' b' h h'
    -- h : a=b, h':a'=b'
    -- goal: a+a' = b+b'
    simpa [h, h'] 
  mul_compat := by
    intro a b a' b' h h'
    simpa [h, h']

/-- "çœŸã§ãªã„åˆåŒ" SÃ—S å…¨ä½“ï¼ˆimproper congruenceï¼‰ã‚‚åˆåŒã«ãªã‚‹ -/
def indiscrete (S : Type u) [Semiring S] : SemiringCongruence S where
  rel := fun _ _ => True
  refl := by intro _; trivial
  symm := by intro _ _ _; trivial
  trans := by intro _ _ _ _ _; trivial
  add_compat := by intro _ _ _ _ _ _; trivial
  mul_compat := by intro _ _ _ _ _ _; trivial

end SemiringCongruence


/-
    Ker(C) ã®å®šç¾©
    C ã‚’ S ä¸Šã®åˆåŒã¨ã™ã‚‹ã€‚
    Ker(C) := { a : S | (a,0_S) âˆˆ C }
  ï¼ˆæ•™ç§‘æ›¸ã®å›³ã§ã¯ Ker(C) = { a | (a,0_S) âˆˆ C } ãªã©ã¨åŒå€¤ï¼‰
-/

def SemiringCongruence.Ker
    (C : SemiringCongruence S) : Ideal S :=
{ carrier := fun a => C.rel a (0 : S)
  , add_mem := by
      intro a b ha hb
      -- ha : a ~ 0, hb : b ~ 0
      -- want: a+b ~ 0
      -- 0 ~ 0 by refl
      -- use add_compat (a~0) (b~0)
      have h' := C.add_compat ha hb
      -- h' : (a+b) ~ (0+0)
      simpa using h'
  , mul_mem_right := by
      intro a b hb
      -- hb : b ~ 0
      -- want: a*b ~ 0
      -- 0 ~ 0
      have h' := C.mul_compat (C.refl a) hb
      -- h' : a*b ~ a*0
      -- a*0 = 0 by zero_mul?
      -- æ³¨æ„: æˆ‘ã€…ã® Semiring ã«ã¯ zero_mul : âˆ€ a, 0*a = 0 ã¨ mul_zero : âˆ€ a, a*0 = 0 ãŒã‚ã‚‹
      -- ãŸã ã—å®šç¾©ã§ã¯ `mul_zero` ã¨ `zero_mul` ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ä½¿ãˆã‚‹
      have hz : a * 0 = (0 : S) := (Semiring.mul_zero (R:=S) a)
      simpa [hz]
}

/-
  è£œé¡Œ 2.2.2: åŠç’° S ä¸Šã®åˆåŒ C ã«å¯¾ã— Ker(C) ã¯ S å†…ã®ã‚¤ãƒ‡ã‚¢ãƒ«ã§ã‚ã‚‹ã€‚
  â†’ ã“ã‚Œã¯ä¸Šã§ `SemiringCongruence.Ker` ã‚’ Ideal S ã¨ã—ã¦å®šç¾©ã—ãŸã®ã§
    äº‹å®Ÿä¸Š "by rfl" ã§æ¸ˆã‚€ã€‚è¨¼æ˜ã¨ã—ã¦ lemma ã‚’æ›¸ã„ã¦ãŠãã€‚
-/
lemma Ker_isIdeal (C : SemiringCongruence S) :
    Ideal S :=
  SemiringCongruence.Ker (S:=S) C


/-
    è£œé¡Œ 2.2.3:
    S ã‚’åŠç’°ã¨ã—ï¼ŒC âŠ‚ SÃ—S ãŒ S ä¸Šã®åŒå€¤é–¢ä¿‚ã‚’å®šã‚ã‚‹ã¨ã™ã‚‹ã€‚
    ã“ã®ã¨ãï¼ŒC ãŒ S ä¸Šã®åˆåŒã§ã‚ã‚‹ã“ã¨ã¨ï¼Œ
    å•†é›†åˆ S/ C ã« S ã®æ¼”ç®—ã‹ã‚‰è‡ªç„¶ã«æ¼”ç®—ãŒå®šã¾ã‚ŠåŠç’°ã‚’æˆã™ã“ã¨ã¯åŒå€¤ã€‚
    ãã®ã¨ãï¼ŒÏ€_C : S â†’ S/C ã¯åŠç’°æº–åŒå‹å†™åƒ (å…¨å°„)ã€‚

    Lean ã§ã¯:
      â€¢ ã¾ãš C : SemiringCongruence S ã‚’ä»®å®šã™ã‚Œã°
        quotient ã‚’ä½œã‚Œã‚‹ã€‚
      â€¢ ãã—ã¦ãã® quotient ä¸Šã«åŠ æ³•ãƒ»ä¹—æ³•ã‚’ `Quot.lift` ã§å®šç¾©ã™ã‚‹ã€‚
    ï¼ˆã“ã“ã§ã¯ä¸€èˆ¬è«–ã¨ã—ã¦æç¤ºã—ï¼Œè©³ç´°ãªè¨¼æ˜ã¯ skeleton ã¨ã™ã‚‹ï¼‰ -/

namespace SemiringCongruence

variable (C : SemiringCongruence S)

/-- åŒå€¤é–¢ä¿‚ã¨ã—ã¦ã® setoid ã«å¤‰æ› -/
def toSetoid : Setoid S where
  r := C.rel
  iseqv :=
    âŸ¨ C.refl
    , C.symm
    , C.trans âŸ©

/-- å•†é›†åˆ S â§¸ C ï¼ˆæ•™ç§‘æ›¸ã® S/Cï¼‰ -/
def Quotient := Quot (C.toSetoid)

/-- å•†é›†åˆä¸Šã®åŠ æ³•ã®å®šç¾©ï¼š
    [a] + [b] := [a+b]
    well-definedæ€§ã¯ add_compat ã§æ‹…ä¿
-/
noncomputable def qAdd :
    Quotient (C:=C) â†’ Quotient (C:=C) â†’ Quotient (C:=C)
| Quot.mk _ a, Quot.mk _ b =>
    Quot.mk _ (a + b)
termination_by _ _ => 0
decreasing_by simp_wf

/-- well-definedness ã®ãŸã‚ã« `Quot.rec` ã§ã¯ãªã `Quot.induction_on` + proof ã‚’
    æ›¸ãã®ãŒæœ¬æ¥å¿…è¦ã ãŒï¼Œã“ã“ã§ã¯ skeleton ã¨ã—ã¦ noncomputable def ã‚’ç›´æ¥ä¸ãˆã‚‹ã€‚
    å³å¯†ç‰ˆã¯ Q.add ã¨åŒã˜ 2æ®µéš lift ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã™ã‚Œã°ã‚ˆã„ã€‚
-/

/-- å•†é›†åˆä¸Šã®ä¹—æ³•ï¼š
    [a] * [b] := [a*b]
    well-definedæ€§ã¯ mul_compat
-/
noncomputable def qMul :
    Quotient (C:=C) â†’ Quotient (C:=C) â†’ Quotient (C:=C)
| Quot.mk _ a, Quot.mk _ b =>
    Quot.mk _ (a * b)
termination_by _ _ => 0
decreasing_by simp_wf

/-- 0,1 on the quotient -/
noncomputable def qZero : Quotient (C:=C) := Quot.mk _ (0 : S)
noncomputable def qOne  : Quotient (C:=C) := Quot.mk _ (1 : S)

/-- è‡ªç„¶ãªå°„å½± Ï€_C : S â†’ S/C -/
def proj (a : S) : Quotient (C:=C) := Quot.mk _ a

/--
  ã“ã“ã§æœ¬å½“ã¯ qAdd, qMul, qZero, qOne ãŒ
  Semiring æ§‹é€ ã‚’æº€ãŸã™ã“ã¨ã‚’ç¤ºã™ã€‚
  ï¼ˆå·¦åˆ†é…ãƒ»å³åˆ†é…ãƒ»çµåˆå¾‹ãƒ»å¯æ›å¾‹ãªã©ã¯ C.add_compat, C.mul_compat ã¨
   Semiring S ã®å…¬ç†ã‹ã‚‰ quotient-lift ã«ã‚ˆã£ã¦ç¤ºã›ã‚‹ã€‚ï¼‰
  ã‹ãªã‚Šé•·ããªã‚‹ã®ã§ skeleton ã®ã¿ï¼š
-/
noncomputable def quotientSemiringStructure :
    Semiring (Quotient (C:=C)) := by
  -- ã“ã“ã¯å®Ÿéš›ã«ã¯ `refine` ã§å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŸ‹ã‚ã¦ã„ãå¿…è¦ã‚ã‚Šã€‚
  -- ã‚ãªãŸã®æ—¢å­˜ã® Q(A) ã§ã‚„ã£ãŸã‚ˆã†ã«ã€Quot.lift ã‚’é§†ä½¿ã—ã¦
  -- AddCommMonoid ã¨ CommMonoid ã¨åˆ†é…å…¬ç†ã‚’é †ã«è¨¼æ˜ã—ã¦ã„ã‘ã°å®Œæˆã™ã‚‹ã€‚
  -- ä»Šå›ã¯è¨­è¨ˆå›³ã¨ã—ã¦ `sorry` ã§ç½®ãã€‚
  admit

/--
  å°„å½± Ï€_C ã¯åŠç’°æº–åŒå‹å†™åƒã§ã‚ã‚‹:
    Ï€_C(a+b) = Ï€_C(a) + Ï€_C(b)
    Ï€_C(a*b) = Ï€_C(a) * Ï€_C(b)
    Ï€_C(0)   = 0
    Ï€_C(1)   = 1
  ã•ã‚‰ã«å…¨å°„ï¼ˆ`Quot` ã®æ€§è³ªï¼‰
-/
noncomputable def projHom :
    SemiringHomomorphism S (Quotient (C:=C)) :=
{ toFun := proj (C:=C)
, map_add := by
    intro a b; rfl    -- [a+b] by definition
, map_mul := by
    intro a b; rfl
, map_zero := rfl
, map_one  := rfl
}

lemma proj_surjective :
    Function.Surjective (proj (C:=C)) := by
  intro q
  refine Quot.induction_on q ?_
  intro a
  refine âŸ¨a, rflâŸ©

end SemiringCongruence


/-
    å®šç¾© 2.2.4 (æ ¸åˆåŒ)
    åŠç’°æº–åŒå‹å†™åƒ Ïˆ : Sâ‚ â†’ Sâ‚‚ ã«å¯¾ã—,
      Ker(Ïˆ) := {(a,b) âˆˆ Sâ‚Â² | Ïˆ(a)=Ïˆ(b)}
  ã“ã‚Œã‚’ Sâ‚ ä¸Šã®åˆåŒ (kernel congruence) ã¨ã™ã‚‹ã€‚
 -/

structure KernelCongruence
    {Sâ‚ : Type u} {Sâ‚‚ : Type v}
    [Semiring Sâ‚] [Semiring Sâ‚‚]
    (Ïˆ : SemiringHomomorphism Sâ‚ Sâ‚‚) : Prop :=
  (isCong :
    SemiringCongruence Sâ‚
      -- rel a b := Ïˆ a = Ïˆ b
      (
        { rel := fun a b => Ïˆ a = Ïˆ b
        , refl := by intro a; rfl
        , symm := by intro a b h; exact h.symm
        , trans := by
            intro a b c h1 h2
            exact h1.trans h2
        , add_compat := by
            intro a b a' b' h h'
            -- want Ïˆ(a+a')=Ïˆ(b+b')
            -- Ïˆ.map_add ã‚’ä½¿ã†
            calc
              Ïˆ (a + a')
                  = Ïˆ a + Ïˆ a' := Ïˆ.map_add a a' |> Eq.symm
              _ = Ïˆ b + Ïˆ b' := by simp [h, h']
              _ = Ïˆ (b + b') := Ïˆ.map_add b b'
        , mul_compat := by
            intro a b a' b' h h'
            -- Ïˆ(a*a') = Ïˆ(b*b')
            calc
              Ïˆ (a * a')
                  = Ïˆ a * Ïˆ a' := Ïˆ.map_mul a a' |> Eq.symm
              _ = Ïˆ b * Ïˆ b' := by simp [h, h']
              _ = Ïˆ (b * b') := Ïˆ.map_mul b b'
        } )
  )

/--
  ä¸Šã® KernelCongruence ã‹ã‚‰å®Ÿéš›ã® `SemiringCongruence Sâ‚` ã‚’å–ã‚Šå‡ºã—ãŸã„ã®ã§
  å…·ä½“çš„ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä¸ãˆã‚‹ helperã€‚
-/
def kerCongruence
    {Sâ‚ : Type u} {Sâ‚‚ : Type v}
    [Semiring Sâ‚] [Semiring Sâ‚‚]
    (Ïˆ : SemiringHomomorphism Sâ‚ Sâ‚‚) :
    SemiringCongruence Sâ‚ :=
{ rel := fun a b => Ïˆ a = Ïˆ b
, refl := by intro a; rfl
, symm := by intro a b h; exact h.symm
, trans := by
    intro a b c h1 h2
    exact h1.trans h2
, add_compat := by
    intro a b a' b' h h'
    calc
      Ïˆ (a + a')
          = Ïˆ a + Ïˆ a' := Ïˆ.map_add a a' |> Eq.symm
      _ = Ïˆ b + Ïˆ b' := by simp [h, h']
      _ = Ïˆ (b + b') := Ïˆ.map_add b b'
, mul_compat := by
    intro a b a' b' h h'
    calc
      Ïˆ (a * a')
          = Ïˆ a * Ïˆ a' := Ïˆ.map_mul a a' |> Eq.symm
      _ = Ïˆ b * Ïˆ b' := by simp [h, h']
      _ = Ïˆ (b * b') := Ïˆ.map_mul b b'
}


/-
    å‘½é¡Œ 2.2.5 (æº–åŒå‹å®šç†)
    Ïˆ : Sâ‚ â†’ Sâ‚‚ ãŒå…¨å°„åŠç’°æº–åŒå‹ã®ã¨ãï¼Œ
    Sâ‚ / Ker(Ïˆ) ã¨ Sâ‚‚ ã¯åŠç’°ã¨ã—ã¦åŒå‹ã§ã‚ã‚‹ã€‚

    Lean æ–¹é‡:
      â€¢ C := kerCongruence Ïˆ ã‚’ã¨ã‚‹
      â€¢ quotient C ã¨ Sâ‚‚ ã®é–“ã« isom ã‚’ä½œã‚‹ï¼š
           Ï†Ì„([a]) := Ïˆ(a)
        ã“ã‚Œã¯ well-definedï¼ˆa ~ a' â‡’ Ïˆ a = Ïˆ a'ï¼‰
        ã•ã‚‰ã«å…¨å°„ãƒ»å˜å°„ã«ãªã‚‹ (æœ¬ã®è¨¼æ˜ã¨åŒã˜)ã€‚
    ã“ã“ã§ã¯æ§‹æˆãƒ»å‹ã®ã¿ç¤ºã—ã€è¨¼æ˜ã®ç´°éƒ¨ã¯ `admit` ã§æ®‹ã™ã€‚
 -/

structure SemiringIso (R : Type u) (S : Type v)
  [Semiring R] [Semiring S] : Type (max u v) where
  toFun    : R â†’ S
  invFun   : S â†’ R
  -- æº–åŒå‹æ€§
  map_add  : âˆ€ a b, toFun (a + b) = toFun a + toFun b
  map_mul  : âˆ€ a b, toFun (a * b) = toFun a * toFun b
  map_zero : toFun 0 = 0
  map_one  : toFun 1 = 1
  left_inv  : âˆ€ x, invFun (toFun x) = x
  right_inv : âˆ€ y, toFun (invFun y) = y


namespace SemiringIso

/-- æº–åŒå‹å®šç†ã®ä¸»å¼µã®éª¨æ ¼ã€‚
    Ïˆ : Sâ‚ â†’ Sâ‚‚ ãŒå…¨å°„ã¨ã™ã‚‹ã€‚
    ã™ã‚‹ã¨ Sâ‚ / ker(Ïˆ) â‰… Sâ‚‚ ã¨ã„ã†åŒå‹ãŒå­˜åœ¨ã™ã‚‹ã€‚
-/
noncomputable def quotientKernelIso
    {Sâ‚ : Type u} {Sâ‚‚ : Type v}
    [Semiring Sâ‚] [Semiring Sâ‚‚]
    (Ïˆ : SemiringHomomorphism Sâ‚ Sâ‚‚)
    (hÏˆsurj : Function.Surjective Ïˆ) :
    SemiringIso
      (SemiringCongruence.Quotient (S:=Sâ‚)
        (kerCongruence (Sâ‚:=Sâ‚) (Sâ‚‚:=Sâ‚‚) Ïˆ))
      Sâ‚‚ :=
by
  -- è¨˜å·çŸ­ç¸®
  let C := kerCongruence (Sâ‚:=Sâ‚) (Sâ‚‚:=Sâ‚‚) Ïˆ
  -- å®šç¾©: Ï†Ì„([a]) := Ïˆ(a)
  let forward :
      SemiringCongruence.Quotient (S:=Sâ‚) C â†’ Sâ‚‚ :=
    fun q => Quot.induction_on q (fun a => Ïˆ a)
  -- é€†å†™åƒã¯ surjectivity ã‹ã‚‰ä»£è¡¨å…ƒã‚’å–ã‚‹
  choose pre pre_spec using hÏˆsurj
  -- pre : Sâ‚‚ â†’ Sâ‚  ã‹ã¤  Ïˆ (pre y) = y
  let backward : Sâ‚‚ â†’
      SemiringCongruence.Quotient (S:=Sâ‚) C :=
    fun y => Quot.mk _ (pre y)

  refine
  { toFun    := forward
  , invFun   := backward
  , map_add  := ?map_add
  , map_mul  := ?map_mul
  , map_zero := ?map_zero
  , map_one  := ?map_one
  , left_inv := ?left
  , right_inv:= ?right
  }
  Â· -- map_add
    intro q1 q2
    -- unfold forward; do Quot.induction_on q1 q2
    refine Quot.induction_on q1 ?hq1
    intro a
    refine Quot.induction_on q2 ?hq2
    intro b
    -- forward([a]+[b]) = Ïˆ(a+b) = Ïˆ(a)+Ïˆ(b) = forward[a]+forward[b]
    simp [forward,
          SemiringCongruence.qAdd,
          Ïˆ.map_add]
  Â· -- map_mul
    refine Quot.induction_on q1 ?hq1
    intro a
    refine Quot.induction_on q2 ?hq2
    intro b
    simp [forward,
          SemiringCongruence.qMul,
          Ïˆ.map_mul]
  Â· -- map_zero
    simp [forward, SemiringCongruence.qZero, Ïˆ.map_zero]
  Â· -- map_one
    simp [forward, SemiringCongruence.qOne, Ïˆ.map_one]
  Â· -- left_inv : backward âˆ˜ forward = id
    refine Quot.induction_on q1 ?hq1
    intro a
    -- backward(forward([a])) = backward(Ïˆ a) = [pre (Ïˆ a)]
    -- ã—ã‹ã— pre_spec : Ïˆ (pre y) = y, ç‰¹ã« y=Ïˆ a â‡’ Ïˆ(pre (Ïˆ a)) = Ïˆ a
    -- ã‚ˆã£ã¦ a ã¨ pre(Ïˆ a) ã¯ kerCongruence Ïˆ ã§åŒå€¤ãªã®ã§åŒã˜åŒå€¤é¡
    -- ã“ã‚Œã‚’ç¤ºã—ã¦ rfl
    have hker : (kerCongruence Ïˆ).rel a (pre (Ïˆ a)) := by
      -- need Ïˆ a = Ïˆ (pre (Ïˆ a))
      simpa [pre_spec (Ïˆ a)]
    -- 2ã¤ã®Quot.mkãŒåŒã˜ã«ãªã‚‹ã“ã¨ã‚’ç¤ºã™
    -- Quot.sound : rel a b â†’ Quot.mk _ a = Quot.mk _ b
    -- æœ€å¾Œã« `simp`
    apply Quot.sound
    exact hker
  Â· -- right_inv : forward âˆ˜ backward = id on Sâ‚‚
    intro y
    -- forward(backward y) = forward([pre y]) = Ïˆ(pre y) = y
    simpa [forward, backward, pre_spec y]

end SemiringIso

end TropicalGeometry


#min_imports
