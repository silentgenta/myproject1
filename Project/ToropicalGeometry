/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1（宋先生の定義に忠実に従った(可換な)Semiringの定義）
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : ∀ a : R, a * 0 = 0
  zero_mul : ∀ a : R, 0 * a = 0
  left_distrib  : ∀ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

--ついでに半体を定義
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) ≠ 1)
  (exists_inv  : ∀ {a : R}, a ≠ 0 → ∃ b : R, a * b = 1)

--加法的冪等の定義
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  ∀ a : R, a + a = a

--Ex2.1.2 𝔹=({0,-∞},max,+)は半体である
inductive 𝔹 : Type
| negInf
| zero

/-
つけておくといいことがあるとGPTからアドバイスあり
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero 𝔹 := ⟨𝔹.negInf⟩
instance : One  𝔹 := ⟨𝔹.zero⟩

instance : Add 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zero⟩

instance : Mul 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInf⟩

/- 加法について可換モノイド -/
instance : AddCommMonoid 𝔹 where
  add := (·+·)
  zero := (0 : 𝔹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- 乗法について可換モノイド -/
instance : CommMonoid 𝔹 where
  mul := (·*·)
  one := (1 : 𝔹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(半環準同型の定義)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 → S2
  map_add : ∀ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : ∀ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--今後ただの構造だってSemiringhomomorphismを関数として使えるようにする。これがないといちいちf.toFun xと書かなきゃいけなくなる。
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 → S2) where
  coe f := f.toFun

--simpを使えるように
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--恒等準同型の定義
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--準同型の合成の定義。半環準同型に必要な５要素を順に証明
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgは両辺に同じ関数を適用してよいという補題。f.map_addの両辺にgを適用したということ
      _ = g (f a) + g (f b) := by --_はg (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism
--10/9
--S₁代数の定義
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Ψ : SemiringHomomorphism B A) : Algebra A B :=
  ⟨Ψ⟩
--semiringhomoには名前のついていない関数があるのでそれをΨと名付ける。

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--AとBの間に必ず存在する半環準同型を一つ取り出すことが出来るようになる。reducibleにすることでalgeMapを使うと自動でh.homのような必ず存在する半環準同型を呼び出してくれる。

--simp用
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-代数準同型の定義
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A → X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A → Y
    --合成を示している(fとtoHomの合成がgと等しくなる。)
namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 可換図式--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)  --A→X(algebraMap)→Y(h.toHom)という写像の合成にaを適用
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g に a を適用
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) h.comm
  --congrArgは両辺に同じ関数を適用するときに使うコマンド。今回は「aを適用する」ということ自体が関数になっていて、それをh.comm(上のAlgHomの中にあるcomm)

end AlgHom


--A-代数準同型の存在
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  ∃ (Ψ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Ψ
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y
  --名前の衝突を防ぐためにscopedをつけておく。今後はopen　scoped TGAlgRelと書くとTropicalGeometry.AlgebraRel A X Y を省略できるようになる。(別ファイルからの参照)も可能

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--具体的な Ψ と可換性(Ψ があって、可換性も証明できたならAlgebraRel A X Yは存在しますよね」という補題)
theorem intro
  (Ψ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Ψ
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  ⟨Ψ, h⟩
  --∃ Ψ, P Ψという形の命題。よって、⟨ ⟩で具体的な写像と仮定をペアで羅列することで存在の証明は完了する。

--ひとつΨを取り出す。 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H
--defはHから具体的な写像Ψを取り出す操作を行うための定義。選択公理に依存しているのでnoncomputableで定義する。使う際はOpen classicalにすればよい。

--psiHで取り出したΨが図式を可換にする。 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--可換性の点ごとver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commで可換図式の関数の等式を取り出してcongrArgでaを適用するだけ
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) hc

end AlgebraRel

-- A-代数同型の定義
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- 互いに逆（AlgHom のフィールド toHom を一度だけ取り出して使う）
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
      --invHom.toHomとtoHom.toHomの合成で恒等写像を作り出す。invHomでAlgIsoからAlgHomを取り出し、toHomでAlgHomからSemiringhomomorphismを取り出す流れ。（AlgHomにも定義があるのでこれは入れ子構造）
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- 同型の順方向の底の準同型を取り出す。 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- 同型の逆方向の底の準同型を取り出す。 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv ∘ eはidentity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idにxを適用
  exact congrArg (fun (φ : SemiringHomomorphism X X) => φ x) e.left_inv

--e ∘ e.invはidentity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idにyを適用
  exact congrArg (fun (φ : SemiringHomomorphism Y Y) => φ y) e.right_inv

--対称性
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--10/17
--𝔹の導入
instance : Semiring 𝔹 where
  mul_zero := by intro a ; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  --<;>で直後のタクティクを全てのゴールに適用できる。
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl


--#check tauto


--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : 𝔹) + (1 : 𝔹)) = (1 : 𝔹) := rfl

--Aが加法冪等のとき，𝔹 → Aで半環準同型となる
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism 𝔹 A :=
{ --どの関数を対象にするかを指定する。-∞を0に対応させ、0を-1に対応させる。
  toFun := fun x =>
    match x with
    | 𝔹.negInf => 0
    | 𝔹.zero   => 1,

  --F(x + y) = F x + F yを示す。x,yの組み合わせには4通りあるので、以下の4つを
  map_add := by
    intro x y
    --x,yで総当たりを行う。
    cases x <;> cases y <;> simp
    /-· -- F(-∞ + -∞)：0 = 0 + 0
      exact (zero_add (0 : A)).symm
    · -- F(-∞ + 0)：1 = 0 + 1
      exact (zero_add (1 : A)).symm
    · -- F(0 + -∞)：1 = 1 + 0
      exact (add_zero (1 : A)).symm-/
    · -- F(0 + 0)：1 = 1 + 1（冪等性）
      exact (h (1 : A)).symm,

  --F(xy) = F(X)F(y)を示す。
  map_mul := by
    intro x y
    cases x <;> cases y 
    · -- F(-∞ * -∞)：0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    · -- F(-∞ * 0)：0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    · -- F(0 * -∞)：0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    · -- F(0 * 0)：1 = 1 * 1
      exact (one_mul (1 : A)).symm,

  --𝔹 では 0 : 𝔹 = 𝔹.negInf、 1 : 𝔹 = 𝔹.zero が既にインスタンスで入っている.
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 「A が加法冪等」↔「A が 𝔹-代数（存在する）」 -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A ↔ Nonempty (Algebra A 𝔹) := by
  constructor
  · -- (→) 加法冪等 ⇒ 𝔹-代数が存在
    intro h
    --Algebra.ofHomは準同型写像から𝔹代数の構造を作ってくれる。準同型写像はboolHomOfAddIdemで指定してあげる。
    exact ⟨Algebra.ofHom (boolHomOfAddIdem A h)⟩

  · -- (←) 𝔹-代数が存在 ⇒ 加法冪等
    intro hAlg
    --nonemptyの状態に具体的にどのようなものがあるかを与えている。Tactic stateのinstで指定されているSemiringを用いて具体的に一つ抽出する。
    rcases hAlg with ⟨inst⟩
    -- ψ : 𝔹 → Aを指定してあげる。Algebraのclassを参照すると.homがあるので、instを指定して写像を取り出す。
    let ψ : SemiringHomomorphism 𝔹 A := inst.hom
    -- 1_A = 1_A + 1_Aを作る。
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := ψ.map_add (1 : 𝔹) (1 : 𝔹)      -- ψ(1+1) = ψ1 + ψ1
      have h1 : ψ 1 = ψ 1 + ψ 1 := by
        --B_one_add_oneで1+1=1なので、Ψ(1+1)=Ψ(1)が言える。h0も合わせることで証明が完了する。
        simpa [B_one_add_one] using h0
      simpa [ψ.map_one] using h1
    -- 任意の a について a + a = a
    intro a
    -- a*1 = a*1 + a*1 を作る（左分配と h11A）
    have hmul : a * 1 = a * 1 + a * 1 := by
      --Semiring.left_distribで a*(1+1) = a*1 + a*1 に対して，(1+1) → 1 へ書き換えh11Aを両辺入れ替えて適用。
     simpa [← h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- あとは mul_one で仕上げ
    -- （向きを合わせるために対称を取る）
    --have : a + a = a := by
    simpa [mul_one] using hmul.symm
    --exact this



--≤ₐの定義

section OrderFromAddIdem

variable {A : Type u} [Semiring A]

--a ≤ₐ bをa + b = bとする。
def leA (a b : A) : Prop := a + b = b

--反射律
theorem leA_refl (h : AddIdempotent A) (a : A) : leA a a := by
  unfold leA
  simpa using h a

--推移律
theorem leA_trans (a b c : A)
    (hab : leA  a b) (hbc : leA  b c) :
    leA  a c := by
  unfold leA at * -- hab hbc ⊢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--反対称律
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at * -- hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0は最小元
theorem bot_leA (a : A) : leA  (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA  a b) :
    leA  (c * a) (c * b) := by
  unfold leA at * -- hab ⊢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

--10/31
universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  ∀ ⦃a b c : A⦄, a * b = a * c → a = (0 : A) ∨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--こんご便利になる(らしい)補題
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a ≠ (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  · exact (ha hzero).elim
  · exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--分母が 0 でない組 (a,b)の集合を定義
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A × A // p.2 ≠ (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- 分子 / 分母を記号で短縮
def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b ≠ 0) :
    num (A:=A) ⟨(a,b), hb⟩ = a := rfl
@[simp] lemma den_mk (a b : A) (hb : b ≠ 0) :
    den (A:=A) ⟨(a,b), hb⟩ = b := rfl
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p ≠ 0 := p.2

--同値関係
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--反射律
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--対称律
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

--推移律
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q r → Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q ≠ (0 : A) := den_ne_zero (A:=A) q

  -- ① (hpq) を右から r.den で掛け、形を q.den * (p.num * r.den) = r.den * (q.num * p.den)に整える
  have h1' :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- ② (hqr) を右から p.den で掛け、形を q.den * (r.num * p.den) = r.den * (q.num * p.den)に整える
  have h2' :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- ③ 同じ右辺を経由して q.den を左から消去
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1'.trans h2'.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aのRelは（cancellativeの下で）同値関係になる。  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    ⟨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) ⟩

end FracCarrier
end TropicalGeometry

namespace TropicalGeometry
open Classical

/- 商集合 Q(A) を作り、要素を a/b と書けるようにする -/

section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

/-- A の分数の商集合：`Q(A) := {(a,b) | b ≠ 0}/∼` -/
def Q : Type u := Quot (FracCarrier.setoid (A:=A) hC)

/-- 基本コンストラクタ：`a/b`（ただし `b ≠ 0`）を同値類に持ち上げる。 -/
def Q.mk (a b : A) (hb : b ≠ 0) : Q (A:=A) hC :=
  Quot.mk _ ⟨(a,b), hb⟩

/-- 「非零の分母」を包むミニ構造体。`⟨b, hb⟩ : NZDen A`。 -/
structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val ≠ 0

namespace Q

/-- 記法 `a / ⟨b, hb⟩` の本体：`Q.mk a b hb`。 -/
def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-! ### 記法

- まずこのセクション内だけ有効な **ローカル記法**。
  セクション変数 `hC` が見えるので、`a / b` がそのまま使えます。
- 併せて、任意の場所で使える **スコープ付き記法** `a /[hC] b` も用意。
  こちらは `hC` を明示するので前チェックに引っかかりません。
-/

/-- セクション内限定：`a / b : Q(A,hC)` （`b : NZDen A`） --/
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

/-- どこでも使える版：`a /[hC] b` （`b : NZDen A`） --/
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic
end TropicalGeometry

namespace TropicalGeometry
open Classical


section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- ここでの Q は「QuotBasic」で定義したものを使う（重複定義しない）

namespace FracCarrier

/-- 分母同士の積は 0 にならない（`Cancellative` を利用） -/
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den ≠ 0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 から p.den * q.den = p.den * 0 を得る
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _
    exact h.trans hz.symm
  -- 左から cancel
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

/-- 商和の「代表」： (a/b) + (c/d) := (ad + cb) / (bd) -/
def addRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ⟨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ⟩

/-- 商積の「代表」： (a/b) * (c/d) := (ac) / (bd) -/
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ⟨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ⟩

/-- 加法が同値関係と両立（well-defined） -/
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  -- 目標： (p.num*q.den + q.num*p.den)*(p'.den*q'.den)
  --     = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
  unfold Rel addRep
  -- (x+y)*z = x*z + y*z
  have H₀ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  -- 1段目：単純分配
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by
            simpa using H₀
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by
            -- かけ算の順序・結合の入れ替え
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            -- 右辺のペアの順序も入れ替える
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by
            -- 逆向きの分配（(a*c)+(b*c) = (a+b)*c）
            have H₁ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            -- 項の順序を `simp` で合わせてから対称を使う
            simpa [mul_comm, mul_left_comm, mul_assoc] using H₁.symm

/-- 乗法が同値関係と両立（well-defined） -/
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  -- 目標： (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den)
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

/-- Q(A) 上の加法（2段階 `Quot.lift` 方式） -/
noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  -- まず「右引数 q を代表に戻してから addRep を持ち上げる」関数を作る
  let addCore₁ :
      FracCarrier A → (Q (A:=A) hC → Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' のときも well-defined
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  -- 次に「左引数 p を代表に戻し、addCore₁ p を選ぶ」関数を作る
  let addCore₂ : Q (A:=A) hC → (Q (A:=A) hC → Q (A:=A) hC) :=
    Quot.lift
      (fun p => addCore₁ p)
      (by
        -- p ~ p' なら、関数 addCore₁ p = addCore₁ p'
        intro p p' hp
        apply funext
        intro y
        -- y も代表に戻して同値を作る
        refine Quot.induction_on y ?_
        intro q
        -- 目標を書き換え（2つの mk の等しさを示せばよい）
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        -- これは addRep_compat の (hp, refl) で成立
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- 以上を使って x, y に適用
  exact addCore₂ x y


/-- Q(A) 上の乗法（2段階 `Quot.lift` 方式） -/
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCore₁ :
      FracCarrier A → (Q (A:=A) hC → Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCore₂ : Q (A:=A) hC → (Q (A:=A) hC → Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCore₁ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCore₂ x y

end QAddMul
end TropicalGeometry

namespace TropicalGeometry
open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) (h10 : (1 : A) ≠ 0)

-- 0,1 の代表（分母 1 を使用）
def Q.zero : Q (A:=A) hC := Q.mk (A:=A) hC 0 1 h10
def Q.one  : Q (A:=A) hC := Q.mk (A:=A) hC 1 1 h10

-- 既に定義済みの Q.add / Q.mul を使ってインスタンス化


instance : Zero (Q (A:=A) hC) := ⟨Q.zero (A:=A) hC h10⟩
instance : One  (Q (A:=A) hC) := ⟨Q.one  (A:=A) hC h10⟩
noncomputable instance : Add  (Q (A:=A) hC) := ⟨Q.add (A:=A) hC⟩
noncomputable instance : Mul  (Q (A:=A) hC) := ⟨Q.mul (A:=A) hC⟩

namespace FracCarrier

variable {hC}

/-- 加法の可換性（代表版） -/
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  -- Rel と addRep, num, den を展開して目標式を素の等式に落とす
  unfold Rel addRep num den
  -- 目標：
  -- (p.num*q.den + q.num*p.den) * (q.den*p.den)
  --   = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  -- 和の順序と分母側の積の順序を入れ替えるだけで一致
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          -- 和の順序だけを可換法則で入れ替え
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          -- 分母側の積の順序を可換法則で入れ替え
          ac_rfl

/-- 加法の結合性（代表版） -/
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  unfold Rel addRep
  set a := p.num; set b := p.den
  set c := q.num; set d := q.den
  set e := r.num; set f := r.den
  let k₁ := b * (d * f)
  let k₂ := (b * d) * f

  /- 左辺を 3 項に -/
  have HL1 :
      ((a*d + c*b) * f + e * (b*d)) * k₁
        = ((a*d + c*b) * f) * k₁ + (e * (b*d)) * k₁ := by
    simpa using
      (Semiring.right_distrib (R:=A) ((a*d + c*b) * f) (e * (b*d)) k₁)

  -- ((a*d + c*b) * f) * k₁ = (a*d)*(f*k₁) + (c*b)*(f*k₁)
  have HL2 :
      ((a*d + c*b) * f) * k₁
        = (a*d) * (f * k₁) + (c*b) * (f * k₁) := by
    -- ((x+y)*f)*k₁ = (x+y)*(f*k₁) にしてから right_distrib
    have := Semiring.right_distrib (R:=A) (a*d) (c*b) (f * k₁)
    simpa [mul_assoc] using this

  -- 左辺まとめ
  have HL :
      ((a*d + c*b) * f + e * (b*d)) * k₁
        = a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁ := by
    calc
      ((a*d + c*b) * f + e * (b*d)) * k₁
          = ((a*d + c*b) * f) * k₁ + (e * (b*d)) * k₁ := HL1
      _ = ((a*d) * (f * k₁) + (c*b) * (f * k₁)) + (e * (b*d)) * k₁ := by
            simp [HL2]
      _ = a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁ := by
            simp [mul_assoc]

  /- 右辺を 3 項に -/
  have HR1 :
      (a * (d*f) + (c*f + e*d) * b) * k₂
        = (a * (d*f)) * k₂ + ((c*f + e*d) * b) * k₂ := by
    simpa using
      (Semiring.right_distrib (R:=A) (a * (d*f)) ((c*f + e*d) * b) k₂)

  -- ((c*f + e*d) * b) * k₂ = (c*f)*(b*k₂) + (e*d)*(b*k₂)
  have HR2' :
      ((c*f + e*d) * b) * k₂
        = (c*f) * (b * k₂) + (e*d) * (b * k₂) := by
    have := Semiring.right_distrib (R:=A) (c*f) (e*d) (b * k₂)
    simpa [mul_assoc] using this

  have HR :
      (a * (d*f) + (c*f + e*d) * b) * k₂
        = a * (d*f) * k₂ + (c*f) * b * k₂ + (e*d) * b * k₂ := by
    calc
      (a * (d*f) + (c*f + e*d) * b) * k₂
          = (a * (d*f)) * k₂ + ((c*f + e*d) * b) * k₂ := HR1
      _ = (a * (d*f)) * k₂ + ((c*f) * (b * k₂) + (e*d) * (b * k₂)) := by
            simp [HR2']
      _ = a * (d*f) * k₂ + (c*f) * b * k₂ + (e*d) * b * k₂ := by
            simp [mul_assoc, add_assoc]

  -- k₁ と k₂ は結合法で同じ（←ここを修正）
  have k_same : k₁ = k₂ := by
    -- k₁ = b * (d * f)
    -- k₂ = (b * d) * f
    -- mul_assoc b d f : (b * d) * f = b * (d * f)
    -- simp で両辺を同じ形に正規化してくれる
    simp [k₁, k₂, mul_assoc]

  -- 3項の和の並び替え（括弧外しを含む）
  have align :
      a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁
        = a*(d*f)*k₂ + (c*f)*b*k₂ + (e*d)*b*k₂ := by 
        simp [k_same, mul_assoc, mul_comm, mul_left_comm]
    -- まず k₁ を k₂ に置換してから ac で並べ替え
    /-simpa [k_same, mul_assoc, mul_comm, mul_left_comm] using
      (by
         have : a*d*f*k₂ + c*b*f*k₂ + e*(b*d)*k₂
              = a*(d*f)*k₂ + (c*f)*b*k₂ + (e*d)*b*k₂ := by
            ac_rfl
         exact this)-/

  -- まとめ
  calc
    ((a*d + c*b) * f + e * (b*d)) * k₁
        = a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁ := HL
    _   = a*(d*f)*k₂ + (c*f)*b*k₂ + (e*d)*b*k₂ := align
    _   = (a * (d*f) + (c*f + e*d) * b) * k₂ := HR.symm





/-- 乗法の可換性（代表版） -/
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  -- (p.num*q.num)*(p.den*q.den) と (q.num*p.num)*(q.den*p.den)
  -- は ac で一致
  simp [mul_comm,  mul_assoc]

/-- 乗法の結合性（代表版） -/
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  -- どちらも分子 p.num*q.num*r.num，分母 p.den*q.den*r.den （順序違い）になるので ac
  simp [mul_comm,  mul_assoc]

/-- 左分配（代表版） -/
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- まず p,q,r の中身を素の変数名にばらす
  rcases p with ⟨⟨pn, pd⟩, hp0⟩
  rcases q with ⟨⟨qn, qd⟩, hq0⟩
  rcases r with ⟨⟨rn, rd⟩, hr0⟩

  -- Rel, addRep, mulRep を展開して、A 上の等式に落とす
  unfold Rel addRep mulRep
  -- FracCarrier.num / den はただの fst / snd
  simp [FracCarrier.num, FracCarrier.den]

  /-
  いまゴール（≒タクティク状態のターゲット）は：
    pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
      =
    (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
      * (pd * (qd * rd))

  これを2段ロケットで示す：
   (1) 左辺 = pn * (qn*rd + rn*qd) * X
   (2) その X 版から最終右辺へ
  を合成する。
  -/

  -- まず分母側の大きい積を名前付けしておく
  set X : A := pd * qd * (pd * rd) with hX
  set Y : A := pd * (qd * rd) with hY

  -- (1) 左辺を pn * (qn*rd + rn*qd) * X という「標準形」に寄せる
  have lhs_reassoc :
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
        =
      pn * (qn * rd + rn * qd) * X := by
    -- まず (pd * (qd * (pd * rd))) を assoc で (pd * qd) * (pd * rd) 型にする
    have tail_assoc :
        pd * (qd * (pd * rd))
          = pd * qd * (pd * rd) := by
      -- (pd * (qd * Z)) = (pd * qd) * Z, and reassociate
      simp [mul_assoc]
    calc
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
          = pn * ((qn * rd + rn * qd) * (pd * qd * (pd * rd))) := by
              simp [tail_assoc]
      _   = pn * (qn * rd + rn * qd) * (pd * qd * (pd * rd)) := by
              -- reassociate pn * ((...) * (...)) → pn * (...) * (...)
              simp [mul_assoc]
      _   = pn * (qn * rd + rn * qd) * X := by
              simp [hX]

  -- (2a) 左側：pn * (qn*rd + rn*qd) * X を足し算に展開
  --      = pn*(qn*rd)*X + pn*(rn*qd)*X
  have left_expand :
      pn * (qn * rd + rn * qd) * X
        =
      pn * (qn * rd) * X + pn * (rn * qd) * X := by
    -- まず (qn*rd + rn*qd) * X を右分配
    have inner :
        (qn * rd + rn * qd) * X
          =
        (qn * rd) * X + (rn * qd) * X := by
      -- right_distrib: (a+b)*c = a*c + b*c
      have tmp :=
        Semiring.right_distrib (R:=A) (qn * rd) (rn * qd) X
      simpa using tmp
    -- 次に pn * [...] を左分配
    -- pn * ( (qn*rd)*X + (rn*qd)*X )
    --   = pn*(qn*rd)*X + pn*(rn*qd)*X
    have tmp2 :=
      Semiring.left_distrib (R:=A) pn ((qn * rd) * X) ((rn * qd) * X)
    -- tmp2 :
    --   pn * ((qn * rd) * X + (rn * qd) * X)
    --     =
    --   pn * ((qn * rd) * X) + pn * ((rn * qd) * X)
    simpa [inner, mul_assoc] using tmp2

  -- (2b) 右側の和を別の形に展開：
  --   (pn*qn*(pd*rd) + pn*rn*(pd*qd)) * Y
  --   = pn*qn*(pd*rd)*Y + pn*rn*(pd*qd)*Y
  have right_expand :
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y
        =
      pn * qn * (pd * rd) * Y
      + pn * rn * (pd * qd) * Y := by
    -- これも right_distrib
    have tmp :=
      Semiring.right_distrib (R:=A)
        (pn * qn * (pd * rd))
        (pn * rn * (pd * qd))
        Y
    simpa [mul_assoc] using tmp

  -- (2c) 個々の項が同じものを掛け算の順序替えで表現してることを示す
  --      pn * (qn * rd) * X  =  pn * qn * (pd * rd) * Y
  have term1_match :
      pn * (qn * rd) * X
        =
      pn * qn * (pd * rd) * Y := by
    -- 両辺とも可換・結合の並べ替えだけで一致する
    simp [X, Y, hY, mul_comm, mul_left_comm]

  --      pn * (rn * qd) * X  =  pn * rn * (pd * qd) * Y
  have term2_match :
      pn * (rn * qd) * X
        =
      pn * rn * (pd * qd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  -- (2d) 右側の「pd*(qd*rd)」に戻すための再結合
  --  (pn*(qn*(pd*rd)) + pn*(rn*(pd*qd))) * (pd*(qd*rd))
  --   と
  --  (pn*qn*(pd*rd) + pn*rn*(pd*qd)) * Y
  --  が同じだという補題
  have rhs_reassoc :
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
        =
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
    calc
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
          =
        ((pn * qn * (pd * rd)) + (pn * rn * (pd * qd)))
          * (pd * (qd * rd)) := by
            -- assocで pn*(qn*...) = pn*qn*..., 同様に rn側も
            simp [mul_assoc]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
            simp [hY]

  ----------------------------------------------------------------
  -- (2e) “X 形” から “最終右辺”までの鎖を mid_chain として証明
  ----------------------------------------------------------------
  have mid_chain :
      pn * (qn * rd + rn * qd) * X
        =
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := by
    -- ここは calc を使って大丈夫。スタートとゴールがハッキリ一致してるから。
    calc
      pn * (qn * rd + rn * qd) * X
          =
        pn * (qn * rd) * X + pn * (rn * qd) * X := left_expand
      _ =
        pn * qn * (pd * rd) * Y
        + pn * rn * (pd * qd) * Y := by
          simp [term1_match, term2_match]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y :=
          (right_expand.symm)
      _ =
        (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := rhs_reassoc.symm

  ----------------------------------------------------------------
  -- 最後に、(1) と mid_chain を合成して元のゴールを証明
  ----------------------------------------------------------------
  grind
  --exact lhs_reassoc.trans mid_chain

/-- 右分配（代表版） -/
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by

  /- まず分子・分母を素の変数にばらす -/
  rcases p with ⟨⟨pn, pd⟩, hp0⟩
  rcases q with ⟨⟨qn, qd⟩, hq0⟩
  rcases r with ⟨⟨rn, rd⟩, hr0⟩

  /- `Rel` と `addRep` / `mulRep` を展開して，
     Q(A) 上の等式を A の等式に落とす -/
  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  /-
  いまゴールは（可換・結合の違い以外は）次の形になっているはず：

    ((pn * qd + qn * pd) * rn) * ((pd * rd) * (qd * rd))
      =
    ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * ((pd * qd) * rd)

  左辺・右辺の「でかい分母部分」を変数に取っておく：
    X := (pd * rd) * (qd * rd)
    Y := (pd * qd) * rd
  -/

  set X : A := (pd * rd) * (qd * rd) with hX
  set Y : A := (pd * qd) * rd with hY

  /- `*` の結合法則で左側を「((...)*rn) * X」から「(...)*rn*X」に寄せる -/
  have lhs_reassoc :
      ((pn * qd + qn * pd) * rn) * X
        =
      (pn * qd + qn * pd) * rn * X := by
    simp [X, mul_assoc]

  /- 左辺を分配で 2 項の和に分ける。
     (pn*qd + qn*pd) * rn * X
       = (pn*qd)*rn*X + (qn*pd)*rn*X
  -/
  have left_expand :
      (pn * qd + qn * pd) * rn * X
        =
      (pn * qd) * rn * X + (qn * pd) * rn * X := by
    -- まず一次分配：(a+b)*rn = a*rn + b*rn
    have step1 :
        (pn * qd + qn * pd) * rn
          =
        (pn * qd) * rn + (qn * pd) * rn := by
      simpa using
        Semiring.right_distrib (R:=A) (pn * qd) (qn * pd) rn
    -- それにさらに * X を右から掛けてもう一度分配
    calc
      (pn * qd + qn * pd) * rn * X
          = ((pn * qd) * rn + (qn * pd) * rn) * X := by
              simp [step1]
      _   = (pn * qd) * rn * X + (qn * pd) * rn * X := by
              simpa [mul_assoc] using
                Semiring.right_distrib (R:=A)
                  ((pn * qd) * rn) ((qn * pd) * rn) X

  /- 右辺側も同様に、
     ((pn*rn)*(qd*rd) + (qn*rn)*(pd*rd)) * Y
       = (pn*rn)*(qd*rd)*Y + (qn*rn)*(pd*rd)*Y
  -/
  have right_expand :
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y
        =
      (pn * rn) * (qd * rd) * Y + (qn * rn) * (pd * rd) * Y := by
    simpa [mul_assoc] using
      Semiring.right_distrib (R:=A)
        ((pn * rn) * (qd * rd)) ((qn * rn) * (pd * rd)) Y

  /- 各項どうしが一致することを示す：
       (pn * qd) * rn * X
         = (pn * rn) * (qd * rd) * Y
     これは可換・結合の並べ替えだけで証明できる
  -/
  have term1_match :
      (pn * qd) * rn * X
        =
      (pn * rn) * (qd * rd) * Y := by
    -- それぞれを `pn * rn * qd * qd * pd * rd * rd` 型まで整形
    simp [X, Y, mul_comm, mul_left_comm]

  /- 同様に 2 個目の項：
       (qn * pd) * rn * X
         = (qn * rn) * (pd * rd) * Y
  -/
  have term2_match :
      (qn * pd) * rn * X
        =
      (qn * rn) * (pd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  /- 以上をまとめる。
     まず左辺を `lhs_reassoc` で (pn*qd+qn*pd)*rn*X に寄せる。
     次に `left_expand` で 2 項に分ける。
     それぞれ `term1_match` / `term2_match` で右辺の形にそろえる。
     最後に `right_expand`.symm で再び和を一つの積にまとめる。
     その結果が最終的な右辺 ((pn*rn)*(qd*rd) + (qn*rn)*(pd*rd)) * Y になる。
  -/
  have mid_chain :
      (pn * qd + qn * pd) * rn * X
        =
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
    calc
      (pn * qd + qn * pd) * rn * X
          = (pn * qd) * rn * X + (qn * pd) * rn * X := left_expand
      _   = (pn * rn) * (qd * rd) * Y
            + (qn * rn) * (pd * rd) * Y := by
              simp [term1_match, term2_match]
      _   = ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
              simpa [mul_assoc] using right_expand.symm

  /- 仕上げ：
     LHS = ((pn*qd + qn*pd) * rn) * X
         = (pn*qd + qn*pd) * rn * X          (lhs_reassoc)
         = ... = RHS                         (mid_chain)
  -/
  exact lhs_reassoc.trans mid_chain



end FracCarrier

/-************************ ここから構造を持ち上げる ************************-/

-- 加法群律（加法：可換・結合・0 は単位）
instance : AddCommMonoid (Q (A:=A) hC) where
  add := (· + ·)
  zero := (0 : Q (A:=A) hC)
  add_assoc := by
    intro x y z
    -- 3 変数の `Quot` 降ろし → 代表版補題 → `Quot.sound`
    refine Quot.induction_on x ?hx |>.trans ?_
    · intro p; refine Quot.induction_on y ?hy
      · intro q; refine Quot.induction_on z ?hz
        · intro r
          apply Quot.sound
          exact FracCarrier.addRep_assoc (A:=A) hC p q r
    · -- 合体
      rfl
  zero_add := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    -- 0 + p = p
    -- 代表 0 は (0,1)
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC
                   ⟨(0,1), h10⟩ p)
        = Quot.mk _ p
    apply Quot.sound
    -- (0/1)+ (a/b) ~ (a/b)
    -- これは addRep_compat に rel_refl と、(0,1) ~ (0,1) を使えばOK（自明）
    -- 直接等式でも良いが、Rel で押す：
    -- addRep_compat (refl, refl) では足りないので、実際の等式で証明
    -- 0/1 + a/b = (0*b + a*1)/(1*b) ~ a/b は代表計算で分子が a*b に一致
    -- すなわち Rel: (a*1)*(1*b) = (a*b)*(1*1)
    -- 直接書く：
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]

  add_zero := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC p ⟨(0,1), h10⟩)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]
  add_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q
  nsmul := fun n x =>
    Nat.recOn n (0) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

-- 乗法モノイド（可換）
instance : CommMonoid (Q (A:=A) hC) where
  mul := (· * ·)
  one := (1 : Q (A:=A) hC)
  mul_assoc := by
    intro x y z
    refine Quot.induction_on x ?hx |>.trans ?_
    · intro p; refine Quot.induction_on y ?hy
      · intro q; refine Quot.induction_on z ?hz
        · intro r
          apply Quot.sound
          exact FracCarrier.mulRep_assoc (A:=A) hC p q r
    · rfl
  one_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ⟨(1,1), h10⟩ p)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_one := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(1,1), h10⟩)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q
  npow := fun n x =>
    Nat.recOn n (1) (fun _ s => s * x)

/-- 分配・零吸収を持ち上げて Semiring インスタンス -/
instance : Semiring (Q (A:=A) hC) where
  mul_zero := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    -- p * 0 = 0
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(0,1), h10⟩)
        = (0 : Q (A:=A) hC)
    -- 右辺の 0 は ⟨(0,1),h10⟩ の同値類
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(0,1), h10⟩)
        = Quot.mk _ ⟨(0,1), h10⟩
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  zero_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ⟨(0,1), h10⟩ p)
        = Quot.mk _ ⟨(0,1), h10⟩
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    -- p * (q + r) = p*q + p*r  を `Rel` で主張
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r
  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r

/********************* 逆元の存在：Semifield 仕上げ *********************/

-- 「0 でない元 x は、何らかの代表 p で p.num ≠ 0」を使って逆を立てる。
-- x = [a/b]（b≠0）で a ≠ 0 なら逆は [b/a]。
-- x = 0 のとき（つまり任意代表が a=0）以外はこれで十分。
-- そこでまず、0 判定の補題を作る。

namespace FracCarrier

/-- [a/b] = 0 であることの代表版判定：a = 0 -/
lemma zero_iff_num_eq_zero (hC : Cancellative A)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p ⟨(0,1), by exact (show (1:A) ≠ 0 from ?_)⟩
      ↔ p.num = 0 := by
  -- ここでは `?_.` に `h10` を入れたいので、外側で使う形に書き換えます。
  -- 実運用では直接使わず、下の `nonzero_num_of_ne_zero` で `h10` を受け渡します。
  admit

end FracCarrier

/-- 非零元は分子が非零な代表を持つ -/
lemma nonzero_num_of_ne_zero
    {x : Q (A:=A) hC} (hx : x ≠ 0) :
    ∃ p : FracCarrier A, Quot.mk _ p = x ∧ p.num ≠ 0 := by
  -- x を代表 p に降ろす。もし p.num = 0 なら x = 0 に矛盾。
  refine Quot.induction_on x (fun p => ?_) 
  intro p
  by_cases hp : p.num = 0
  · -- この場合、[p] = 0 になってしまう
    have : Quot.mk _ p = (0 : Q (A:=A) hC) := by
      -- 0 は ⟨(0,1),h10⟩ の同値類
      change Quot.mk _ p = Quot.mk _ ⟨(0,1), h10⟩
      apply Quot.sound
      -- Rel: p.num*1 = 0 * p.den
      unfold FracCarrier.Rel FracCarrier.num FracCarrier.den
      simp [hp, Semiring.one_mul, Semiring.zero_mul]
    exact (hx (by simpa using this)).elim
  · exact ⟨p, rfl, hp⟩

/-- Q(A) は Semifield：0≠1 と「非零に逆」 -/
noncomputable instance : Semifield (Q (A:=A) hC) where
  -- 既に Semiring インスタンスはある
  zero_ne_one := by
    -- 0 ≠ 1 は代表 0/1 と 1/1 が異なることに帰着（h10 を使用）
    -- Rel で等しいと仮定すると 0=1 に矛盾
    intro h01
    -- 0 = 1 なら、その代表が Rel で等しい
    -- (0*1) * (1*1) = (1*1) * (0*1) を見ると 0=1 を強いる
    have : (0 : A) = 1 := by
      -- `Quot.eqv_iff_eq` は使えないので、等しいと仮定したら Rel が成り立つはず
      -- ここは手短に：もし 0=1 なら h10 に反する、という形に変換
      -- 実際には 0=1 を導く代表計算でも OK
      -- 簡略化のために反証法：h10 : 1 ≠ 0
      exact (h10 (by simpa))
    -- 矛盾
    exact (by have := this.symm; simpa using this)
  exists_inv := by
    intro x hx
    -- 非零なら代表 p で p.num ≠ 0 が取れる
    rcases nonzero_num_of_ne_zero (A:=A) hC h10 hx with ⟨p, rfl, hp⟩
    -- 逆は [p.den/p.num]
    refine ⟨
      Quot.mk _ ⟨(p.den, p.num), hp⟩,
      ?goal
    ⟩
    -- 証明： [p]*[p.den/p.num] = 1
    -- 代表計算： (p.num/p.den) * (p.den/p.num) = (p.num*p.den)/(p.den*p.num) ~ 1/1
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p ⟨(p.den, p.num), hp⟩)
        = (1 : Q (A:=A) hC)
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p ⟨(p.den, p.num), hp⟩)
        = Quot.mk _ ⟨(1,1), h10⟩
    apply Quot.sound
    -- Rel の式に落とす
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    -- (p.num*p.den) * (1*1) = (1*p.num) * (p.den*p.num)
    -- 可換結合で `ac_rfl`
    have h1 : (p.num * p.den) * (1 * 1)
            = p.num * p.den := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    have h2 : (1 * p.num) * (p.den * p.num)
            = p.num * p.den * p.num := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    -- 左右とも p.num*p.den*p.num に落ちる
    simpa [h1, h2, Semiring.one_mul,
           mul_comm, mul_left_comm, mul_assoc]

end QSemiring
end TropicalGeometry




#min_imports
