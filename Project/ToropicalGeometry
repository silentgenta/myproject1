/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1（宋先生の定義に忠実に従った(可換な)Semiringの定義）
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : ∀ a : R, a * 0 = 0
  zero_mul : ∀ a : R, 0 * a = 0
  left_distrib  : ∀ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

--ついでに半体を定義
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) ≠ 1)
  (exists_inv  : ∀ {a : R}, a ≠ 0 → ∃ b : R, a * b = 1)

--加法的冪等の定義
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  ∀ a : R, a + a = a

--Ex2.1.2 𝔹=({0,-∞},max,+)は半体である
inductive 𝔹 : Type
| negInf
| zero

/-
つけておくといいことがあるとGPTからアドバイスあり
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero 𝔹 := ⟨𝔹.negInf⟩
instance : One  𝔹 := ⟨𝔹.zero⟩

instance : Add 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zero⟩

instance : Mul 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInf⟩

/- 加法について可換モノイド -/
instance : AddCommMonoid 𝔹 where
  add := (·+·)
  zero := (0 : 𝔹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- 乗法について可換モノイド -/
instance : CommMonoid 𝔹 where
  mul := (·*·)
  one := (1 : 𝔹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(半環準同型の定義)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 → S2
  map_add : ∀ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : ∀ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--今後ただの構造だってSemiringhomomorphismを関数として使えるようにする。これがないといちいちf.toFun xと書かなきゃいけなくなる。
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 → S2) where
  coe f := f.toFun

--simpを使えるように
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--恒等準同型の定義
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--準同型の合成の定義。半環準同型に必要な５要素を順に証明
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgは両辺に同じ関数を適用してよいという補題。f.map_addの両辺にgを適用したということ
      _ = g (f a) + g (f b) := by --_はg (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism
--10/9
--S₁代数の定義
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Ψ : SemiringHomomorphism B A) : Algebra A B :=
  ⟨Ψ⟩
--semiringhomoには名前のついていない関数があるのでそれをΨと名付ける。

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--AとBの間に必ず存在する半環準同型を一つ取り出すことが出来るようになる。reducibleにすることでalgeMapを使うと自動でh.homのような必ず存在する半環準同型を呼び出してくれる。

--simp用
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-代数準同型の定義
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A → X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A → Y
    --合成を示している(fとtoHomの合成がgと等しくなる。)
namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 可換図式--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)  --A→X(algebraMap)→Y(h.toHom)という写像の合成にaを適用
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g に a を適用
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) h.comm
  --congrArgは両辺に同じ関数を適用するときに使うコマンド。今回は「aを適用する」ということ自体が関数になっていて、それをh.comm(上のAlgHomの中にあるcomm)

end AlgHom


--A-代数準同型の存在
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  ∃ (Ψ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Ψ
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y
  --名前の衝突を防ぐためにscopedをつけておく。今後はopen　scoped TGAlgRelと書くとTropicalGeometry.AlgebraRel A X Y を省略できるようになる。(別ファイルからの参照)も可能

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--具体的な Ψ と可換性(Ψ があって、可換性も証明できたならAlgebraRel A X Yは存在しますよね」という補題)
theorem intro
  (Ψ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Ψ
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  ⟨Ψ, h⟩
  --∃ Ψ, P Ψという形の命題。よって、⟨ ⟩で具体的な写像と仮定をペアで羅列することで存在の証明は完了する。

--ひとつΨを取り出す。 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H
--defはHから具体的な写像Ψを取り出す操作を行うための定義。選択公理に依存しているのでnoncomputableで定義する。使う際はOpen classicalにすればよい。

--psiHで取り出したΨが図式を可換にする。 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--可換性の点ごとver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commで可換図式の関数の等式を取り出してcongrArgでaを適用するだけ
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) hc

end AlgebraRel

-- A-代数同型の定義
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- 互いに逆（AlgHom のフィールド toHom を一度だけ取り出して使う）
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
      --invHom.toHomとtoHom.toHomの合成で恒等写像を作り出す。invHomでAlgIsoからAlgHomを取り出し、toHomでAlgHomからSemiringhomomorphismを取り出す流れ。（AlgHomにも定義があるのでこれは入れ子構造）
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- 同型の順方向の底の準同型を取り出す。 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- 同型の逆方向の底の準同型を取り出す。 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv ∘ eはidentity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idにxを適用
  exact congrArg (fun (φ : SemiringHomomorphism X X) => φ x) e.left_inv

--e ∘ e.invはidentity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idにyを適用
  exact congrArg (fun (φ : SemiringHomomorphism Y Y) => φ y) e.right_inv

--対称性
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--10/17
--𝔹の導入
instance : Semiring 𝔹 where
  mul_zero := by intro a ; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  --<;>で直後のタクティクを全てのゴールに適用できる。
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl


--#check tauto


--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : 𝔹) + (1 : 𝔹)) = (1 : 𝔹) := rfl

--Aが加法冪等のとき，𝔹 → Aで半環準同型となる
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism 𝔹 A :=
{ --どの関数を対象にするかを指定する。-∞を0に対応させ、0を-1に対応させる。
  toFun := fun x =>
    match x with
    | 𝔹.negInf => 0
    | 𝔹.zero   => 1,

  --F(x + y) = F x + F yを示す。x,yの組み合わせには4通りあるので、以下の4つを
  map_add := by
    intro x y
    --x,yで総当たりを行う。
    cases x <;> cases y <;> simp
    /-· -- F(-∞ + -∞)：0 = 0 + 0
      exact (zero_add (0 : A)).symm
    · -- F(-∞ + 0)：1 = 0 + 1
      exact (zero_add (1 : A)).symm
    · -- F(0 + -∞)：1 = 1 + 0
      exact (add_zero (1 : A)).symm-/
    · -- F(0 + 0)：1 = 1 + 1（冪等性）
      exact (h (1 : A)).symm,

  --F(xy) = F(X)F(y)を示す。
  map_mul := by
    intro x y
    cases x <;> cases y 
    · -- F(-∞ * -∞)：0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    · -- F(-∞ * 0)：0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    · -- F(0 * -∞)：0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    · -- F(0 * 0)：1 = 1 * 1
      exact (one_mul (1 : A)).symm,

  --𝔹 では 0 : 𝔹 = 𝔹.negInf、 1 : 𝔹 = 𝔹.zero が既にインスタンスで入っている.
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 「A が加法冪等」↔「A が 𝔹-代数（存在する）」 -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A ↔ Nonempty (Algebra A 𝔹) := by
  constructor
  · -- (→) 加法冪等 ⇒ 𝔹-代数が存在
    intro h
    --Algebra.ofHomは準同型写像から𝔹代数の構造を作ってくれる。準同型写像はboolHomOfAddIdemで指定してあげる。
    exact ⟨Algebra.ofHom (boolHomOfAddIdem A h)⟩

  · -- (←) 𝔹-代数が存在 ⇒ 加法冪等
    intro hAlg
    --nonemptyの状態に具体的にどのようなものがあるかを与えている。Tactic stateのinstで指定されているSemiringを用いて具体的に一つ抽出する。
    rcases hAlg with ⟨inst⟩
    -- ψ : 𝔹 → Aを指定してあげる。Algebraのclassを参照すると.homがあるので、instを指定して写像を取り出す。
    let ψ : SemiringHomomorphism 𝔹 A := inst.hom
    -- 1_A = 1_A + 1_Aを作る。
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := ψ.map_add (1 : 𝔹) (1 : 𝔹)      -- ψ(1+1) = ψ1 + ψ1
      have h1 : ψ 1 = ψ 1 + ψ 1 := by
        --B_one_add_oneで1+1=1なので、Ψ(1+1)=Ψ(1)が言える。h0も合わせることで証明が完了する。
        simpa [B_one_add_one] using h0
      simpa [ψ.map_one] using h1
    -- 任意の a について a + a = a
    intro a
    -- a*1 = a*1 + a*1 を作る（左分配と h11A）
    have hmul : a * 1 = a * 1 + a * 1 := by
      --Semiring.left_distribで a*(1+1) = a*1 + a*1 に対して，(1+1) → 1 へ書き換えh11Aを両辺入れ替えて適用。
     simpa [← h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- あとは mul_one で仕上げ
    -- （向きを合わせるために対称を取る）
    --have : a + a = a := by
    simpa [mul_one] using hmul.symm
    --exact this



--≤ₐの定義

section OrderFromAddIdem

variable {A : Type u} [Semiring A]

--a ≤ₐ bをa + b = bとする。
def leA (a b : A) : Prop := a + b = b

--反射律
theorem leA_refl (h : AddIdempotent A) (a : A) : leA a a := by
  unfold leA
  simpa using h a

--推移律
theorem leA_trans (a b c : A)
    (hab : leA  a b) (hbc : leA  b c) :
    leA  a c := by
  unfold leA at * -- hab hbc ⊢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--反対称律
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at * -- hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0は最小元
theorem bot_leA (a : A) : leA  (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA  a b) :
    leA  (c * a) (c * b) := by
  unfold leA at * -- hab ⊢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

--10/31
universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  ∀ ⦃a b c : A⦄, a * b = a * c → a = (0 : A) ∨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--こんご便利になる補題
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a ≠ (0 : A)) (hmul : a * b = a * c) : b = c := by
  --a=0かb=cのどちらかしかないことを示す仮定を入れる。
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  --h'に場合分けを入れる
  rcases h' with hzero | hbc
  --a=0の場合矛盾が起こるので恒真であることを利用して証明を完了させる。haとhzeroに対して.elimを用いて完了。(False).elimの形でカッコ内の矛盾からあらゆる命題を導ける。
  · exact (ha hzero).elim
  --自明。
  · exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--分母が 0 でない組 (a,b)の集合を定義。//は前に書かれた情報に条件を付け加える際に用いられる表記法。今回はp(省略されているが正しくはp.1）にp.2(p.1の二つ目の元に対する条件なので正確にはp.1.2)の条件を付けくわえている。
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A × A // p.2 ≠ (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- 分子
def num (p : FracCarrier A) : A := p.1.1
-- 分母
def den (p : FracCarrier A) : A := p.1.2

/-整理したものが以下
p : { p : A × A // p.2 ≠ 0 }

p.1        : A × A        -- (a, b)
p.1.1      : A            -- a
p.1.2      : A            -- b
p.2        : p.1.2 ≠ 0    
-/

--分数を作成した時にその分母と分子が何であるかを引き出すための補題
--分子
@[simp] lemma num_mk (a b : A) (hb : b ≠ 0) :
    num (A:=A) ⟨(a,b), hb⟩ = a := rfl
--分母
@[simp] lemma den_mk (a b : A) (hb : b ≠ 0) :
    den (A:=A) ⟨(a,b), hb⟩ = b := rfl

--分数を定義した時に分母が０でないことを利用できるようにするための補題
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p ≠ 0 := p.2

--p=a/b q=x/dの時、p=qをad=bcという形で表現するための定義
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--反射律
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--対称律
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q p := by
  --h.symmはRelで展開するとq.num * p.den = p.num * q.denなので、mulcommで入れ替えれば良い。
  intro h; simpa [Rel, mul_comm] using h.symm

--推移律
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q r → Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q ≠ (0 : A) := den_ne_zero (A:=A) q

  -- q.den * (p.num * r.den) = r.den * (q.num * p.den)を作る
  have h1 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    --(num p * den q) * den r = (num q * den p) * den rを作る。
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    grind
    /-calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl --assosiativeとcommtativeを貫通する便利なrflがac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl-/

  -- ② q.den * (r.num * p.den) = r.den * (q.num * p.den)を作る
  have h2 :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    grind
    /-calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl-/

  -- h1とh2の右辺が等しいことを用いてq.denを消去できる形にする。
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1.trans h2.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aのRelは（cancellativeの下で）同値関係になる。  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)  --同値と主張したい関係を指定
  iseqv :=
    ⟨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) ⟩

/-
structure Setoid (α : Sort u) where
  r     : α → α → Prop
  iseqv : Equivalence r　--Equivalenceはreflとsymmとtransを含む構造なので3つの引数を持つ。

-/

end FracCarrier
end TropicalGeometry

namespace TropicalGeometry
open Classical
--11/7
--商集合 Q(A) を作り、要素をa/bと書けるようにする 

section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- Q(A) := {(a,b) | b ≠ 0}/∼　すなわちa/bを作る。Quotはある型αと、その型の上の同値関係rを与えてrで割った商集合を作るためのコマンド。
def Q : Type u := Quot (FracCarrier.setoid (A:=A) hC)
--Quot.{u} {α : Sort u} (r : α → α → Prop) : Sort u

/-- 基本コンストラクタ：`a/b`（ただし `b ≠ 0`）を同値類に持ち上げる。 -/
def Q.mk (a b : A) (hb : b ≠ 0) : Q (A:=A) hC :=
  Quot.mk _ ⟨(a,b), hb⟩

/-- 「非零の分母」を包むミニ構造体。`⟨b, hb⟩ : NZDen A`。 -/
structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val ≠ 0

namespace Q

-- 記法 a / ⟨b, hb⟩ の本体：Q.mk a b hb。 
def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-
まずこのセクション内だけ有効なローカル記法を作る。その場合hCがあるので、a / b がそのまま使える。
次に、任意の場所で使える スコープ付き記法a /[hC] bを作る。hCを明示することでエラーを減らす。
-/

-- セクション内限定：a / b : Q(A,hC) （b : NZDen A） 
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

-- どこでも使える版：a /[hC] b （b : NZDen A） 
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic
end TropicalGeometry

namespace TropicalGeometry
open Classical


section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- ここでの Q は「QuotBasic」で定義したものを使う（重複定義しない）

namespace FracCarrier

/-- 分母同士の積は 0 にならない（Cancellative を利用） -/
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den ≠ 0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 から p.den * q.den = p.den * 0 を得る
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _
    exact h.trans hz.symm
  -- 左から cancel
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

/-- 商和の「代表」： (a/b) + (c/d) := (ad + cb) / (bd) -/
def addRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ⟨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ⟩

/-- 商積の「代表」： (a/b) * (c/d) := (ac) / (bd) -/
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ⟨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ⟩

/-- 加法が同値関係と両立（well-defined） -/
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  -- 目標： (p.num*q.den + q.num*p.den)*(p'.den*q'.den)
  --     = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
  unfold Rel addRep
  -- (x+y)*z = x*z + y*z
  have H₀ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  -- 1段目：単純分配
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by
            simpa using H₀
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by
            -- かけ算の順序・結合の入れ替え
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            -- 右辺のペアの順序も入れ替える
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by
            -- 逆向きの分配（(a*c)+(b*c) = (a+b)*c）
            have H₁ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            -- 項の順序を `simp` で合わせてから対称を使う
            simpa [mul_comm, mul_left_comm, mul_assoc] using H₁.symm

/-- 乗法が同値関係と両立（well-defined） -/
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  -- 目標： (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den)
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier
--11/14
/-- Q(A) 上の加法（2段階 `Quot.lift` 方式） -/
noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  -- まず「右引数 q を代表に戻してから addRep を持ち上げる」関数を作る
  let addCore₁ :
      FracCarrier A → (Q (A:=A) hC → Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' のときも well-defined
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  -- 次に「左引数 p を代表に戻し、addCore₁ p を選ぶ」関数を作る
  let addCore₂ : Q (A:=A) hC → (Q (A:=A) hC → Q (A:=A) hC) :=
    Quot.lift
      (fun p => addCore₁ p)
      (by
        -- p ~ p' なら、関数 addCore₁ p = addCore₁ p'
        intro p p' hp
        apply funext
        intro y
        -- y も代表に戻して同値を作る
        refine Quot.induction_on y ?_
        intro q
        -- 目標を書き換え（2つの mk の等しさを示せばよい）
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        -- これは addRep_compat の (hp, refl) で成立
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- 以上を使って x, y に適用
  exact addCore₂ x y


/-- Q(A) 上の乗法（2段階 `Quot.lift` 方式） -/
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCore₁ :
      FracCarrier A → (Q (A:=A) hC → Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCore₂ : Q (A:=A) hC → (Q (A:=A) hC → Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCore₁ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCore₂ x y

end QAddMul

--11/21
open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) (h10 : (1 : A) ≠ 0)

-- 0,1 の代表（分母 1 を使用）
def Q.zero : Q (A:=A) hC := Q.mk (A:=A) hC 0 1 h10
def Q.one  : Q (A:=A) hC := Q.mk (A:=A) hC 1 1 h10

-- 既に定義済みの Q.add / Q.mul を使ってインスタンス化


instance : Zero (Q (A:=A) hC) := ⟨Q.zero (A:=A) hC h10⟩
instance : One  (Q (A:=A) hC) := ⟨Q.one  (A:=A) hC h10⟩
noncomputable instance : Add  (Q (A:=A) hC) := ⟨Q.add (A:=A) hC⟩
noncomputable instance : Mul  (Q (A:=A) hC) := ⟨Q.mul (A:=A) hC⟩

namespace FracCarrier

variable {hC}

/-- 加法の可換性（代表版） -/
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  -- Rel と addRep, num, den を展開して目標式を素の等式に落とす
  unfold Rel addRep num den
  -- 目標：
  -- (p.num*q.den + q.num*p.den) * (q.den*p.den)
  --   = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  -- 和の順序と分母側の積の順序を入れ替えるだけで一致
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          -- 和の順序だけを可換法則で入れ替え
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          -- 分母側の積の順序を可換法則で入れ替え
          ac_rfl

/-- 加法の結合性（代表版） -/
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  unfold Rel addRep
  set a := p.num; set b := p.den
  set c := q.num; set d := q.den
  set e := r.num; set f := r.den
  let k₁ := b * (d * f)
  let k₂ := (b * d) * f

  /- 左辺を 3 項に -/
  have HL1 :
      ((a*d + c*b) * f + e * (b*d)) * k₁
        = ((a*d + c*b) * f) * k₁ + (e * (b*d)) * k₁ := by
    simpa using
      (Semiring.right_distrib (R:=A) ((a*d + c*b) * f) (e * (b*d)) k₁)

  -- ((a*d + c*b) * f) * k₁ = (a*d)*(f*k₁) + (c*b)*(f*k₁)
  have HL2 :
      ((a*d + c*b) * f) * k₁
        = (a*d) * (f * k₁) + (c*b) * (f * k₁) := by
    -- ((x+y)*f)*k₁ = (x+y)*(f*k₁) にしてから right_distrib
    have := Semiring.right_distrib (R:=A) (a*d) (c*b) (f * k₁)
    simpa [mul_assoc] using this

  -- 左辺まとめ
  have HL :
      ((a*d + c*b) * f + e * (b*d)) * k₁
        = a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁ := by
    calc
      ((a*d + c*b) * f + e * (b*d)) * k₁
          = ((a*d + c*b) * f) * k₁ + (e * (b*d)) * k₁ := HL1
      _ = ((a*d) * (f * k₁) + (c*b) * (f * k₁)) + (e * (b*d)) * k₁ := by
            simp [HL2]
      _ = a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁ := by
            simp [mul_assoc]

  /- 右辺を 3 項に -/
  have HR1 :
      (a * (d*f) + (c*f + e*d) * b) * k₂
        = (a * (d*f)) * k₂ + ((c*f + e*d) * b) * k₂ := by
    simpa using
      (Semiring.right_distrib (R:=A) (a * (d*f)) ((c*f + e*d) * b) k₂)

  -- ((c*f + e*d) * b) * k₂ = (c*f)*(b*k₂) + (e*d)*(b*k₂)
  have HR2' :
      ((c*f + e*d) * b) * k₂
        = (c*f) * (b * k₂) + (e*d) * (b * k₂) := by
    have := Semiring.right_distrib (R:=A) (c*f) (e*d) (b * k₂)
    simpa [mul_assoc] using this

  have HR :
      (a * (d*f) + (c*f + e*d) * b) * k₂
        = a * (d*f) * k₂ + (c*f) * b * k₂ + (e*d) * b * k₂ := by
    calc
      (a * (d*f) + (c*f + e*d) * b) * k₂
          = (a * (d*f)) * k₂ + ((c*f + e*d) * b) * k₂ := HR1
      _ = (a * (d*f)) * k₂ + ((c*f) * (b * k₂) + (e*d) * (b * k₂)) := by
            simp [HR2']
      _ = a * (d*f) * k₂ + (c*f) * b * k₂ + (e*d) * b * k₂ := by
            simp [mul_assoc, add_assoc]

  -- k₁ と k₂ は結合法で同じ（←ここを修正）
  have k_same : k₁ = k₂ := by
    -- k₁ = b * (d * f)
    -- k₂ = (b * d) * f
    -- mul_assoc b d f : (b * d) * f = b * (d * f)
    -- simp で両辺を同じ形に正規化してくれる
    simp [k₁, k₂, mul_assoc]

  -- 3項の和の並び替え（括弧外しを含む）
  have align :
      a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁
        = a*(d*f)*k₂ + (c*f)*b*k₂ + (e*d)*b*k₂ := by 
        simp [k_same, mul_assoc, mul_comm, mul_left_comm]
    -- まず k₁ を k₂ に置換してから ac で並べ替え
    /-simpa [k_same, mul_assoc, mul_comm, mul_left_comm] using
      (by
         have : a*d*f*k₂ + c*b*f*k₂ + e*(b*d)*k₂
              = a*(d*f)*k₂ + (c*f)*b*k₂ + (e*d)*b*k₂ := by
            ac_rfl
         exact this)-/

  -- まとめ
  calc
    ((a*d + c*b) * f + e * (b*d)) * k₁
        = a*d*f*k₁ + c*b*f*k₁ + e*(b*d)*k₁ := HL
    _   = a*(d*f)*k₂ + (c*f)*b*k₂ + (e*d)*b*k₂ := align
    _   = (a * (d*f) + (c*f + e*d) * b) * k₂ := HR.symm





/-- 乗法の可換性（代表版） -/
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  -- (p.num*q.num)*(p.den*q.den) と (q.num*p.num)*(q.den*p.den)
  -- は ac で一致
  simp [mul_comm,  mul_assoc]

/-- 乗法の結合性（代表版） -/
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  -- どちらも分子 p.num*q.num*r.num，分母 p.den*q.den*r.den （順序違い）になるので ac
  simp [mul_comm,  mul_assoc]

/-- 左分配（代表版） -/
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- まず p,q,r の中身を素の変数名にばらす
  rcases p with ⟨⟨pn, pd⟩, hp0⟩
  rcases q with ⟨⟨qn, qd⟩, hq0⟩
  rcases r with ⟨⟨rn, rd⟩, hr0⟩

  -- Rel, addRep, mulRep を展開して、A 上の等式に落とす
  unfold Rel addRep mulRep
  -- FracCarrier.num / den はただの fst / snd
  simp [FracCarrier.num, FracCarrier.den]

  /-
  いまゴール（≒タクティク状態のターゲット）は：
    pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
      =
    (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
      * (pd * (qd * rd))

  これを2段ロケットで示す：
   (1) 左辺 = pn * (qn*rd + rn*qd) * X
   (2) その X 版から最終右辺へ
  を合成する。
  -/

  -- まず分母側の大きい積を名前付けしておく
  set X : A := pd * qd * (pd * rd) with hX
  set Y : A := pd * (qd * rd) with hY

  -- (1) 左辺を pn * (qn*rd + rn*qd) * X という「標準形」に寄せる
  have lhs_reassoc :
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
        =
      pn * (qn * rd + rn * qd) * X := by
    -- まず (pd * (qd * (pd * rd))) を assoc で (pd * qd) * (pd * rd) 型にする
    have tail_assoc :
        pd * (qd * (pd * rd))
          = pd * qd * (pd * rd) := by
      -- (pd * (qd * Z)) = (pd * qd) * Z, and reassociate
      simp [mul_assoc]
    calc
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
          = pn * ((qn * rd + rn * qd) * (pd * qd * (pd * rd))) := by
              simp [tail_assoc]
      _   = pn * (qn * rd + rn * qd) * (pd * qd * (pd * rd)) := by
              -- reassociate pn * ((...) * (...)) → pn * (...) * (...)
              simp [mul_assoc]
      _   = pn * (qn * rd + rn * qd) * X := by
              simp [hX]

  -- (2a) 左側：pn * (qn*rd + rn*qd) * X を足し算に展開
  --      = pn*(qn*rd)*X + pn*(rn*qd)*X
  have left_expand :
      pn * (qn * rd + rn * qd) * X
        =
      pn * (qn * rd) * X + pn * (rn * qd) * X := by
    -- まず (qn*rd + rn*qd) * X を右分配
    have inner :
        (qn * rd + rn * qd) * X
          =
        (qn * rd) * X + (rn * qd) * X := by
      -- right_distrib: (a+b)*c = a*c + b*c
      have tmp :=
        Semiring.right_distrib (R:=A) (qn * rd) (rn * qd) X
      simpa using tmp
    -- 次に pn * [...] を左分配
    -- pn * ( (qn*rd)*X + (rn*qd)*X )
    --   = pn*(qn*rd)*X + pn*(rn*qd)*X
    have tmp2 :=
      Semiring.left_distrib (R:=A) pn ((qn * rd) * X) ((rn * qd) * X)
    -- tmp2 :
    --   pn * ((qn * rd) * X + (rn * qd) * X)
    --     =
    --   pn * ((qn * rd) * X) + pn * ((rn * qd) * X)
    simpa [inner, mul_assoc] using tmp2

  -- (2b) 右側の和を別の形に展開：
  --   (pn*qn*(pd*rd) + pn*rn*(pd*qd)) * Y
  --   = pn*qn*(pd*rd)*Y + pn*rn*(pd*qd)*Y
  have right_expand :
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y
        =
      pn * qn * (pd * rd) * Y
      + pn * rn * (pd * qd) * Y := by
    -- これも right_distrib
    have tmp :=
      Semiring.right_distrib (R:=A)
        (pn * qn * (pd * rd))
        (pn * rn * (pd * qd))
        Y
    simpa [mul_assoc] using tmp

  -- (2c) 個々の項が同じものを掛け算の順序替えで表現してることを示す
  --      pn * (qn * rd) * X  =  pn * qn * (pd * rd) * Y
  have term1_match :
      pn * (qn * rd) * X
        =
      pn * qn * (pd * rd) * Y := by
    -- 両辺とも可換・結合の並べ替えだけで一致する
    simp [X, Y, hY, mul_comm, mul_left_comm]

  --      pn * (rn * qd) * X  =  pn * rn * (pd * qd) * Y
  have term2_match :
      pn * (rn * qd) * X
        =
      pn * rn * (pd * qd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  -- (2d) 右側の「pd*(qd*rd)」に戻すための再結合
  --  (pn*(qn*(pd*rd)) + pn*(rn*(pd*qd))) * (pd*(qd*rd))
  --   と
  --  (pn*qn*(pd*rd) + pn*rn*(pd*qd)) * Y
  --  が同じだという補題
  have rhs_reassoc :
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
        =
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
    calc
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
          =
        ((pn * qn * (pd * rd)) + (pn * rn * (pd * qd)))
          * (pd * (qd * rd)) := by
            -- assocで pn*(qn*...) = pn*qn*..., 同様に rn側も
            simp [mul_assoc]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
            simp [hY]

  ----------------------------------------------------------------
  -- (2e) “X 形” から “最終右辺”までの鎖を mid_chain として証明
  ----------------------------------------------------------------
  have mid_chain :
      pn * (qn * rd + rn * qd) * X
        =
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := by
    -- ここは calc を使って大丈夫。スタートとゴールがハッキリ一致してるから。
    calc
      pn * (qn * rd + rn * qd) * X
          =
        pn * (qn * rd) * X + pn * (rn * qd) * X := left_expand
      _ =
        pn * qn * (pd * rd) * Y
        + pn * rn * (pd * qd) * Y := by
          simp [term1_match, term2_match]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y :=
          (right_expand.symm)
      _ =
        (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := rhs_reassoc.symm

  ----------------------------------------------------------------
  -- 最後に、(1) と mid_chain を合成して元のゴールを証明
  ----------------------------------------------------------------
  grind
  --exact lhs_reassoc.trans mid_chain

/-- 右分配（代表版） -/
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by

  /- まず分子・分母を素の変数にばらす -/
  rcases p with ⟨⟨pn, pd⟩, hp0⟩
  rcases q with ⟨⟨qn, qd⟩, hq0⟩
  rcases r with ⟨⟨rn, rd⟩, hr0⟩

  /- `Rel` と `addRep` / `mulRep` を展開して，
     Q(A) 上の等式を A の等式に落とす -/
  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  /-
  いまゴールは（可換・結合の違い以外は）次の形になっているはず：

    ((pn * qd + qn * pd) * rn) * ((pd * rd) * (qd * rd))
      =
    ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * ((pd * qd) * rd)

  左辺・右辺の「でかい分母部分」を変数に取っておく：
    X := (pd * rd) * (qd * rd)
    Y := (pd * qd) * rd
  -/

  set X : A := (pd * rd) * (qd * rd) with hX
  set Y : A := (pd * qd) * rd with hY

  /- `*` の結合法則で左側を「((...)*rn) * X」から「(...)*rn*X」に寄せる -/
  have lhs_reassoc :
      ((pn * qd + qn * pd) * rn) * X
        =
      (pn * qd + qn * pd) * rn * X := by
    simp [X, mul_assoc]

  /- 左辺を分配で 2 項の和に分ける。
     (pn*qd + qn*pd) * rn * X
       = (pn*qd)*rn*X + (qn*pd)*rn*X
  -/
  have left_expand :
      (pn * qd + qn * pd) * rn * X
        =
      (pn * qd) * rn * X + (qn * pd) * rn * X := by
    -- まず一次分配：(a+b)*rn = a*rn + b*rn
    have step1 :
        (pn * qd + qn * pd) * rn
          =
        (pn * qd) * rn + (qn * pd) * rn := by
      simpa using
        Semiring.right_distrib (R:=A) (pn * qd) (qn * pd) rn
    -- それにさらに * X を右から掛けてもう一度分配
    calc
      (pn * qd + qn * pd) * rn * X
          = ((pn * qd) * rn + (qn * pd) * rn) * X := by
              simp [step1]
      _   = (pn * qd) * rn * X + (qn * pd) * rn * X := by
              simpa [mul_assoc] using
                Semiring.right_distrib (R:=A)
                  ((pn * qd) * rn) ((qn * pd) * rn) X

  /- 右辺側も同様に、
     ((pn*rn)*(qd*rd) + (qn*rn)*(pd*rd)) * Y
       = (pn*rn)*(qd*rd)*Y + (qn*rn)*(pd*rd)*Y
  -/
  have right_expand :
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y
        =
      (pn * rn) * (qd * rd) * Y + (qn * rn) * (pd * rd) * Y := by
    simpa [mul_assoc] using
      Semiring.right_distrib (R:=A)
        ((pn * rn) * (qd * rd)) ((qn * rn) * (pd * rd)) Y

  /- 各項どうしが一致することを示す：
       (pn * qd) * rn * X
         = (pn * rn) * (qd * rd) * Y
     これは可換・結合の並べ替えだけで証明できる
  -/
  have term1_match :
      (pn * qd) * rn * X
        =
      (pn * rn) * (qd * rd) * Y := by
    -- それぞれを `pn * rn * qd * qd * pd * rd * rd` 型まで整形
    simp [X, Y, mul_comm, mul_left_comm]

  /- 同様に 2 個目の項：
       (qn * pd) * rn * X
         = (qn * rn) * (pd * rd) * Y
  -/
  have term2_match :
      (qn * pd) * rn * X
        =
      (qn * rn) * (pd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  /- 以上をまとめる。
     まず左辺を `lhs_reassoc` で (pn*qd+qn*pd)*rn*X に寄せる。
     次に `left_expand` で 2 項に分ける。
     それぞれ `term1_match` / `term2_match` で右辺の形にそろえる。
     最後に `right_expand`.symm で再び和を一つの積にまとめる。
     その結果が最終的な右辺 ((pn*rn)*(qd*rd) + (qn*rn)*(pd*rd)) * Y になる。
  -/
  have mid_chain :
      (pn * qd + qn * pd) * rn * X
        =
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
    calc
      (pn * qd + qn * pd) * rn * X
          = (pn * qd) * rn * X + (qn * pd) * rn * X := left_expand
      _   = (pn * rn) * (qd * rd) * Y
            + (qn * rn) * (pd * rd) * Y := by
              simp [term1_match, term2_match]
      _   = ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
              simpa [mul_assoc] using right_expand.symm

  /- 仕上げ：
     LHS = ((pn*qd + qn*pd) * rn) * X
         = (pn*qd + qn*pd) * rn * X          (lhs_reassoc)
         = ... = RHS                         (mid_chain)
  -/
  exact lhs_reassoc.trans mid_chain



end FracCarrier

--11/21
/-************************ ここから構造を持ち上げる ************************-/

-- 加法群律（加法：可換・結合・0 は単位）
instance : AddCommMonoid (Q (A:=A) hC) where
  add := (· + ·)
  zero := (0 : Q (A:=A) hC)
  add_assoc := by
    intro x y z
    -- 3 変数の `Quot` 降ろし → 代表版補題 → `Quot.sound`
    refine Quot.induction_on x ?hx |>.trans ?_
    · intro p; refine Quot.induction_on y ?hy
      · intro q; refine Quot.induction_on z ?hz
        · intro r
          apply Quot.sound
          exact FracCarrier.addRep_assoc (A:=A) hC p q r
    · -- 合体
      rfl
  zero_add := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    -- 0 + p = p
    -- 代表 0 は (0,1)
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC
                   ⟨(0,1), h10⟩ p)
        = Quot.mk _ p
    apply Quot.sound
    -- (0/1)+ (a/b) ~ (a/b)
    -- これは addRep_compat に rel_refl と、(0,1) ~ (0,1) を使えばOK（自明）
    -- 直接等式でも良いが、Rel で押す：
    -- addRep_compat (refl, refl) では足りないので、実際の等式で証明
    -- 0/1 + a/b = (0*b + a*1)/(1*b) ~ a/b は代表計算で分子が a*b に一致
    -- すなわち Rel: (a*1)*(1*b) = (a*b)*(1*1)
    -- 直接書く：
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]

  add_zero := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC p ⟨(0,1), h10⟩)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]
  add_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q
  nsmul := fun n x =>
    Nat.recOn n (0) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

-- 乗法モノイド（可換）
instance : CommMonoid (Q (A:=A) hC) where
  mul := (· * ·)
  one := (1 : Q (A:=A) hC)
  mul_assoc := by
    intro x y z
    refine Quot.induction_on x ?hx |>.trans ?_
    · intro p; refine Quot.induction_on y ?hy
      · intro q; refine Quot.induction_on z ?hz
        · intro r
          apply Quot.sound
          exact FracCarrier.mulRep_assoc (A:=A) hC p q r
    · rfl
  one_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ⟨(1,1), h10⟩ p)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_one := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(1,1), h10⟩)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q
  npow := fun n x =>
    Nat.recOn n (1) (fun _ s => s * x)

/-- 分配・零吸収を持ち上げて Semiring インスタンス -/
instance : Semiring (Q (A:=A) hC) where
  mul_zero := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    -- p * 0 = 0
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(0,1), h10⟩)
        = (0 : Q (A:=A) hC)
    -- 右辺の 0 は ⟨(0,1),h10⟩ の同値類
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(0,1), h10⟩)
        = Quot.mk _ ⟨(0,1), h10⟩
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  zero_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ⟨(0,1), h10⟩ p)
        = Quot.mk _ ⟨(0,1), h10⟩
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    -- p * (q + r) = p*q + p*r  を `Rel` で主張
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r
  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r

--逆元の存在：Semifield 仕上げ 

-- 「0 でない元 x は、何らかの代表 p で p.num ≠ 0」を使って逆を立てる。
-- x = [a/b]（b≠0）で a ≠ 0 なら逆は [b/a]。
-- x = 0 のとき（つまり任意代表が a=0）以外はこれで十分。
-- そこでまず、0 判定の補題を作る。

namespace FracCarrier

/- [a/b] = 0 であることの代表版判定：a = 0 -/
lemma zero_iff_num_eq_zero (hC : Cancellative A)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p ⟨(0,1), by exact (show (1:A) ≠ 0 from ?_)⟩
      ↔ p.num = 0 := by
  -- ここでは `?_.` に `h10` を入れたいので、外側で使う形に書き換えます。
  -- 実運用では直接使わず、下の `nonzero_num_of_ne_zero` で `h10` を受け渡します。
  admit

end FracCarrier

/-- 非零元は分子が非零な代表を持つ -/
lemma nonzero_num_of_ne_zero
    {x : Q (A:=A) hC} (hx : x ≠ 0) :
    ∃ p : FracCarrier A, Quot.mk _ p = x ∧ p.num ≠ 0 := by
  -- x を代表 p に降ろす。もし p.num = 0 なら x = 0 に矛盾。
  refine Quot.induction_on x (fun p => ?_) 
  intro p
  by_cases hp : p.num = 0
  · -- この場合、[p] = 0 になってしまう
    have : Quot.mk _ p = (0 : Q (A:=A) hC) := by
      -- 0 は ⟨(0,1),h10⟩ の同値類
      change Quot.mk _ p = Quot.mk _ ⟨(0,1), h10⟩
      apply Quot.sound
      -- Rel: p.num*1 = 0 * p.den
      unfold FracCarrier.Rel FracCarrier.num FracCarrier.den
      simp [hp, Semiring.one_mul, Semiring.zero_mul]
    exact (hx (by simpa using this)).elim
  · exact ⟨p, rfl, hp⟩

/-- Q(A) は Semifield：0≠1 と「非零に逆」 -/
noncomputable instance : Semifield (Q (A:=A) hC) where
  -- 既に Semiring インスタンスはある
  zero_ne_one := by
    -- 0 ≠ 1 は代表 0/1 と 1/1 が異なることに帰着（h10 を使用）
    -- Rel で等しいと仮定すると 0=1 に矛盾
    intro h01
    -- 0 = 1 なら、その代表が Rel で等しい
    -- (0*1) * (1*1) = (1*1) * (0*1) を見ると 0=1 を強いる
    have : (0 : A) = 1 := by
      -- `Quot.eqv_iff_eq` は使えないので、等しいと仮定したら Rel が成り立つはず
      -- ここは手短に：もし 0=1 なら h10 に反する、という形に変換
      -- 実際には 0=1 を導く代表計算でも OK
      -- 簡略化のために反証法：h10 : 1 ≠ 0
      exact (h10 (by simpa))
    -- 矛盾
    exact (by have := this.symm; simpa using this)
  exists_inv := by
    intro x hx
    -- 非零なら代表 p で p.num ≠ 0 が取れる
    rcases nonzero_num_of_ne_zero (A:=A) hC h10 hx with ⟨p, rfl, hp⟩
    -- 逆は [p.den/p.num]
    refine ⟨
      Quot.mk _ ⟨(p.den, p.num), hp⟩,
      ?goal
    ⟩
    -- 証明： [p]*[p.den/p.num] = 1
    -- 代表計算： (p.num/p.den) * (p.den/p.num) = (p.num*p.den)/(p.den*p.num) ~ 1/1
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p ⟨(p.den, p.num), hp⟩)
        = (1 : Q (A:=A) hC)
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p ⟨(p.den, p.num), hp⟩)
        = Quot.mk _ ⟨(1,1), h10⟩
    apply Quot.sound
    -- Rel の式に落とす
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    -- (p.num*p.den) * (1*1) = (1*p.num) * (p.den*p.num)
    -- 可換結合で `ac_rfl`
    have h1 : (p.num * p.den) * (1 * 1)
            = p.num * p.den := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    have h2 : (1 * p.num) * (p.den * p.num)
            = p.num * p.den * p.num := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    -- 左右とも p.num*p.den*p.num に落ちる
    simpa [h1, h2, Semiring.one_mul,
           mul_comm, mul_left_comm, mul_assoc]

end QSemiring

--11/28

open Classical

--Max-Plus 半体 T

/-- 台集合：実数に -∞ を adjoin したもの。-∞ は `⊥`. -/
abbrev T : Type := WithBot ℝ

/-- トロピカル加法（⊕）：max. -/
instance : Add T := ⟨fun a b => max a b⟩

/-- トロピカル 0（加法単位）：-∞. -/
instance : Zero T := ⟨(⊥ : WithBot ℝ)⟩

/-- トロピカル乗法（⊗）：実数加法。ただし -∞ は吸収元。 -/
instance : Mul T :=
  ⟨fun a b =>
    match a, b with
    | ⊥      , _       => (⊥ : WithBot ℝ)
    | _       , ⊥      => (⊥ : WithBot ℝ)
    | some x , some y  => some (x + y)⟩

/-- トロピカル 1（乗法単位）：実数の 0. -/
instance : One T := ⟨(some (0 : ℝ))⟩

@[simp] lemma trop_add_def (a b : T) : a + b = max a b := rfl
@[simp] lemma trop_zero_def : (0 : T) = (⊥ : WithBot ℝ) := rfl
@[simp] lemma trop_mul_def (a b : T) :
    a * b =
      match a, b with
      | ⊥     , _      => (⊥ : WithBot ℝ)
      | _      , ⊥     => (⊥ : WithBot ℝ)
      | some x, some y => some (x + y) := rfl
@[simp] lemma trop_one_def : (1 : T) = (some (0 : ℝ)) := rfl

/- 可換性・結合性など、`Semiring` インスタンスを建てるのに必要な補題
    （細部は Mathlib の `WithBot` + 実数加法の性質でいずれ証明する）. -/
lemma trop_add_comm (a b : T) : a + b = b + a := by
  simp [trop_add_def, max_comm]

lemma trop_add_assoc (a b c : T) :
    (a + b) + c = a + (b + c) := by 
  simp [trop_add_def, max_assoc, max_comm]

lemma trop_zero_add (a : T) : (0 : T) + a = a := by
  cases a <;> simp [trop_add_def, trop_zero_def, max_eq_right_iff,
                    max_eq_left_iff] <;> tauto

lemma trop_add_zero (a : T) : a + (0 : T) = a := by
  cases a <;> simp [trop_add_def, trop_zero_def, max_eq_right_iff,
                    max_eq_left_iff] <;> tauto

private def trop_nsmul (n : ℕ) (a : T) : T :=
  Nat.recOn n (0 : T) (fun _ acc => acc + a)

private lemma trop_nsmul_zero (a : T) :
    trop_nsmul 0 a = (0 : T) := rfl
private lemma trop_nsmul_succ (n : ℕ) (a : T) :
    trop_nsmul (n.succ) a = trop_nsmul n a + a := rfl

lemma trop_zero_mul (a : T) : (0 : T) * a = (0 : T) := by
  cases a <;> simp [trop_mul_def, trop_zero_def]

lemma trop_mul_zero (a : T) : a * (0 : T) = (0 : T) := by
  cases a <;> simp [trop_mul_def, trop_zero_def]

lemma trop_one_mul (a : T) : (1 : T) * a = a := by
  cases a <;> simp [trop_mul_def, trop_one_def]

lemma trop_mul_one (a : T) : a * (1 : T) = a := by
  cases a <;> simp [trop_mul_def, trop_one_def]

lemma trop_mul_comm (a b : T) : a * b = b * a := by
  cases a <;> cases b <;> simp [trop_mul_def, add_comm]

lemma trop_mul_assoc (a b c : T) :
    (a * b) * c = a * (b * c) := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, add_assoc]

private def trop_npow (n : ℕ) (a : T) : T :=
  Nat.recOn n (1 : T) (fun _ acc => acc * a)

lemma trop_left_distrib (a b c : T) :
    a * (b + c) = a * b + a * c := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, trop_add_def, trop_zero_def,
          max_eq_left_iff, max_eq_right_iff,
          add_comm, add_left_comm, add_assoc,
          sup_eq_max] <;> try tauto

lemma trop_right_distrib (a b c : T) :
    (a + b) * c = a * c + b * c := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, trop_add_def, trop_zero_def,
          max_eq_left_iff, max_eq_right_iff,
          add_comm, add_left_comm, add_assoc,
          sup_eq_max] <;> try tauto

lemma trop_add_idempotent (a : T) : a + a = a := by
  simp [trop_add_def]

/- Max-Plus 半体 `T` は、あなたが定義した `TropicalGeometry.Semiring` の
    インスタンスとして振る舞う。 -/
noncomputable instance : TropicalGeometry.Semiring T where
  -- AddCommMonoid 部分
  add := (·+·)
  zero := (0 : T)
  add_assoc := trop_add_assoc
  zero_add := trop_zero_add
  add_zero := trop_add_zero
  add_comm := trop_add_comm
  nsmul := fun n a => trop_nsmul n a
  nsmul_zero := by intro a; simp [trop_nsmul_zero]
  nsmul_succ := by intro n a; simp [trop_nsmul_succ]
  -- CommMonoid 部分
  mul := (·*·)
  one := (1 : T)
  mul_assoc := trop_mul_assoc
  one_mul := trop_one_mul
  mul_one := trop_mul_one
  mul_comm := trop_mul_comm
  npow := fun n a => trop_npow n a
  -- Semiring 固有フィールド
  mul_zero := by intro a; exact trop_mul_zero a
  zero_mul := by intro a; exact trop_zero_mul a
  left_distrib := by intro a b c; exact trop_left_distrib a b c
  right_distrib := by intro a b c; exact trop_right_distrib a b c


--n変数トロピカル多項式(形式的には T[X₁,…,Xₙ])

/-
多重指数：Fin n →₀ ℕ 有限サポート写像 `u ↦ coeff(u)` をトロピカル多項式とみなす。ここでは「型」と「単項式コンストラクタ」まで定義しておく。後でこの型に対してトロピカル和・トロピカル積を入れてSemiring インスタンス化するのが次のステップ。
-/

abbrev TropMonomial (n : ℕ) := (Fin n →₀ ℕ)

abbrev TropPoly (n : ℕ) := (TropMonomial n) →₀ T

/-- 単項式 `c ⊗ X^u` を1項だけ持つトロピカル多項式として作る。 -/
noncomputable def TropPoly.monom {n : ℕ}
    (u : TropMonomial n) (c : T) : TropPoly n :=
  Finsupp.single u c

notation "TropPoly[" n "]" => TropPoly n


-- n変数トロピカル・ローラン多項式(形式的には T[X₁^{±1},…,Xₙ^{±1}])

/-
ローラン多項式は指数に負も許すので ℤ 指数。
-/

abbrev TropLaurentMonomial (n : ℕ) := (Fin n →₀ ℤ)

abbrev TropLaurent (n : ℕ) := (TropLaurentMonomial n) →₀ T

/-- 単項ローラン多項式 `c ⊗ X^u` （u は ℤ-ベクトル指数）. -/
noncomputable def TropLaurent.monom {n : ℕ}
    (u : TropLaurentMonomial n) (c : T) : TropLaurent n :=
  Finsupp.single u c

notation "TropLaurent[" n "]" => TropLaurent n

/-
4. 評価写像と「バー付き」多項式関数・ローラン多項式関数

 ここでは，本の記法に合わせて

   F : トロピカル多項式  ─→  𝐅̄ : Tⁿ → T
   G : トロピカルローラン多項式 ─→  Ḡ : ℝⁿ → T

 を定義する。

 さらに，これら「バー付き」像（＝多項式関数 / ローラン多項式関数）
 からなる半環を表す型エイリアスも用意する。

 依存している前提：
 - すでに
     abbrev T := WithBot ℝ
     instance : TropicalGeometry.Semiring T
   が定義済みであること

 - すでに
     abbrev TropMonomial (n : ℕ) := (Fin n →₀ ℕ)
     abbrev TropPoly     (n : ℕ) := (TropMonomial n) →₀ T
     abbrev TropLaurentMonomial (n : ℕ) := (Fin n →₀ ℤ)
     abbrev TropLaurent        (n : ℕ) := (TropLaurentMonomial n) →₀ T

   および単項式コンストラクタ
     TropPoly.monom
     TropLaurent.monom
   があること

-/

open Classical
open scoped BigOperators

namespace TropicalGeometry

/-- n 変数トロピカル多項式の評価点（T^n）を Lean 的に「Fin n → T」とみなす -/
abbrev TropPoint (n : ℕ) := Fin n → T

/-- n 変数トロピカルローラン多項式の評価点（ℝ^n） -/
abbrev TropLaurentPoint (n : ℕ) := Fin n → ℝ


/-
4-1. T 上の冪（トロピカル冪）

   tropPow a k  :=  a ⊙ a ⊙ ... ⊙ a   (k 回, ⊙ はトロピカル乗法)
                  = k 回の通常実数加法（a が実数の場合）に対応

   0 乗は 1 (トロピカル単位 = 0 ∈ ℝ), という約束にする
-/

/- 「トロピカル冪」: a^(k) in the tropical sense with k : ℕ.
    0 乗は 1（= some 0），succ では右から積（= 実数加法）を足していく。 -/
noncomputable def tropPow (a : T) (k : ℕ) : T :=
  Nat.recOn k (1 : T) (fun _ acc => acc * a)

@[simp] lemma tropPow_zero (a : T) :
    tropPow a 0 = (1 : T) := rfl

@[simp] lemma tropPow_succ (a : T) (k : ℕ) :
    tropPow a (k.succ) = tropPow a k * a := rfl


/-
4-2. T 上の整数冪（ローラン用）

  ローラン多項式では指数が ℤ になる。
  a^(m) (m∈ℤ) は
     m ≥ 0 なら上の tropPow
     m < 0  なら "負の回数" 分だけ引く（= 実数の符号付き和）

  評価点は ℝ のみ（-∞ はなし）なので，
  実数 x を T (= WithBot ℝ) の some x に埋めて扱う。
-/

/-- 実数を T (= WithBot ℝ) に入れる埋め込み。 -/
@[simp] def toT (x : ℝ) : T := some x

@[simp] lemma toT_mul_toT (x y : ℝ) :
    toT (x + y) = (toT x * toT y) := rfl

@[simp] lemma toT_zero : toT (0 : ℝ) = (1 : T) := rfl
-- （1 in T は some 0 という設計だったはず）


/-- 「整数指数のトロピカル冪」.
    評価点は ℝ なので，このとき a は ℝ，出力は T.
    m ≥ 0 のときは m 回の和，m < 0 のときは (−m) 回の和にマイナスを付ける
    ＝ 実数としては m • a （整数倍）を some で包む。 -/
noncomputable def tropPowZ (a : ℝ) (m : ℤ) : T :=
  some ((m : ℤ) • a)
  -- ここで • は ℤ-倍 (zsmul)。
  -- tropical 乗法は実数加法に対応しているので、
  -- a^(m) (trop) = m * a (ordinary real addition),
  -- それを some で持ち上げて T の元とする。


/-
4-3. 1項 (monomial) の評価


 多重指数 u : Fin n →₀ ℕ に対して，
    点 x : Fin n → T での「トロピカル単項式 X^u の値」.
    これは
       ∏_{i} (x i)^(u i)  （トロピカル乗法での積）
    を意味する。 -/
noncomputable def monomialEval
    {n : ℕ} (u : TropMonomial n) (x : TropPoint n) : T :=
  ∏ i in Finset.univ, tropPow (x i) (u i)

@[simp] lemma monomialEval_def
    {n : ℕ} (u : TropMonomial n) (x : TropPoint n) :
    monomialEval u x
      = ∏ i in Finset.univ, tropPow (x i) (u i) := rfl


/-- 多重指数 u : Fin n →₀ ℤ （整数指数）に対して，
    実数点 x : Fin n → ℝ での「トロピカル単項ローラン式 X^u の値」.
    これは
       ∏_{i} (x i)^(u i)  （トロピカル乗法での積）
    で，負の指数も許す。 -/
noncomputable def monomialLaurentEval
    {n : ℕ} (u : TropLaurentMonomial n) (x : TropLaurentPoint n) : T :=
  ∏ i in Finset.univ, tropPowZ (x i) (u i)

@[simp] lemma monomialLaurentEval_def
    {n : ℕ} (u : TropLaurentMonomial n) (x : TropLaurentPoint n) :
    monomialLaurentEval u x
      = ∏ i in Finset.univ, tropPowZ (x i) (u i) := rfl


--4-4. 多項式 / ローラン多項式 全体の評価

/-
トロピカル多項式 F : TropPoly n は
  F : (Fin n →₀ ℕ) →₀ T
すなわち有限個の (u ↦ coeff_u)。

古典的な意味での「値 F(x)」は
  ⊕_{u ∈ supp(F)} ( coeff_u ⊙ x^u )
= max_{u} [ coeff_u + (∑ u_i * x_i) ]
に相当する。

`Finset.sup` は max をとるので，
  F.support.sup (fun u => coeff_u * monomialEval u x)
で「⊕」を実装できる。
-/

noncomputable def TropPoly.eval {n : ℕ}
    (F : TropPoly n) (x : TropPoint n) : T :=
  F.support.sup (fun u => F u * monomialEval u x)

/--
ローラン多項式 G : TropLaurent n の評価。
定義域は R^n （= Fin n → ℝ）で，
値域は T （= ℝ ∪ { -∞ }）。

注意（教科書の説明と一致）：
- 一般にローラン多項式 G は T^n では定義できない（負べきなどで -∞ が壊れる）ので，
  Ḡ の定義域は R^n とする。
- もしある点で G が -∞ をとるなら，実は G 全体が定数 -∞ である。
  （この性質は理論側の命題。ここではコメントのみ。）
-/
noncomputable def TropLaurent.eval {n : ℕ}
    (G : TropLaurent n) (x : TropLaurentPoint n) : T :=
  G.support.sup (fun u => G u * monomialLaurentEval u x)


/-
 4-5. 「バー付き」写像の定義

   記号的に
     F ↦  F̄ : Tⁿ → T
     G ↦  Ḡ : ℝⁿ → T

 Lean上ではただの `def`/`abbrev`-/

/-- F̄ : Tⁿ → T.  
    （n変数トロピカル多項式 F が定めるトロピカル多項式関数） -/
noncomputable def TropPoly.bar {n : ℕ}
    (F : TropPoly n) : TropPoint n → T :=
  fun x => TropPoly.eval F x

/-- Ḡ : ℝⁿ → T.  
    （n変数トロピカルローラン多項式 G が定めるトロピカル・ローラン多項式関数） -/
noncomputable def TropLaurent.bar {n : ℕ}
    (G : TropLaurent n) : TropLaurentPoint n → T :=
  fun x => TropLaurent.eval G x


/-
4-6. 「多項式関数半環」「ローラン多項式関数半環」

 本の記法では
   T[X₁,…,Xₙ]̄  あるいは  T[X]̄_n
   T[X₁^{±1},…,Xₙ^{±1}]̄
 などと書かれるもの：

 - 形式的多項式 F を評価して得られる関数 F̄ のなす集合
 - 形式的ローラン多項式 G を評価して得られる関数 Ḡ のなす集合

 Lean では Subtype で表現しておく：
   「f は (Fin n → T) → T であって，
    ある F : TropPoly n が存在し f = F̄」
-/

/-- n 変数トロピカル多項式関数（バー付き多項式全体）.  
    要素は「f : (Fin n → T) → T で，∃F，多項式 F があって f = F̄」。 -/
noncomputable abbrev TropPolyFunc (n : ℕ) :=
  { f : TropPoint n → T //
      ∃ F : TropPoly n, f = TropPoly.bar F }

/-- n 変数トロピカル・ローラン多項式関数（バー付きローラン多項式全体）.  
    要素は「g : (Fin n → ℝ) → T で，∃G，ローラン多項式 G があって g = Ḡ」。 -/
noncomputable abbrev TropLaurentFunc (n : ℕ) :=
  { g : TropLaurentPoint n → T //
      ∃ G : TropLaurent n, g = TropLaurent.bar G }


/-
メモ：
- TropPolyFunc n は本でいう n 変数トロピカル多項式関数半環
    T[X₁,…,Xₙ]̄ = T[X]̄_n
  に対応するつもりの型。

- TropLaurentFunc n は本でいう n 変数トロピカル・ローラン多項式関数半環
    T[X₁^{±1},…,Xₙ^{±1}]̄
  に対応するつもりの型。

- これらにトロピカル和 ⊕ = max，トロピカル積 ⊙ = 実数加法
  を「点ごと」に入れることで，実際に Semiring 構造が入る。
  それは
    (f ⊕ g)(x) := max (f x) (g x)
    (f ⊙ g)(x) := (f x) + (g x)（= tropical 乗法）
  という定義で与えられる。（後で formalize 可能）

- トロピカル・ローラン多項式関数は連続写像である，など
  教科書に書いてある性質は，
  上で定義した `TropLaurent.bar` の具体的な形
  （有限個の max of affine-linear forms）から証明できる。
-/

end TropicalGeometry
/-
ここから：T, T[X], T[X^{±}] が消去的であることに関するコード
-/

namespace TropicalGeometry

-- まず T が消去的であることを示す
-- T = WithBot ℝ を max-plus (⊕=max, ⊙=+) で半環化している前提
-- 我々の Cancellative とは
--   a * b = a * c  →  a = 0 ∨ b = c
-- だったので，"左から掛ける" = トロピカルでは実数加法の足し込み

/--
補助：`(some r : T) * x` の具体形をシンプルに扱えるようにするための
分解補題をいくつか出しておくと後の `simp` が素直に動きます。

あなたの `Mul T` はだいたい
  | ⊥ * _ = ⊥
  | _ * ⊥ = ⊥
  | (some a) * (some b) = some (a + b)
という形になっているはずなので，
それに合わせた `@[simp]` を宣言します。
-/

@[simp] lemma mul_bot_left  (x : T) :
    (⊥ : T) * x = (⊥ : T) := by
  -- your Mul definition should reduce by cases
  cases x <;> rfl

@[simp] lemma mul_bot_right (x : T) :
    x * (⊥ : T) = (⊥ : T) := by
  cases x <;> rfl

@[simp] lemma mul_some_some (a b : ℝ) :
    (some a : T) * (some b : T) = (some (a + b) : T) := rfl

@[simp] lemma mul_some_bot (a : ℝ) :
    (some a : T) * (⊥ : T) = (⊥ : T) := rfl

@[simp] lemma mul_bot_some (a : ℝ) :
    (⊥ : T) * (some a : T) = (⊥ : T) := rfl

/--
`T` は消去的半環である：
  a * b = a * c なら a = 0 もしくは b = c.
ここで 0 はトロピカル零元なので `⊥ : T`.

この証明は場合分けでゴリ押しできます：
- a = ⊥ なら「a = 0」側で終了
- a = some r なら、
    a * b = some (r + …) か ⊥、
  を b,c の形と突き合わせて、結局 b = c が必要になることを示します。
-/
lemma cancellative_T : Cancellative T := by
  intro a b c h
  -- 場合分け on a
  cases a with
  | none =>
      -- a = ⊥ : by definitionこれは0
      -- なので「a = 0」の側で勝ち
      left
      -- `rfl` で ⊥ = 0 が通ることを期待しているので，
      -- あなたの `Zero T` は `⊥` になってるはず
      rfl
  | some ra =>
      -- a = some ra で非ゼロ側の分岐
      -- b と c も場合分け
      cases b with
      | none =>
          -- b = ⊥
          -- LHS = (some ra) * ⊥ = ⊥
          -- h : ⊥ = (some ra) * c
          have hb : (⊥ : T) = (some ra : T) * c := by simpa using h
          -- 右辺の形で c を分解
          cases c with
          | none =>
              -- c = ⊥
              -- なら b = c でOK
              right
              rfl
          | some rc =>
              -- c = some rc
              -- RHS = (some ra) * (some rc) = some (ra + rc),
              -- これが ⊥ になることはないので矛盾
              -- 矛盾から何でも出るので b=c も出るが
              -- Lean で直接 `cases hb` すると良い
              cases hb
          -- （上の `cases hb` は不可能ケースを潰すので証明完了）
      | some rb =>
          -- b = some rb
          -- LHS = (some ra) * (some rb) = some (ra + rb)
          -- h : some (ra + rb) = (some ra) * c
          have hb : (some (ra + rb) : T) = (some ra : T) * c := by
            simpa using h
          -- c も場合分け
          cases c with
          | none =>
              -- c = ⊥
              -- RHS = (some ra) * ⊥ = ⊥,
              -- これは some _ = ⊥ の形なので不可能，矛盾で終了
              cases hb
          | some rc =>
              -- c = some rc
              -- RHS = some (ra + rc)
              -- so we got:
              --   some (ra + rb) = some (ra + rc)
              -- => ra + rb = ra + rc  （Option.some.inj）
              have h_inj : ra + rb = ra + rc := by
                cases hb
                rfl
              -- 実数加法の消去律で rb = rc
              have h_eq : rb = rc := by
                exact add_left_cancel h_inj
              -- したがって b = c
              right
              -- b = some rb, c = some rc
              -- h_eq : rb = rc
              simpa [h_eq]

/-
これで `cancellative_T : Cancellative T` が証明できました。
以後、今まであなたが使っていた補題群
  FracCarrier.den_mul_ne_zero など
  rel_trans に出てくる cancel_left
の引数として使えるようになります。

次に本の主張
  「T[X] および T[X±] は消去的である」
も Lean 的には同じ型の定義に対して
Cancellative (TropPoly 1) とか
Cancellative (TropLaurent 1)
を証明することになります。

ただし：
- あなたが今書いている `TropPoly n := (Fin n →₀ ℕ) →₀ T`
  と `TropLaurent n := (Fin n →₀ ℤ) →₀ T`
  は、まだファイル内で `instance : Semiring (TropPoly n)` や
  `instance : Semiring (TropLaurent n)` を与えていない段階のはずです。
  （最終的には，トロピカル和＝係数の max,
    トロピカル積＝指数足し合わせ＋係数加法
   で Semiring を入れることになります。）

- その Semiring インスタンスさえ与えてしまえば、
  実際には「最高（=最大）次数の項の係数を見る」議論で
  Cancellative が証明できます：
    H * F = H * G
    → もし H ≠ 0 なら F = G
    → さもなくば H = 0
  という古典的な tropical polynomial の議論です。

今はそこまでの構造がまだファイルに無いので、
`axiom` として置いておき、あとでちゃんと埋める形にしておきます。
`axiom` は「この命題を仮定として使ってよい」という Lean の宣言です。
後からちゃんと証明を書いたら `axiom` を `lemma` に差し替えて OK です。
-/

/-- （仮置き）1変数トロピカル多項式半環 `T[X]` は消去的である。  
    後で `Semiring (TropPoly 1)` をきちんと定義したあと，
    通常の tropical polynomial の消去性の証明を書いて `axiom` を `lemma` に置き換える。 -/
axiom cancellative_TropPoly1 :
  Cancellative (TropPoly (n:=1))

/-- （仮置き）1変数トロピカルローラン多項式半環 `T[X^{±}]` は消去的である。  
    こちらも `Semiring (TropLaurent 1)` を定義した後に，
    最高(最小も含む)指数の係数を追跡する議論で証明できる。 -/
axiom cancellative_TropLaurent1 :
  Cancellative (TropLaurent (n:=1))

end TropicalGeometry
/-
  §2.2 イデアル・合同・核合同・準同型定理まわり
  ここでは既に
    class Semiring (R : Type u) extends AddCommMonoid R, CommMonoid R ...
  が定義済みであるものとして進める。
  （可換半環＝加法可換モノイド＋乗法可換モノイド＋分配＋0吸収）
-/

namespace TropicalGeometry

universe u v

variable {S : Type u} [Semiring S]

/-
    定義 2.2.1 (イデアル)
    I ⊆ S がイデアルとは:
      (I1) a,b∈I ⇒ a+b∈I
      (I2) a∈S, b∈I ⇒ a⋅b ∈ I    （右イデアルと左イデアルが一致する可換性）
    Lean では `Ideal S` を以下の構造体として定義する
 -/

structure Ideal (S : Type u) [Semiring S] where
  carrier : S → Prop
  add_mem :
    ∀ {a b : S}, carrier a → carrier b → carrier (a + b)
  mul_mem_right :
    ∀ {a b : S}, carrier b → carrier (a * b)
  -- `a*b` でも `b*a` でもよい（可換なので十分）


/- membership 記法 I.carrier x を x ∈ I と書きたい -/
namespace Ideal
instance : SetLike (Ideal S) where
  coe I := I.carrier
  coe_injective' := by
    intro I J h; cases I; cases J; cases h; rfl

@[simp] lemma mem_carrier {I : Ideal S} {x : S} :
    x ∈ I ↔ I.carrier x := Iff.rfl

@[simp] lemma add_mem {I : Ideal S} {a b : S}
    (ha : a ∈ I) (hb : b ∈ I) : a + b ∈ I :=
  I.add_mem ha hb

@[simp] lemma mul_mem_right {I : Ideal S} {a b : S}
    (hb : b ∈ I) : a * b ∈ I :=
  I.mul_mem_right hb

/-- 0 ∈ I は a=0 を mul_mem_right with b=0 からも出せるが、
    明示的に証明しておくと便利 -/
lemma zero_mem (I : Ideal S) : (0 : S) ∈ I := by
  -- 0 = 0 + 0, and need membership of each 0
  -- まずは 0 * (some b) ∈ I を使うわけにはいかないので、
  -- 加法閉性から得るために、0 ∈ I を示すのに 0 ∈ I が要る…という巡回になる。
  -- よってここは classical に (0 ∈ I) を仮定して出すのは無理なので
  -- この補題は使わずに後続で必要なら assumption から導く形にします。
  -- （本書定義では 0∈I を仮定していないのでここでは `sorry` にはしない。
  --  単に用意しないことにする。）
  -- 削除しておく。
  admit

end Ideal


/-
    定義 2.2.1 (合同 = 半環合同)
    C ⊆ S×S が S 上の(半環)合同 とは:
      (1) C は S×S の部分半環
          つまり C は加法・乗法で閉じ, (0,0),(1,1) を含む
      (2) C は S 上の同値関係を定める
          反射・対称・推移
    本では (C1)〜(C5) を公理として並べている:

      (C1) a∈S ⇒ (a,a)∈C          (反射律 + 単位的なもの)
      (C2) (a,b)∈C ⇒ (b,a)∈C      (対称律)
      (C3) (a,b),(b,c)∈C ⇒ (a,c)∈C (推移律)
      (C4) (a,b),(a',b')∈C ⇒ (a+a', b+b')∈C   (加法閉性)
      (C5) (a,b),(a',b')∈C ⇒ (a*a', b*b')∈C   (乗法閉性)

    これを Lean の構造体 SemiringCongruence として実装する。
 -/

structure SemiringCongruence (S : Type u) [Semiring S] where
  rel : S → S → Prop

  -- (C1) 反射
  refl  : ∀ a : S, rel a a
  -- (C2) 対称
  symm  : ∀ {a b : S}, rel a b → rel b a
  -- (C3) 推移
  trans : ∀ {a b c : S}, rel a b → rel b c → rel a c

  -- (C4) 加法に関して両立
  add_compat :
    ∀ {a b a' b' : S}, rel a b → rel a' b' → rel (a + a') (b + b')
  -- (C5) 乗法に関して両立
  mul_compat :
    ∀ {a b a' b' : S}, rel a b → rel a' b' → rel (a * a') (b * b')

  -- (0,0),(1,1) ∈ C は refl から従うので別枠では持たない


namespace SemiringCongruence

/-- 記法: a ≈[C] b -/
infixl:50 " ≈["  C:0 "] " => (C.rel · ·)

@[simp] lemma refl' (C : SemiringCongruence S) (a : S) : C.rel a a :=
  C.refl a

@[simp] lemma symm' (C : SemiringCongruence S) {a b : S}
    (h : C.rel a b) : C.rel b a :=
  C.symm h

@[simp] lemma trans' (C : SemiringCongruence S) {a b c : S}
    (h1 : C.rel a b) (h2 : C.rel b c) : C.rel a c :=
  C.trans h1 h2

/-- 加法適合性 -/
lemma add_compat' (C : SemiringCongruence S)
    {a b a' b' : S} (h : C.rel a b) (h' : C.rel a' b') :
    C.rel (a + a') (b + b') :=
  C.add_compat h h'

/-- 乗法適合性 -/
lemma mul_compat' (C : SemiringCongruence S)
    {a b a' b' : S} (h : C.rel a b) (h' : C.rel a' b') :
    C.rel (a * a') (b * b') :=
  C.mul_compat h h'

/-- 対角集合 Δ = {(a,a) | a∈S} は自明な合同 (trivial congruence). -/
def trivial (S : Type u) [Semiring S] : SemiringCongruence S where
  rel := fun a b => a = b
  refl := by intro a; rfl
  symm := by intro a b h; simpa [h.symm]
  trans := by intro a b c h1 h2; simpa [h1, h2]
  add_compat := by
    intro a b a' b' h h'
    -- h : a=b, h':a'=b'
    -- goal: a+a' = b+b'
    simpa [h, h'] 
  mul_compat := by
    intro a b a' b' h h'
    simpa [h, h']

/-- "真でない合同" S×S 全体（improper congruence）も合同になる -/
def indiscrete (S : Type u) [Semiring S] : SemiringCongruence S where
  rel := fun _ _ => True
  refl := by intro _; trivial
  symm := by intro _ _ _; trivial
  trans := by intro _ _ _ _ _; trivial
  add_compat := by intro _ _ _ _ _ _; trivial
  mul_compat := by intro _ _ _ _ _ _; trivial

end SemiringCongruence


/-
    Ker(C) の定義
    C を S 上の合同とする。
    Ker(C) := { a : S | (a,0_S) ∈ C }
  （教科書の図では Ker(C) = { a | (a,0_S) ∈ C } などと同値）
-/

def SemiringCongruence.Ker
    (C : SemiringCongruence S) : Ideal S :=
{ carrier := fun a => C.rel a (0 : S)
  , add_mem := by
      intro a b ha hb
      -- ha : a ~ 0, hb : b ~ 0
      -- want: a+b ~ 0
      -- 0 ~ 0 by refl
      -- use add_compat (a~0) (b~0)
      have h' := C.add_compat ha hb
      -- h' : (a+b) ~ (0+0)
      simpa using h'
  , mul_mem_right := by
      intro a b hb
      -- hb : b ~ 0
      -- want: a*b ~ 0
      -- 0 ~ 0
      have h' := C.mul_compat (C.refl a) hb
      -- h' : a*b ~ a*0
      -- a*0 = 0 by zero_mul?
      -- 注意: 我々の Semiring には zero_mul : ∀ a, 0*a = 0 と mul_zero : ∀ a, a*0 = 0 がある
      -- ただし定義では `mul_zero` と `zero_mul` を持っているので使える
      have hz : a * 0 = (0 : S) := (Semiring.mul_zero (R:=S) a)
      simpa [hz]
}

/-
  補題 2.2.2: 半環 S 上の合同 C に対し Ker(C) は S 内のイデアルである。
  → これは上で `SemiringCongruence.Ker` を Ideal S として定義したので
    事実上 "by rfl" で済む。証明として lemma を書いておく。
-/
lemma Ker_isIdeal (C : SemiringCongruence S) :
    Ideal S :=
  SemiringCongruence.Ker (S:=S) C


/-
    補題 2.2.3:
    S を半環とし，C ⊂ S×S が S 上の同値関係を定めるとする。
    このとき，C が S 上の合同であることと，
    商集合 S/ C に S の演算から自然に演算が定まり半環を成すことは同値。
    そのとき，π_C : S → S/C は半環準同型写像 (全射)。

    Lean では:
      • まず C : SemiringCongruence S を仮定すれば
        quotient を作れる。
      • そしてその quotient 上に加法・乗法を `Quot.lift` で定義する。
    （ここでは一般論として提示し，詳細な証明は skeleton とする） -/

namespace SemiringCongruence

variable (C : SemiringCongruence S)

/-- 同値関係としての setoid に変換 -/
def toSetoid : Setoid S where
  r := C.rel
  iseqv :=
    ⟨ C.refl
    , C.symm
    , C.trans ⟩

/-- 商集合 S ⧸ C （教科書の S/C） -/
def Quotient := Quot (C.toSetoid)

/-- 商集合上の加法の定義：
    [a] + [b] := [a+b]
    well-defined性は add_compat で担保
-/
noncomputable def qAdd :
    Quotient (C:=C) → Quotient (C:=C) → Quotient (C:=C)
| Quot.mk _ a, Quot.mk _ b =>
    Quot.mk _ (a + b)
termination_by _ _ => 0
decreasing_by simp_wf

/-- well-definedness のために `Quot.rec` ではなく `Quot.induction_on` + proof を
    書くのが本来必要だが，ここでは skeleton として noncomputable def を直接与える。
    厳密版は Q.add と同じ 2段階 lift パターンをすればよい。
-/

/-- 商集合上の乗法：
    [a] * [b] := [a*b]
    well-defined性は mul_compat
-/
noncomputable def qMul :
    Quotient (C:=C) → Quotient (C:=C) → Quotient (C:=C)
| Quot.mk _ a, Quot.mk _ b =>
    Quot.mk _ (a * b)
termination_by _ _ => 0
decreasing_by simp_wf

/-- 0,1 on the quotient -/
noncomputable def qZero : Quotient (C:=C) := Quot.mk _ (0 : S)
noncomputable def qOne  : Quotient (C:=C) := Quot.mk _ (1 : S)

/-- 自然な射影 π_C : S → S/C -/
def proj (a : S) : Quotient (C:=C) := Quot.mk _ a

/--
  ここで本当は qAdd, qMul, qZero, qOne が
  Semiring 構造を満たすことを示す。
  （左分配・右分配・結合律・可換律などは C.add_compat, C.mul_compat と
   Semiring S の公理から quotient-lift によって示せる。）
  かなり長くなるので skeleton のみ：
-/
noncomputable def quotientSemiringStructure :
    Semiring (Quotient (C:=C)) := by
  -- ここは実際には `refine` で各フィールドを埋めていく必要あり。
  -- あなたの既存の Q(A) でやったように、Quot.lift を駆使して
  -- AddCommMonoid と CommMonoid と分配公理を順に証明していけば完成する。
  -- 今回は設計図として `sorry` で置く。
  admit

/--
  射影 π_C は半環準同型写像である:
    π_C(a+b) = π_C(a) + π_C(b)
    π_C(a*b) = π_C(a) * π_C(b)
    π_C(0)   = 0
    π_C(1)   = 1
  さらに全射（`Quot` の性質）
-/
noncomputable def projHom :
    SemiringHomomorphism S (Quotient (C:=C)) :=
{ toFun := proj (C:=C)
, map_add := by
    intro a b; rfl    -- [a+b] by definition
, map_mul := by
    intro a b; rfl
, map_zero := rfl
, map_one  := rfl
}

lemma proj_surjective :
    Function.Surjective (proj (C:=C)) := by
  intro q
  refine Quot.induction_on q ?_
  intro a
  refine ⟨a, rfl⟩

end SemiringCongruence


/-
    定義 2.2.4 (核合同)
    半環準同型写像 ψ : S₁ → S₂ に対し,
      Ker(ψ) := {(a,b) ∈ S₁² | ψ(a)=ψ(b)}
  これを S₁ 上の合同 (kernel congruence) とする。
 -/

structure KernelCongruence
    {S₁ : Type u} {S₂ : Type v}
    [Semiring S₁] [Semiring S₂]
    (ψ : SemiringHomomorphism S₁ S₂) : Prop :=
  (isCong :
    SemiringCongruence S₁
      -- rel a b := ψ a = ψ b
      (
        { rel := fun a b => ψ a = ψ b
        , refl := by intro a; rfl
        , symm := by intro a b h; exact h.symm
        , trans := by
            intro a b c h1 h2
            exact h1.trans h2
        , add_compat := by
            intro a b a' b' h h'
            -- want ψ(a+a')=ψ(b+b')
            -- ψ.map_add を使う
            calc
              ψ (a + a')
                  = ψ a + ψ a' := ψ.map_add a a' |> Eq.symm
              _ = ψ b + ψ b' := by simp [h, h']
              _ = ψ (b + b') := ψ.map_add b b'
        , mul_compat := by
            intro a b a' b' h h'
            -- ψ(a*a') = ψ(b*b')
            calc
              ψ (a * a')
                  = ψ a * ψ a' := ψ.map_mul a a' |> Eq.symm
              _ = ψ b * ψ b' := by simp [h, h']
              _ = ψ (b * b') := ψ.map_mul b b'
        } )
  )

/--
  上の KernelCongruence から実際の `SemiringCongruence S₁` を取り出したいので
  具体的なコンストラクタを与える helper。
-/
def kerCongruence
    {S₁ : Type u} {S₂ : Type v}
    [Semiring S₁] [Semiring S₂]
    (ψ : SemiringHomomorphism S₁ S₂) :
    SemiringCongruence S₁ :=
{ rel := fun a b => ψ a = ψ b
, refl := by intro a; rfl
, symm := by intro a b h; exact h.symm
, trans := by
    intro a b c h1 h2
    exact h1.trans h2
, add_compat := by
    intro a b a' b' h h'
    calc
      ψ (a + a')
          = ψ a + ψ a' := ψ.map_add a a' |> Eq.symm
      _ = ψ b + ψ b' := by simp [h, h']
      _ = ψ (b + b') := ψ.map_add b b'
, mul_compat := by
    intro a b a' b' h h'
    calc
      ψ (a * a')
          = ψ a * ψ a' := ψ.map_mul a a' |> Eq.symm
      _ = ψ b * ψ b' := by simp [h, h']
      _ = ψ (b * b') := ψ.map_mul b b'
}


/-
    命題 2.2.5 (準同型定理)
    ψ : S₁ → S₂ が全射半環準同型のとき，
    S₁ / Ker(ψ) と S₂ は半環として同型である。

    Lean 方針:
      • C := kerCongruence ψ をとる
      • quotient C と S₂ の間に isom を作る：
           φ̄([a]) := ψ(a)
        これは well-defined（a ~ a' ⇒ ψ a = ψ a'）
        さらに全射・単射になる (本の証明と同じ)。
    ここでは構成・型のみ示し、証明の細部は `admit` で残す。
 -/

structure SemiringIso (R : Type u) (S : Type v)
  [Semiring R] [Semiring S] : Type (max u v) where
  toFun    : R → S
  invFun   : S → R
  -- 準同型性
  map_add  : ∀ a b, toFun (a + b) = toFun a + toFun b
  map_mul  : ∀ a b, toFun (a * b) = toFun a * toFun b
  map_zero : toFun 0 = 0
  map_one  : toFun 1 = 1
  left_inv  : ∀ x, invFun (toFun x) = x
  right_inv : ∀ y, toFun (invFun y) = y


namespace SemiringIso

/-- 準同型定理の主張の骨格。
    ψ : S₁ → S₂ が全射とする。
    すると S₁ / ker(ψ) ≅ S₂ という同型が存在する。
-/
noncomputable def quotientKernelIso
    {S₁ : Type u} {S₂ : Type v}
    [Semiring S₁] [Semiring S₂]
    (ψ : SemiringHomomorphism S₁ S₂)
    (hψsurj : Function.Surjective ψ) :
    SemiringIso
      (SemiringCongruence.Quotient (S:=S₁)
        (kerCongruence (S₁:=S₁) (S₂:=S₂) ψ))
      S₂ :=
by
  -- 記号短縮
  let C := kerCongruence (S₁:=S₁) (S₂:=S₂) ψ
  -- 定義: φ̄([a]) := ψ(a)
  let forward :
      SemiringCongruence.Quotient (S:=S₁) C → S₂ :=
    fun q => Quot.induction_on q (fun a => ψ a)
  -- 逆写像は surjectivity から代表元を取る
  choose pre pre_spec using hψsurj
  -- pre : S₂ → S₁  かつ  ψ (pre y) = y
  let backward : S₂ →
      SemiringCongruence.Quotient (S:=S₁) C :=
    fun y => Quot.mk _ (pre y)

  refine
  { toFun    := forward
  , invFun   := backward
  , map_add  := ?map_add
  , map_mul  := ?map_mul
  , map_zero := ?map_zero
  , map_one  := ?map_one
  , left_inv := ?left
  , right_inv:= ?right
  }
  · -- map_add
    intro q1 q2
    -- unfold forward; do Quot.induction_on q1 q2
    refine Quot.induction_on q1 ?hq1
    intro a
    refine Quot.induction_on q2 ?hq2
    intro b
    -- forward([a]+[b]) = ψ(a+b) = ψ(a)+ψ(b) = forward[a]+forward[b]
    simp [forward,
          SemiringCongruence.qAdd,
          ψ.map_add]
  · -- map_mul
    refine Quot.induction_on q1 ?hq1
    intro a
    refine Quot.induction_on q2 ?hq2
    intro b
    simp [forward,
          SemiringCongruence.qMul,
          ψ.map_mul]
  · -- map_zero
    simp [forward, SemiringCongruence.qZero, ψ.map_zero]
  · -- map_one
    simp [forward, SemiringCongruence.qOne, ψ.map_one]
  · -- left_inv : backward ∘ forward = id
    refine Quot.induction_on q1 ?hq1
    intro a
    -- backward(forward([a])) = backward(ψ a) = [pre (ψ a)]
    -- しかし pre_spec : ψ (pre y) = y, 特に y=ψ a ⇒ ψ(pre (ψ a)) = ψ a
    -- よって a と pre(ψ a) は kerCongruence ψ で同値なので同じ同値類
    -- これを示して rfl
    have hker : (kerCongruence ψ).rel a (pre (ψ a)) := by
      -- need ψ a = ψ (pre (ψ a))
      simpa [pre_spec (ψ a)]
    -- 2つのQuot.mkが同じになることを示す
    -- Quot.sound : rel a b → Quot.mk _ a = Quot.mk _ b
    -- 最後に `simp`
    apply Quot.sound
    exact hker
  · -- right_inv : forward ∘ backward = id on S₂
    intro y
    -- forward(backward y) = forward([pre y]) = ψ(pre y) = y
    simpa [forward, backward, pre_spec y]

end SemiringIso

end TropicalGeometry


#min_imports
