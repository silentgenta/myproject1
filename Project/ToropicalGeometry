/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1（宋先生の定義に忠実に従った(可換な)Semiringの定義）
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : ∀ a : R, a * 0 = 0
  zero_mul : ∀ a : R, 0 * a = 0
  left_distrib  : ∀ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

--ついでに半体を定義
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) ≠ 1)
  (exists_inv  : ∀ {a : R}, a ≠ 0 → ∃ b : R, a * b = 1)

--加法的冪等の定義
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  ∀ a : R, a + a = a

--Ex2.1.2 𝔹=({0,-∞},max,+)は半体である
inductive 𝔹 : Type
| negInf
| zero

/-
つけておくといいことがあるとGPTからアドバイスあり
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero 𝔹 := ⟨𝔹.negInf⟩
instance : One  𝔹 := ⟨𝔹.zero⟩

instance : Add 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zero⟩

instance : Mul 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInf⟩

/- 加法について可換モノイド -/
instance : AddCommMonoid 𝔹 where
  add := (·+·)
  zero := (0 : 𝔹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- 乗法について可換モノイド -/
instance : CommMonoid 𝔹 where
  mul := (·*·)
  one := (1 : 𝔹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(半環準同型の定義)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 → S2
  map_add : ∀ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : ∀ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--今後ただの構造だってSemiringhomomorphismを関数として使えるようにする。これがないといちいちf.toFun xと書かなきゃいけなくなる。
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 → S2) where
  coe f := f.toFun

--simpを使えるように
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--恒等準同型の定義
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--準同型の合成の定義。半環準同型に必要な５要素を順に証明
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgは両辺に同じ関数を適用してよいという補題。f.map_addの両辺にgを適用したということ
      _ = g (f a) + g (f b) := by --_はg (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

--S₁代数の定義
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Ψ : SemiringHomomorphism B A) : Algebra A B :=
  ⟨Ψ⟩
--semiringhomoには名前のついていない関数があるのでそれをΨと名付ける。

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--AとBの間に必ず存在する半環準同型を一つ取り出すことが出来るようになる。reducibleにすることでalgeMapを使うと自動でh.homのような必ず存在する半環準同型を呼び出してくれる。

--simp用
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-代数準同型の定義
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A → X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A → Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 可換図式--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g に a を適用
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) h.comm

end AlgHom


--A-代数準同型の存在
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  ∃ (Ψ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Ψ
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--具体的な Ψ と可換性
theorem intro
  (Ψ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Ψ
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  ⟨Ψ, h⟩

--ひとつΨを取り出す。 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

--取り出したΨが図式を可換にする。 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--可換性の点ごとver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commを取り出してcongrArgを適用するだけ
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) hc

end AlgebraRel

-- A-代数同型の定義
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- 互いに逆（AlgHom のフィールド toHom を一度だけ取り出して使う）
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- 同型の順方向の底の準同型を取り出す。 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- 同型の逆方向の底の準同型を取り出す。 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv ∘ eはidentity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idにxを適用
  exact congrArg (fun (φ : SemiringHomomorphism X X) => φ x) e.left_inv

--e ∘ e.invはidentity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idにyを適用
  exact congrArg (fun (φ : SemiringHomomorphism Y Y) => φ y) e.right_inv

--対称性
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--𝔹の導入
instance : Semiring 𝔹 where
  mul_zero := by intro a; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl

--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : 𝔹) + (1 : 𝔹)) = (1 : 𝔹) := rfl

--Aが加法冪等のとき，𝔹 → Aで半環準同型となる
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism 𝔹 A :=
{ toFun := fun x =>
    match x with
    | 𝔹.negInf => 0
    | 𝔹.zero   => 1,
  map_add := by
    intro x y
    cases x <;> cases y
    · -- (⊥, ⊥)：0 = 0 + 0
      exact (zero_add (0 : A)).symm
    · -- (⊥, 0)：1 = 0 + 1
      exact (zero_add (1 : A)).symm
    · -- (0, ⊥)：1 = 1 + 0
      exact (add_zero (1 : A)).symm
    · -- (0, 0)：1 = 1 + 1（冪等性）
      exact (h (1 : A)).symm,
  map_mul := by
    intro x y
    cases x <;> cases y
    · -- (⊥, ⊥)：0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    · -- (⊥, 0)：0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    · -- (0, ⊥)：0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    · -- (0, 0)：1 = 1 * 1
      exact (one_mul (1 : A)).symm,
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 「A が加法冪等」↔「A が 𝔹-代数（存在する）」 -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A ↔ Nonempty (Algebra A 𝔹) := by
  constructor
  · -- (→) 加法冪等 ⇒ 𝔹-代数が存在
    intro h
    exact ⟨Algebra.ofHom (boolHomOfAddIdem A h)⟩
  · -- (←) 𝔹-代数が存在 ⇒ 加法冪等
    intro hAlg
    rcases hAlg with ⟨inst⟩
    -- ψ : 𝔹 → A
    let ψ : SemiringHomomorphism 𝔹 A := inst.hom
    -- 1_A = 1_A + 1_A
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := ψ.map_add (1 : 𝔹) (1 : 𝔹)      -- ψ(1+1) = ψ1 + ψ1
      have h1 : ψ 1 = ψ 1 + ψ 1 := by
        simpa [B_one_add_one] using h0
      simpa [ψ.map_one] using h1
    -- 任意の a について a + a = a
    intro a
    -- まず a*1 = a*1 + a*1 を作る（左分配と h11A）
    have hmul : a * 1 = a * 1 + a * 1 := by
      -- a*(1+1) = a*1 + a*1 に対して，(1+1) → 1 へ書き換える
     simpa [← h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- あとは mul_one で仕上げ
    -- （向きを合わせるために対称を取る）
    have : a + a = a := by
      simpa [mul_one] using hmul.symm
    exact this



--≤ₐの定義

section OrderFromAddIdem

variable (A : Type u) [Semiring A]

--a ≤ₐ bをa + b = bとする。
def leA (a b : A) : Prop := a + b = b

--反射律
theorem leA_refl (h : AddIdempotent A) (a : A) : leA (A:=A) a a := by
  unfold leA
  simpa using h a

--推移律
theorem leA_trans {a b c : A}
    (hab : leA (A:=A) a b) (hbc : leA (A:=A) b c) :
    leA (A:=A) a c := by
  unfold leA at hab hbc ⊢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--反対称律
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0は最小元
theorem bot_leA (a : A) : leA (A:=A) (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA (A:=A) a b) :
    leA (A:=A) (c * a) (c * b) := by
  unfold leA at hab ⊢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  ∀ ⦃a b c : A⦄, a * b = a * c → a = (0 : A) ∨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--こんご便利になる(らしい)補題
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a ≠ (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  · exact (ha hzero).elim
  · exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--分母が 0 でない組 (a,b)の集合を定義
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A × A // p.2 ≠ (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- 分子 / 分母を記号で短縮
def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b ≠ 0) :
    num (A:=A) ⟨(a,b), hb⟩ = a := rfl
@[simp] lemma den_mk (a b : A) (hb : b ≠ 0) :
    den (A:=A) ⟨(a,b), hb⟩ = b := rfl
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p ≠ 0 := p.2

--同値関係
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--反射律
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--対称律
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

--推移律
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q r → Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q ≠ (0 : A) := den_ne_zero (A:=A) q

  -- ① (hpq) を右から r.den で掛け、形を q.den * (p.num * r.den) = r.den * (q.num * p.den)に整える
  have h1' :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- ② (hqr) を右から p.den で掛け、形を q.den * (r.num * p.den) = r.den * (q.num * p.den)に整える
  have h2' :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- ③ 同じ右辺を経由して q.den を左から消去
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1'.trans h2'.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aのRelは（cancellativeの下で）同値関係になる。  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    ⟨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) ⟩

end FracCarrier
end TropicalGeometry

namespace TropicalGeometry
open Classical

/- 商集合 Q(A) を作り、要素を a/b と書けるようにする -/

section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

/-- A の分数の商集合：`Q(A) := {(a,b) | b ≠ 0}/∼` -/
def Q : Type u := Quot (FracCarrier.setoid (A:=A) hC)

/-- 基本コンストラクタ：`a/b`（ただし `b ≠ 0`）を同値類に持ち上げる。 -/
def Q.mk (a b : A) (hb : b ≠ 0) : Q (A:=A) hC :=
  Quot.mk _ ⟨(a,b), hb⟩

/-- 「非零の分母」を包むミニ構造体。`⟨b, hb⟩ : NZDen A`。 -/
structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val ≠ 0

namespace Q

/-- 記法 `a / ⟨b, hb⟩` の本体：`Q.mk a b hb`。 -/
def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-! ### 記法

- まずこのセクション内だけ有効な **ローカル記法**。
  セクション変数 `hC` が見えるので、`a / b` がそのまま使えます。
- 併せて、任意の場所で使える **スコープ付き記法** `a /[hC] b` も用意。
  こちらは `hC` を明示するので前チェックに引っかかりません。
-/

/-- セクション内限定：`a / b : Q(A,hC)` （`b : NZDen A`） --/
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

/-- どこでも使える版：`a /[hC] b` （`b : NZDen A`） --/
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic
end TropicalGeometry

namespace TropicalGeometry
open Classical


section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- ここでの Q は「QuotBasic」で定義したものを使う（重複定義しない）

namespace FracCarrier

/-- 分母同士の積は 0 にならない（`Cancellative` を利用） -/
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den ≠ 0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 から p.den * q.den = p.den * 0 を得る
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _
    exact h.trans hz.symm
  -- 左から cancel
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

/-- 商和の「代表」： (a/b) + (c/d) := (ad + cb) / (bd) -/
def addRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ⟨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ⟩

/-- 商積の「代表」： (a/b) * (c/d) := (ac) / (bd) -/
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ⟨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ⟩

/-- 加法が同値関係と両立（well-defined） -/
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  -- 目標： (p.num*q.den + q.num*p.den)*(p'.den*q'.den)
  --     = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
  unfold Rel addRep
  -- (x+y)*z = x*z + y*z
  have H₀ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  -- 1段目：単純分配
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by
            simpa using H₀
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by
            -- かけ算の順序・結合の入れ替え
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            -- 右辺のペアの順序も入れ替える
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by
            -- 逆向きの分配（(a*c)+(b*c) = (a+b)*c）
            have H₁ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            -- 項の順序を `simp` で合わせてから対称を使う
            simpa [mul_comm, mul_left_comm, mul_assoc] using H₁.symm

/-- 乗法が同値関係と両立（well-defined） -/
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  -- 目標： (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den)
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

/-- Q(A) 上の加法（2段階 `Quot.lift` 方式） -/
noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  -- まず「右引数 q を代表に戻してから addRep を持ち上げる」関数を作る
  let addCore₁ :
      FracCarrier A → (Q (A:=A) hC → Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' のときも well-defined
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  -- 次に「左引数 p を代表に戻し、addCore₁ p を選ぶ」関数を作る
  let addCore₂ : Q (A:=A) hC → (Q (A:=A) hC → Q (A:=A) hC) :=
    Quot.lift
      (fun p => addCore₁ p)
      (by
        -- p ~ p' なら、関数 addCore₁ p = addCore₁ p'
        intro p p' hp
        apply funext
        intro y
        -- y も代表に戻して同値を作る
        refine Quot.induction_on y ?_
        intro q
        -- 目標を書き換え（2つの mk の等しさを示せばよい）
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        -- これは addRep_compat の (hp, refl) で成立
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- 以上を使って x, y に適用
  exact addCore₂ x y


/-- Q(A) 上の乗法（2段階 `Quot.lift` 方式） -/
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCore₁ :
      FracCarrier A → (Q (A:=A) hC → Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCore₂ : Q (A:=A) hC → (Q (A:=A) hC → Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCore₁ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCore₂ x y

end QAddMul
end TropicalGeometry

namespace TropicalGeometry
open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) (h10 : (1 : A) ≠ 0)

-- 0,1 の代表（分母 1 を使用）
def Q.zero : Q (A:=A) hC := Q.mk (A:=A) hC 0 1 h10
def Q.one  : Q (A:=A) hC := Q.mk (A:=A) hC 1 1 h10

-- 既に定義済みの Q.add / Q.mul を使ってインスタンス化


instance : Zero (Q (A:=A) hC) := ⟨Q.zero (A:=A) hC h10⟩
instance : One  (Q (A:=A) hC) := ⟨Q.one  (A:=A) hC h10⟩
instance : Add  (Q (A:=A) hC) := ⟨Q.add (A:=A) hC⟩
instance : Mul  (Q (A:=A) hC) := ⟨Q.mul (A:=A) hC⟩

namespace FracCarrier

variable {hC}

/-- 加法の可換性（代表版） -/
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  -- Rel と addRep, num, den を展開して目標式を素の等式に落とす
  unfold Rel addRep num den
  -- 目標：
  -- (p.num*q.den + q.num*p.den) * (q.den*p.den)
  --   = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  -- 和の順序と分母側の積の順序を入れ替えるだけで一致
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          -- 和の順序だけを可換法則で入れ替え
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          -- 分母側の積の順序を可換法則で入れ替え
          ac_rfl

/-- 加法の結合性（代表版） -/
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  -- どちら側も分母は p.den*q.den*r.den の順序違い。分子は分配で一致。
  -- ひたすら分配＋可換結合で並べ替え。
  unfold Rel addRep
  -- 省略せず正攻法： ( (p.num*q.den + q.num*p.den)*r.den + r.num*(p.den*q.den) ) * ( (p.den*q.den)*r.den )
  -- と ( p.num*(q.den*r.den) + (q.num*r.den + r.num*q.den)*p.den ) * ( p.den*(q.den*r.den) )
  -- を ac と分配を駆使して一致させる。
  -- 計算は長いが、`right_distrib` を2回ずつ当てて各項を同型に並べ替えればよい。
  -- 書き換え用の補助：
  have Dpq : p.den * q.den = q.den * p.den := by ac_rfl
  have Drp : r.den * p.den = p.den * r.den := by ac_rfl
  have Dqr : q.den * r.den = r.den * q.den := by ac_rfl
  -- 展開して合わせる（`calc`＋`simp` で押し切る）
  -- （詳細展開は機械的。以下は一括で片付けるための `simp` ブロック）
  -- Lean の可換結合補題群（`mul_comm`, `mul_left_comm`, `mul_assoc`）と
  -- 右分配 `right_distrib` を適宜 `simpa` で使います。
  -- まず左辺を 3 項の和の和に展開
  have L :
    (p.num*q.den + q.num*p.den) * r.den
      + r.num * (p.den*q.den)
    = p.num*q.den*r.den + q.num*p.den*r.den + r.num*p.den*q.den := by
    -- 2回の分配＋結合可換で整形
    have := Semiring.right_distrib (R:=A)
                (p.num*q.den) (q.num*p.den) r.den
    -- (x+y)*z = x*z + y*z
    -- さらに各項に結合を適用
    -- 仕上げ：
    simpa [mul_comm, mul_left_comm, mul_assoc] using
      congrArg (fun t => t + r.num * (p.den*q.den)) this
  have R :
    p.num*(q.den*r.den)
      + (q.num*r.den + r.num*q.den)*p.den
    = p.num*q.den*r.den + q.num*r.den*p.den + r.num*q.den*p.den := by
    have := Semiring.right_distrib (R:=A)
                (q.num*r.den) (r.num*q.den) p.den
    -- こちらも同様に整形
    simpa [mul_comm, mul_left_comm, mul_assoc] using
      congrArg (fun t => p.num*(q.den*r.den) + t) this
  -- すると両辺は可換結合で一致
  -- （q.den*p.den と p.den*q.den の入れ替えなど）
  have : (p.num*q.den*r.den + q.num*p.den*r.den + r.num*p.den*q.den)
       = (p.num*q.den*r.den + q.num*r.den*p.den + r.num*q.den*p.den) := by
    -- 第2・第3項の順序を合わせるだけ
    simp [mul_comm, mul_left_comm, mul_assoc]
  -- 以上を分母の並べ替えと合わせれば OK
  -- 今回は等式を “分子同士を一致させた” 形で示したので、そのまま `simp` で終える
  simpa [L, R, mul_comm, mul_left_comm, mul_assoc]

/-- 乗法の可換性（代表版） -/
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  -- (p.num*q.num)*(p.den*q.den) と (q.num*p.num)*(q.den*p.den)
  -- は ac で一致
  simp [mul_comm,  mul_assoc]

/-- 乗法の結合性（代表版） -/
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  -- どちらも分子 p.num*q.num*r.num，分母 p.den*q.den*r.den （順序違い）になるので ac
  simp [mul_comm,  mul_assoc]

/-- 左分配（代表版） -/
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- 目標：(p.num*(q.num*r.den + r.num*q.den))*(p.den*(q.den*r.den))
  --     = ((p.num*q.num)*r.den + (p.num*r.num)*q.den) * ((p.den*q.den)*r.den)
  unfold Rel addRep mulRep
  -- 展開→分配→順序入替で一致
  -- 左側の分子：
  have L :
    (p.num * (q.num * r.den + r.num * q.den))
    = p.num*q.num*r.den + p.num*r.num*q.den := by
    have := Semiring.left_distrib (R:=A) p.num (q.num * r.den) (r.num * q.den)
    simpa [mul_comm, mul_left_comm, mul_assoc] using this
  -- 全体としては右分配一回で形が一致する
  have H₁ :=
    Semiring.right_distrib (R:=A)
      (p.num*q.num*r.den) (p.num*r.num*q.den) (p.den*(q.den*r.den))
  -- 右辺の分配形
  have H₂ :=
    Semiring.right_distrib (R:=A)
      ((p.num*q.num)*r.den) ((p.num*r.num)*q.den) ((p.den*q.den)*r.den)
  -- 仕上げ
  simpa [L, mul_comm, mul_left_comm, mul_assoc] using H₂.symm

/-- 右分配（代表版） -/
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by
  -- 左分配の対称版（comm を挟んでも良い）
  -- ここは直接展開しても短い
  unfold Rel addRep mulRep
  -- (p.num*q.den + q.num*p.den)*r.num = ...
  have L :
    (p.num*q.den + q.num*p.den) * r.num
      = p.num*r.num*q.den + q.num*r.num*p.den := by
    have := Semiring.left_distrib (R:=A) r.num (p.num*q.den) (q.num*p.den)
    -- (r*(x+y) = r*x + r*y) を可換結合で整形
    simpa [mul_comm, mul_left_comm, mul_assoc] using this.symm
  have H₁ :=
    Semiring.right_distrib (R:=A)
      (p.num*r.num*q.den) (q.num*r.num*p.den) ((p.den*q.den)*r.den)
  have H₂ :=
    Semiring.right_distrib (R:=A)
      ((p.num*r.num)*q.den) ((q.num*r.num)*p.den) ((p.den*q.den)*r.den)
  simpa [L, mul_comm, mul_left_comm, mul_assoc] using H₂.symm

end FracCarrier

/************************ ここから構造を持ち上げる ************************/

-- 加法群律（加法：可換・結合・0 は単位）
instance : AddCommMonoid (Q (A:=A) hC) where
  add := (· + ·)
  zero := (0 : Q (A:=A) hC)
  add_assoc := by
    intro x y z
    -- 3 変数の `Quot` 降ろし → 代表版補題 → `Quot.sound`
    refine Quot.induction_on x ?hx |>.trans ?_
    · intro p; refine Quot.induction_on y ?hy
      · intro q; refine Quot.induction_on z ?hz
        · intro r
          apply Quot.sound
          exact FracCarrier.addRep_assoc (A:=A) hC p q r
    · -- 合体
      rfl
  zero_add := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    -- 0 + p = p
    -- 代表 0 は (0,1)
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC
                   ⟨(0,1), h10⟩ p)
        = Quot.mk _ p
    apply Quot.sound
    -- (0/1)+ (a/b) ~ (a/b)
    -- これは addRep_compat に rel_refl と、(0,1) ~ (0,1) を使えばOK（自明）
    -- 直接等式でも良いが、Rel で押す：
    -- addRep_compat (refl, refl) では足りないので、実際の等式で証明
    -- 0/1 + a/b = (0*b + a*1)/(1*b) ~ a/b は代表計算で分子が a*b に一致
    -- すなわち Rel: (a*1)*(1*b) = (a*b)*(1*1)
    -- 直接書く：
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]

  add_zero := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC p ⟨(0,1), h10⟩)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]
  add_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q
  nsmul := fun n x =>
    Nat.recOn n (0) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

-- 乗法モノイド（可換）
instance : CommMonoid (Q (A:=A) hC) where
  mul := (· * ·)
  one := (1 : Q (A:=A) hC)
  mul_assoc := by
    intro x y z
    refine Quot.induction_on x ?hx |>.trans ?_
    · intro p; refine Quot.induction_on y ?hy
      · intro q; refine Quot.induction_on z ?hz
        · intro r
          apply Quot.sound
          exact FracCarrier.mulRep_assoc (A:=A) hC p q r
    · rfl
  one_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ⟨(1,1), h10⟩ p)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_one := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(1,1), h10⟩)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q
  npow := fun n x =>
    Nat.recOn n (1) (fun _ s => s * x)

/-- 分配・零吸収を持ち上げて Semiring インスタンス -/
instance : Semiring (Q (A:=A) hC) where
  mul_zero := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    -- p * 0 = 0
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(0,1), h10⟩)
        = (0 : Q (A:=A) hC)
    -- 右辺の 0 は ⟨(0,1),h10⟩ の同値類
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ⟨(0,1), h10⟩)
        = Quot.mk _ ⟨(0,1), h10⟩
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  zero_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ⟨(0,1), h10⟩ p)
        = Quot.mk _ ⟨(0,1), h10⟩
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    -- p * (q + r) = p*q + p*r  を `Rel` で主張
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r
  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r

/********************* 逆元の存在：Semifield 仕上げ *********************/

-- 「0 でない元 x は、何らかの代表 p で p.num ≠ 0」を使って逆を立てる。
-- x = [a/b]（b≠0）で a ≠ 0 なら逆は [b/a]。
-- x = 0 のとき（つまり任意代表が a=0）以外はこれで十分。
-- そこでまず、0 判定の補題を作る。

namespace FracCarrier

/-- [a/b] = 0 であることの代表版判定：a = 0 -/
lemma zero_iff_num_eq_zero (hC : Cancellative A)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p ⟨(0,1), by exact (show (1:A) ≠ 0 from ?_)⟩
      ↔ p.num = 0 := by
  -- ここでは `?_.` に `h10` を入れたいので、外側で使う形に書き換えます。
  -- 実運用では直接使わず、下の `nonzero_num_of_ne_zero` で `h10` を受け渡します。
  admit

end FracCarrier

/-- 非零元は分子が非零な代表を持つ -/
lemma nonzero_num_of_ne_zero
    {x : Q (A:=A) hC} (hx : x ≠ 0) :
    ∃ p : FracCarrier A, Quot.mk _ p = x ∧ p.num ≠ 0 := by
  -- x を代表 p に降ろす。もし p.num = 0 なら x = 0 に矛盾。
  refine Quot.induction_on x (fun p => ?_) 
  intro p
  by_cases hp : p.num = 0
  · -- この場合、[p] = 0 になってしまう
    have : Quot.mk _ p = (0 : Q (A:=A) hC) := by
      -- 0 は ⟨(0,1),h10⟩ の同値類
      change Quot.mk _ p = Quot.mk _ ⟨(0,1), h10⟩
      apply Quot.sound
      -- Rel: p.num*1 = 0 * p.den
      unfold FracCarrier.Rel FracCarrier.num FracCarrier.den
      simp [hp, Semiring.one_mul, Semiring.zero_mul]
    exact (hx (by simpa using this)).elim
  · exact ⟨p, rfl, hp⟩

/-- Q(A) は Semifield：0≠1 と「非零に逆」 -/
noncomputable instance : Semifield (Q (A:=A) hC) where
  -- 既に Semiring インスタンスはある
  zero_ne_one := by
    -- 0 ≠ 1 は代表 0/1 と 1/1 が異なることに帰着（h10 を使用）
    -- Rel で等しいと仮定すると 0=1 に矛盾
    intro h01
    -- 0 = 1 なら、その代表が Rel で等しい
    -- (0*1) * (1*1) = (1*1) * (0*1) を見ると 0=1 を強いる
    have : (0 : A) = 1 := by
      -- `Quot.eqv_iff_eq` は使えないので、等しいと仮定したら Rel が成り立つはず
      -- ここは手短に：もし 0=1 なら h10 に反する、という形に変換
      -- 実際には 0=1 を導く代表計算でも OK
      -- 簡略化のために反証法：h10 : 1 ≠ 0
      exact (h10 (by simpa))
    -- 矛盾
    exact (by have := this.symm; simpa using this)
  exists_inv := by
    intro x hx
    -- 非零なら代表 p で p.num ≠ 0 が取れる
    rcases nonzero_num_of_ne_zero (A:=A) hC h10 hx with ⟨p, rfl, hp⟩
    -- 逆は [p.den/p.num]
    refine ⟨
      Quot.mk _ ⟨(p.den, p.num), hp⟩,
      ?goal
    ⟩
    -- 証明： [p]*[p.den/p.num] = 1
    -- 代表計算： (p.num/p.den) * (p.den/p.num) = (p.num*p.den)/(p.den*p.num) ~ 1/1
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p ⟨(p.den, p.num), hp⟩)
        = (1 : Q (A:=A) hC)
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p ⟨(p.den, p.num), hp⟩)
        = Quot.mk _ ⟨(1,1), h10⟩
    apply Quot.sound
    -- Rel の式に落とす
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    -- (p.num*p.den) * (1*1) = (1*p.num) * (p.den*p.num)
    -- 可換結合で `ac_rfl`
    have h1 : (p.num * p.den) * (1 * 1)
            = p.num * p.den := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    have h2 : (1 * p.num) * (p.den * p.num)
            = p.num * p.den * p.num := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    -- 左右とも p.num*p.den*p.num に落ちる
    simpa [h1, h2, Semiring.one_mul,
           mul_comm, mul_left_comm, mul_assoc]

end QSemiring
end TropicalGeometry




#min_imports
