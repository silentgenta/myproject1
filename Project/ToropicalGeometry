/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1ï¼ˆå®‹å…ˆç”Ÿã®å®šç¾©ã«å¿ å®Ÿã«å¾“ã£ãŸ(å¯æ›ãª)Semiringã®å®šç¾©ï¼‰
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

--ã¤ã„ã§ã«åŠä½“ã‚’å®šç¾©
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

--åŠ æ³•çš„å†ªç­‰ã®å®šç¾©
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

--Ex2.1.2 ğ”¹=({0,-âˆ},max,+)ã¯åŠä½“ã§ã‚ã‚‹
inductive ğ”¹ : Type
| negInf
| zero

/-
ã¤ã‘ã¦ãŠãã¨ã„ã„ã“ã¨ãŒã‚ã‚‹ã¨GPTã‹ã‚‰ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Š
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

/- åŠ æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0 : ğ”¹) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- ä¹—æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1 : ğ”¹) (fun _ s => s * a)

--Def2.1.3(åŠç’°æº–åŒå‹ã®å®šç¾©)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--ä»Šå¾ŒãŸã ã®æ§‹é€ ã ã£ã¦Semiringhomomorphismã‚’é–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã„ã¡ã„ã¡f.toFun xã¨æ›¸ã‹ãªãã‚ƒã„ã‘ãªããªã‚‹ã€‚
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

--simpã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--æ’ç­‰æº–åŒå‹ã®å®šç¾©
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--æº–åŒå‹ã®åˆæˆã®å®šç¾©ã€‚åŠç’°æº–åŒå‹ã«å¿…è¦ãªï¼•è¦ç´ ã‚’é †ã«è¨¼æ˜
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgã¯ä¸¡è¾ºã«åŒã˜é–¢æ•°ã‚’é©ç”¨ã—ã¦ã‚ˆã„ã¨ã„ã†è£œé¡Œã€‚f.map_addã®ä¸¡è¾ºã«gã‚’é©ç”¨ã—ãŸã¨ã„ã†ã“ã¨
      _ = g (f a) + g (f b) := by --_ã¯g (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism
--10/9
--Sâ‚ä»£æ•°ã®å®šç¾©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©
--semiringhomoã«ã¯åå‰ã®ã¤ã„ã¦ã„ãªã„é–¢æ•°ãŒã‚ã‚‹ã®ã§ãã‚Œã‚’Î¨ã¨åä»˜ã‘ã‚‹ã€‚

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--Aã¨Bã®é–“ã«å¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’ä¸€ã¤å–ã‚Šå‡ºã™ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚reducibleã«ã™ã‚‹ã“ã¨ã§algeMapã‚’ä½¿ã†ã¨è‡ªå‹•ã§h.homã®ã‚ˆã†ãªå¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’å‘¼ã³å‡ºã—ã¦ãã‚Œã‚‹ã€‚

--simpç”¨
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-ä»£æ•°æº–åŒå‹ã®å®šç¾©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A â†’ X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A â†’ Y
    --åˆæˆã‚’ç¤ºã—ã¦ã„ã‚‹(fã¨toHomã®åˆæˆãŒgã¨ç­‰ã—ããªã‚‹ã€‚)
namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å¯æ›å›³å¼--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)  --Aâ†’X(algebraMap)â†’Y(h.toHom)ã¨ã„ã†å†™åƒã®åˆæˆã«aã‚’é©ç”¨
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g ã« a ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) h.comm
  --congrArgã¯ä¸¡è¾ºã«åŒã˜é–¢æ•°ã‚’é©ç”¨ã™ã‚‹ã¨ãã«ä½¿ã†ã‚³ãƒãƒ³ãƒ‰ã€‚ä»Šå›ã¯ã€Œaã‚’é©ç”¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨è‡ªä½“ãŒé–¢æ•°ã«ãªã£ã¦ã„ã¦ã€ãã‚Œã‚’h.comm(ä¸Šã®AlgHomã®ä¸­ã«ã‚ã‚‹comm)

end AlgHom


--A-ä»£æ•°æº–åŒå‹ã®å­˜åœ¨
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y
  --åå‰ã®è¡çªã‚’é˜²ããŸã‚ã«scopedã‚’ã¤ã‘ã¦ãŠãã€‚ä»Šå¾Œã¯openã€€scoped TGAlgRelã¨æ›¸ãã¨TropicalGeometry.AlgebraRel A X Y ã‚’çœç•¥ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚(åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®å‚ç…§)ã‚‚å¯èƒ½

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--å…·ä½“çš„ãª Î¨ ã¨å¯æ›æ€§(Î¨ ãŒã‚ã£ã¦ã€å¯æ›æ€§ã‚‚è¨¼æ˜ã§ããŸãªã‚‰AlgebraRel A X Yã¯å­˜åœ¨ã—ã¾ã™ã‚ˆã­ã€ã¨ã„ã†è£œé¡Œ)
theorem intro
  (Î¨ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Î¨
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  âŸ¨Î¨, hâŸ©
  --âˆƒ Î¨, P Î¨ã¨ã„ã†å½¢ã®å‘½é¡Œã€‚ã‚ˆã£ã¦ã€âŸ¨ âŸ©ã§å…·ä½“çš„ãªå†™åƒã¨ä»®å®šã‚’ãƒšã‚¢ã§ç¾…åˆ—ã™ã‚‹ã“ã¨ã§å­˜åœ¨ã®è¨¼æ˜ã¯å®Œäº†ã™ã‚‹ã€‚

--ã²ã¨ã¤Î¨ã‚’å–ã‚Šå‡ºã™ã€‚ 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H
--defã¯Hã‹ã‚‰å…·ä½“çš„ãªå†™åƒÎ¨ã‚’å–ã‚Šå‡ºã™æ“ä½œã‚’è¡Œã†ãŸã‚ã®å®šç¾©ã€‚é¸æŠå…¬ç†ã«ä¾å­˜ã—ã¦ã„ã‚‹ã®ã§noncomputableã§å®šç¾©ã™ã‚‹ã€‚ä½¿ã†éš›ã¯Open classicalã«ã™ã‚Œã°ã‚ˆã„ã€‚

--psiHã§å–ã‚Šå‡ºã—ãŸÎ¨ãŒå›³å¼ã‚’å¯æ›ã«ã™ã‚‹ã€‚ 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--å¯æ›æ€§ã®ç‚¹ã”ã¨ver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commã§å¯æ›å›³å¼ã®é–¢æ•°ã®ç­‰å¼ã‚’å–ã‚Šå‡ºã—ã¦congrArgã§aã‚’é©ç”¨ã™ã‚‹ã ã‘
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) hc

end AlgebraRel

-- A-ä»£æ•°åŒå‹ã®å®šç¾©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- äº’ã„ã«é€†ï¼ˆAlgHom ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ toHom ã‚’ä¸€åº¦ã ã‘å–ã‚Šå‡ºã—ã¦ä½¿ã†ï¼‰
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
      --invHom.toHomã¨toHom.toHomã®åˆæˆã§æ’ç­‰å†™åƒã‚’ä½œã‚Šå‡ºã™ã€‚invHomã§AlgIsoã‹ã‚‰AlgHomã‚’å–ã‚Šå‡ºã—ã€toHomã§AlgHomã‹ã‚‰Semiringhomomorphismã‚’å–ã‚Šå‡ºã™æµã‚Œã€‚ï¼ˆAlgHomã«ã‚‚å®šç¾©ãŒã‚ã‚‹ã®ã§ã“ã‚Œã¯å…¥ã‚Œå­æ§‹é€ ï¼‰
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- åŒå‹ã®é †æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- åŒå‹ã®é€†æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv âˆ˜ eã¯identity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idã«xã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism X X) => Ï† x) e.left_inv

--e âˆ˜ e.invã¯identity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idã«yã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism Y Y) => Ï† y) e.right_inv

--å¯¾ç§°æ€§
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--10/17
--ğ”¹ã®å°å…¥
instance : Semiring ğ”¹ where
  mul_zero := by intro a ; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  --<;>ã§ç›´å¾Œã®ã‚¿ã‚¯ãƒ†ã‚£ã‚¯ã‚’å…¨ã¦ã®ã‚´ãƒ¼ãƒ«ã«é©ç”¨ã§ãã‚‹ã€‚
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl


--#check tauto


--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl

--AãŒåŠ æ³•å†ªç­‰ã®ã¨ãï¼Œğ”¹ â†’ Aã§åŠç’°æº–åŒå‹ã¨ãªã‚‹
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ --ã©ã®é–¢æ•°ã‚’å¯¾è±¡ã«ã™ã‚‹ã‹ã‚’æŒ‡å®šã™ã‚‹ã€‚-âˆã‚’0ã«å¯¾å¿œã•ã›ã€0ã‚’-1ã«å¯¾å¿œã•ã›ã‚‹ã€‚
  toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1,

  --F(x + y) = F x + F yã‚’ç¤ºã™ã€‚x,yã®çµ„ã¿åˆã‚ã›ã«ã¯4é€šã‚Šã‚ã‚‹ã®ã§ã€ä»¥ä¸‹ã®4ã¤ã‚’
  map_add := by
    intro x y
    --x,yã§ç·å½“ãŸã‚Šã‚’è¡Œã†ã€‚
    cases x <;> cases y <;> simp
    /-Â· -- F(-âˆ + -âˆ)ï¼š0 = 0 + 0
      exact (zero_add (0 : A)).symm
    Â· -- F(-âˆ + 0)ï¼š1 = 0 + 1
      exact (zero_add (1 : A)).symm
    Â· -- F(0 + -âˆ)ï¼š1 = 1 + 0
      exact (add_zero (1 : A)).symm-/
    Â· -- F(0 + 0)ï¼š1 = 1 + 1ï¼ˆå†ªç­‰æ€§ï¼‰
      exact (h (1 : A)).symm,

  --F(xy) = F(X)F(y)ã‚’ç¤ºã™ã€‚
  map_mul := by
    intro x y
    cases x <;> cases y 
    Â· -- F(-âˆ * -âˆ)ï¼š0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    Â· -- F(-âˆ * 0)ï¼š0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    Â· -- F(0 * -âˆ)ï¼š0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    Â· -- F(0 * 0)ï¼š1 = 1 * 1
      exact (one_mul (1 : A)).symm,

  --ğ”¹ ã§ã¯ 0 : ğ”¹ = ğ”¹.negInfã€ 1 : ğ”¹ = ğ”¹.zero ãŒæ—¢ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§å…¥ã£ã¦ã„ã‚‹.
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 ã€ŒA ãŒåŠ æ³•å†ªç­‰ã€â†”ã€ŒA ãŒ ğ”¹-ä»£æ•°ï¼ˆå­˜åœ¨ã™ã‚‹ï¼‰ã€ -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· -- (â†’) åŠ æ³•å†ªç­‰ â‡’ ğ”¹-ä»£æ•°ãŒå­˜åœ¨
    intro h
    --Algebra.ofHomã¯æº–åŒå‹å†™åƒã‹ã‚‰ğ”¹ä»£æ•°ã®æ§‹é€ ã‚’ä½œã£ã¦ãã‚Œã‚‹ã€‚æº–åŒå‹å†™åƒã¯boolHomOfAddIdemã§æŒ‡å®šã—ã¦ã‚ã’ã‚‹ã€‚
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©

  Â· -- (â†) ğ”¹-ä»£æ•°ãŒå­˜åœ¨ â‡’ åŠ æ³•å†ªç­‰
    intro hAlg
    --nonemptyã®çŠ¶æ…‹ã«å…·ä½“çš„ã«ã©ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚‹ã‹ã‚’ä¸ãˆã¦ã„ã‚‹ã€‚Tactic stateã®instã§æŒ‡å®šã•ã‚Œã¦ã„ã‚‹Semiringã‚’ç”¨ã„ã¦å…·ä½“çš„ã«ä¸€ã¤æŠ½å‡ºã™ã‚‹ã€‚
    rcases hAlg with âŸ¨instâŸ©
    -- Ïˆ : ğ”¹ â†’ Aã‚’æŒ‡å®šã—ã¦ã‚ã’ã‚‹ã€‚Algebraã®classã‚’å‚ç…§ã™ã‚‹ã¨.homãŒã‚ã‚‹ã®ã§ã€instã‚’æŒ‡å®šã—ã¦å†™åƒã‚’å–ã‚Šå‡ºã™ã€‚
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    -- 1_A = 1_A + 1_Aã‚’ä½œã‚‹ã€‚
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)      -- Ïˆ(1+1) = Ïˆ1 + Ïˆ1
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        --B_one_add_oneã§1+1=1ãªã®ã§ã€Î¨(1+1)=Î¨(1)ãŒè¨€ãˆã‚‹ã€‚h0ã‚‚åˆã‚ã›ã‚‹ã“ã¨ã§è¨¼æ˜ãŒå®Œäº†ã™ã‚‹ã€‚
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    -- ä»»æ„ã® a ã«ã¤ã„ã¦ a + a = a
    intro a
    -- a*1 = a*1 + a*1 ã‚’ä½œã‚‹ï¼ˆå·¦åˆ†é…ã¨ h11Aï¼‰
    have hmul : a * 1 = a * 1 + a * 1 := by
      --Semiring.left_distribã§ a*(1+1) = a*1 + a*1 ã«å¯¾ã—ã¦ï¼Œ(1+1) â†’ 1 ã¸æ›¸ãæ›ãˆh11Aã‚’ä¸¡è¾ºå…¥ã‚Œæ›¿ãˆã¦é©ç”¨ã€‚
     simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- ã‚ã¨ã¯ mul_one ã§ä»•ä¸Šã’
    -- ï¼ˆå‘ãã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¯¾ç§°ã‚’å–ã‚‹ï¼‰
    --have : a + a = a := by
    simpa [mul_one] using hmul.symm
    --exact this



--â‰¤â‚ã®å®šç¾©

section OrderFromAddIdem

variable {A : Type u} [Semiring A]

--a â‰¤â‚ bã‚’a + b = bã¨ã™ã‚‹ã€‚
def leA (a b : A) : Prop := a + b = b

--åå°„å¾‹
theorem leA_refl (h : AddIdempotent A) (a : A) : leA a a := by
  unfold leA
  simpa using h a

--æ¨ç§»å¾‹
theorem leA_trans (a b c : A)
    (hab : leA  a b) (hbc : leA  b c) :
    leA  a c := by
  unfold leA at * -- hab hbc âŠ¢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--åå¯¾ç§°å¾‹
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at * -- hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0ã¯æœ€å°å…ƒ
theorem bot_leA (a : A) : leA  (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA  a b) :
    leA  (c * a) (c * b) := by
  unfold leA at * -- hab âŠ¢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

--10/31
universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  âˆ€ â¦ƒa b c : Aâ¦„, a * b = a * c â†’ a = (0 : A) âˆ¨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--ã“ã‚“ã”ä¾¿åˆ©ã«ãªã‚‹è£œé¡Œ
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a â‰  (0 : A)) (hmul : a * b = a * c) : b = c := by
  --a=0ã‹b=cã®ã©ã¡ã‚‰ã‹ã—ã‹ãªã„ã“ã¨ã‚’ç¤ºã™ä»®å®šã‚’å…¥ã‚Œã‚‹ã€‚
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  --h'ã«å ´åˆåˆ†ã‘ã‚’å…¥ã‚Œã‚‹
  rcases h' with hzero | hbc
  --a=0ã®å ´åˆçŸ›ç›¾ãŒèµ·ã“ã‚‹ã®ã§æ’çœŸã§ã‚ã‚‹ã“ã¨ã‚’åˆ©ç”¨ã—ã¦è¨¼æ˜ã‚’å®Œäº†ã•ã›ã‚‹ã€‚haã¨hzeroã«å¯¾ã—ã¦.elimã‚’ç”¨ã„ã¦å®Œäº†ã€‚(False).elimã®å½¢ã§ã‚«ãƒƒã‚³å†…ã®çŸ›ç›¾ã‹ã‚‰ã‚ã‚‰ã‚†ã‚‹å‘½é¡Œã‚’å°ã‘ã‚‹ã€‚
  Â· exact (ha hzero).elim
  --è‡ªæ˜ã€‚
  Â· exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--åˆ†æ¯ãŒ 0 ã§ãªã„çµ„ (a,b)ã®é›†åˆã‚’å®šç¾©ã€‚//ã¯å‰ã«æ›¸ã‹ã‚ŒãŸæƒ…å ±ã«æ¡ä»¶ã‚’ä»˜ã‘åŠ ãˆã‚‹éš›ã«ç”¨ã„ã‚‰ã‚Œã‚‹è¡¨è¨˜æ³•ã€‚ä»Šå›ã¯p(çœç•¥ã•ã‚Œã¦ã„ã‚‹ãŒæ­£ã—ãã¯p.1ï¼‰ã«p.2(p.1ã®äºŒã¤ç›®ã®å…ƒã«å¯¾ã™ã‚‹æ¡ä»¶ãªã®ã§æ­£ç¢ºã«ã¯p.1.2)ã®æ¡ä»¶ã‚’ä»˜ã‘ãã‚ãˆã¦ã„ã‚‹ã€‚
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A Ã— A // p.2 â‰  (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- åˆ†å­
def num (p : FracCarrier A) : A := p.1.1
-- åˆ†æ¯
def den (p : FracCarrier A) : A := p.1.2

/-æ•´ç†ã—ãŸã‚‚ã®ãŒä»¥ä¸‹
p : { p : A Ã— A // p.2 â‰  0 }

p.1        : A Ã— A        -- (a, b)
p.1.1      : A            -- a
p.1.2      : A            -- b
p.2        : p.1.2 â‰  0    
-/

--åˆ†æ•°ã‚’ä½œæˆã—ãŸæ™‚ã«ãã®åˆ†æ¯ã¨åˆ†å­ãŒä½•ã§ã‚ã‚‹ã‹ã‚’å¼•ãå‡ºã™ãŸã‚ã®è£œé¡Œ
--åˆ†å­
@[simp] lemma num_mk (a b : A) (hb : b â‰  0) :
    num (A:=A) âŸ¨(a,b), hbâŸ© = a := rfl
--åˆ†æ¯
@[simp] lemma den_mk (a b : A) (hb : b â‰  0) :
    den (A:=A) âŸ¨(a,b), hbâŸ© = b := rfl

--åˆ†æ•°ã‚’å®šç¾©ã—ãŸæ™‚ã«åˆ†æ¯ãŒï¼ã§ãªã„ã“ã¨ã‚’åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®è£œé¡Œ
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p â‰  0 := p.2

--p=a/b q=x/dã®æ™‚ã€p=qã‚’ad=bcã¨ã„ã†å½¢ã§è¡¨ç¾ã™ã‚‹ãŸã‚ã®å®šç¾©
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--åå°„å¾‹
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--å¯¾ç§°å¾‹
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q p := by
  --h.symmã¯Relã§å±•é–‹ã™ã‚‹ã¨q.num * p.den = p.num * q.denãªã®ã§ã€mulcommã§å…¥ã‚Œæ›¿ãˆã‚Œã°è‰¯ã„ã€‚
  intro h; simpa [Rel, mul_comm] using h.symm

--æ¨ç§»å¾‹
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q r â†’ Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q â‰  (0 : A) := den_ne_zero (A:=A) q

  -- q.den * (p.num * r.den) = r.den * (q.num * p.den)ã‚’ä½œã‚‹
  have h1 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    --(num p * den q) * den r = (num q * den p) * den rã‚’ä½œã‚‹ã€‚
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    grind
    /-calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl --assosiativeã¨commtativeã‚’è²«é€šã™ã‚‹ä¾¿åˆ©ãªrflãŒac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl-/

  -- â‘¡ q.den * (r.num * p.den) = r.den * (q.num * p.den)ã‚’ä½œã‚‹
  have h2 :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    grind
    /-calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl-/

  -- h1ã¨h2ã®å³è¾ºãŒç­‰ã—ã„ã“ã¨ã‚’ç”¨ã„ã¦q.denã‚’æ¶ˆå»ã§ãã‚‹å½¢ã«ã™ã‚‹ã€‚
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1.trans h2.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aã®Relã¯ï¼ˆcancellativeã®ä¸‹ã§ï¼‰åŒå€¤é–¢ä¿‚ã«ãªã‚‹ã€‚  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)  --åŒå€¤ã¨ä¸»å¼µã—ãŸã„é–¢ä¿‚ã‚’æŒ‡å®š
  iseqv :=
    âŸ¨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) âŸ©

/-
structure Setoid (Î± : Sort u) where
  r     : Î± â†’ Î± â†’ Prop
  iseqv : Equivalence rã€€--Equivalenceã¯reflã¨symmã¨transã‚’å«ã‚€æ§‹é€ ãªã®ã§3ã¤ã®å¼•æ•°ã‚’æŒã¤ã€‚

-/

end FracCarrier

open Classical
--11/7
--å•†é›†åˆ Q(A) ã‚’ä½œã‚Šã€è¦ç´ ã‚’a/bã¨æ›¸ã‘ã‚‹ã‚ˆã†ã«ã™ã‚‹ 

section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- Q(A) := {(a,b) | b â‰  0}/âˆ¼ã€€ã™ãªã‚ã¡a/bã‚’ä½œã‚‹ã€‚Quotã¯ã‚ã‚‹å‹Î±ã¨ã€ãã®å‹ã®ä¸Šã®åŒå€¤é–¢ä¿‚rã‚’ä¸ãˆã¦rã§å‰²ã£ãŸå•†é›†åˆã‚’ä½œã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ã€‚å‹ã¯setoidã®äºŒã¤ã®Î±ã§ã€åŒå€¤é–¢ä¿‚ã¯setoidãã®ã‚‚ã®ã€‚
def Q : Type u := Quotient (FracCarrier.setoid (A:=A) hC)
--Quot.{u} {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) : Sort u

-- Q.mk a b hb ã¨æ›¸ãã“ã¨ã§a/b ã®åŒå€¤é¡ãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ãŸã„ã€‚ä¸Šè¨˜ã®Qã¯ãŸã ã®å‹ã®ã¾ã¾ãªã®ã§å…·ä½“çš„ãªå€¤ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒå‡ºæ¥ãªã„ã€‚æ¯å›Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(a,b), hbâŸ©ã¨æ›¸ãã®ã¯é¢å€’ãªã®ã§å®šç¾©ã™ã‚‹ã€‚
def Q.mk (a b : A) (hb : b â‰  0) : Q (A:=A) hC :=
  Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(a,b), hbâŸ©

-- Quot.mk.{u} {Î± : Sort u} (r : Î± â†’ Î± â†’ Prop) (a : Î±) : Quot r


-- åˆ†æ¯ãŒ0ã§ãªã„ã¨ã„ã†æƒ…å ±ã‚’ä½¿ã„ã‚„ã™ãã™ã‚‹ãŸã‚ã«structureã‚’ç”¨æ„ã—ã¦ãŠãã€‚(NonZeroDen)
structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val â‰  0

namespace Q

-- NZDenã§åˆ†æ¯ãŒï¼ã§ãªã„çŠ¶æ…‹ãŒä¿éšœã•ã‚Œã¦ã„ã‚‹å ´åˆã«ãƒšã‚¢(åŒå€¤é¡)ã‚’ä½œã‚‹ãŸã‚ã®å®šç¾©
def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-
Leanã§ã¯æ¼”ç®—ã®å„ªå…ˆé †ä½ã‚’æ•°å€¤ã§å®šç¾©ã—ã¦ã„ã‚‹ã€‚ãŸã ã€æ¼”ç®—ã‚’è‡ªç”±ã«è¿½åŠ ã§ãã‚‹ã‚ˆã†ã«ä½™è£•ã‚’ã‚‚ã£ã¦æ•°å€¤ã¯å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
ä¾‹ã‚’æŒ™ã’ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚
ã¹ãä¹—ï¼šï¼˜ï¼
æ›ã‘ç®—å‰²ã‚Šç®—ï¼šï¼—ï¼
è¶³ã—ç®—å¼•ãç®—ï¼šï¼–ï¼•
ã‚¤ã‚³ãƒ¼ãƒ«ã€‚å¤§ãªã‚Šå°ãªã‚Šï¼šï¼•ï¼
ã‚ã‚‹æ¼”ç®—å­ã‚’å®šã‚ãŸã¨ãã«ã¯ä¸€ç•ªå³ã«è¨˜å…¥ã•ã‚ŒãŸæ•°å€¤ãŒãã®æ¼”ç®—ã®å„ªå…ˆé †ä½ã¨ãªã‚‹ã€‚ä»¥ä¸‹ã®notationã§ã¯ï¼—ï¼‘ãŒæ¼”ç®—ã®å„ªå…ˆé †ä½ã¨ãªã‚‹ã€‚71ã«ã—ãŸã®ã¯åˆ†å­ã¯å‰ã«ã¤ã„ãŸæ›xã‘ç®—ã‚’å·»ãè¾¼ã‚“ã§ã»ã—ã„ãŒã€åˆ†æ¯ã¯å¾Œã‚ã«ã¤ã„ãŸæ›ã‘ç®—ã‚’å·»ãè¾¼ã‚€ã¨äº‹æ•…ç™ºç”Ÿã«ãªã‚‹ãŸã‚ã€‚
æ¼”ç®—ã®å„ªå…ˆåº¦ã‚’71ã«ã™ã‚‹ã“ã¨ã§/ã¯
+ï¼ˆ65ï¼‰ã‚ˆã‚Šå¼·ã„ â†’ a / b + c ã¯ (a / b) + c ã¨èª­ã¾ã‚Œã‚‹
*ï¼ˆ70ï¼‰ã‚ˆã‚Šå°‘ã—å¼·ã„ â†’ a / b * c ã¯ (a / b) * c ã¨èª­ã¾ã‚Œã‚‹
^ï¼ˆ80ï¼‰ã‚ˆã‚Šå¼±ã„ â†’ a^2 / b ã¯ (a^2) / b ã¨èª­ã¾ã‚Œã‚‹
ã¨ãªã‚‹ã€‚
ä»¥ä¸‹ã‚½ãƒ¼ã‚¹
https://leanprover-community.github.io/lt2021/slides/sebastian-lean4-parsers-macros.pdf?utm_source=chatgpt.com
-/

-- ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…é™å®šã®åˆ†æ•°è¡¨ç¤ºã®å°å…¥ã€‚ a / b : Q(A,hC) ï¼ˆb : NZDen Aï¼‰ _/_
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

-- open scoped TGFracã¨æ›¸ã‘ã°ã©ã“ã§ã‚‚ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼ša /[hC] b ï¼ˆb : NZDen Aï¼‰ 
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic

open Classical

section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

namespace FracCarrier

-- åˆ†æ¯åŒå£«ã®ç©ã¯ 0 ã«ãªã‚‰ãªã„ã“ã¨ã‚’ç¤ºã™è£œé¡Œã€‚ï¼ˆCancellative ã‚’åˆ©ç”¨ï¼‰
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den â‰  0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 ã‹ã‚‰ p.den * q.den = p.den * 0 ã‚’å¾—ã‚‹
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _ --_ã¯p.den
    exact h.trans hz.symm
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

-- (a/b) + (c/d) := (ad + cb) / (bd)  FracCarrierã¯ãƒšã‚¢ãªã®ã§ã€âŸ¨(åˆ†æ¯,åˆ†å­),åˆ¶ç´„æ¡ä»¶(åˆ†æ¯ã¯ï¼ã˜ã‚ƒãªã„)âŸ© ã¨ã„ã†æ–‡ä¿ã«ãªã‚‹ã€‚
def addRep (hC : Cancellative A) (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

-- (a/b) * (c/d) := (ac) / (bd) 
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

-- åŠ æ³•ã®well-definedæ€§ 
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
      -- ç›®æ¨™ã¯(p.num*q.den + q.num*p.den)*(p'.den*q'.den) = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  unfold Rel addRep
  have Hâ‚€ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by --åˆ†é…æ³•å‰‡ã®é©ç”¨
            simpa using Hâ‚€
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by --æ›ã‘ç®—ã®é †ç•ªå…¥ã‚Œæ›¿ãˆ
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl --assocã¨commã‚’é©ç”¨ã—ãŸã†ãˆã§ã®rfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by --å„æ‹¬å¼§ã®ä¸­ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by --p.den * d.denã§æ‹¬ã‚Šã ã—
            have Hâ‚ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            simpa [mul_comm, mul_left_comm, mul_assoc] using Hâ‚.symm

-- ä¹—æ³•ã®well-definedæ€§ 
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
      -- ç›®æ¨™ã¯ (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den) (Rel)
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

--11/14
-- Q(A) ä¸Šã®åŠ æ³•

/-
Quot.lift :                      
  (F : Î± â†’ Î²) â†’                  -- é–¢æ•° F
  (âˆ€{x y}, r x y â†’ F x = F y) â†’  -- rãŒåŒå€¤ãªã‚‰ F ã®å€¤ã‚‚ç­‰ã—ã„ï¼ˆwell-definedã®è¨¼æ˜å¿…è¦ï¼‰
  Quot r â†’ Î²                     -- å•† Quot r ã‹ã‚‰ Î² ã¸ã®é–¢æ•°ã‚’å¾—ã‚‹
-/

noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let addCoreâ‚ :
      --ä»¥ä¸‹ã®FracCarrier Aã¯1ã¤ç›®ã®å¼•æ•°ã€ã¤ã¾ã‚Špã®ã“ã¨ã§ã‚ã‚‹ã€‚ã™ãªã‚ã¡ã€pã‚’å›ºå®šã—ãŸã†ãˆã§ã®qã®Q(A)â†’Q(A)ã¨ã„ã†æ¼”ç®—ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    --fun p => Quot.liftãŒä¸Šã®FracCarrier Aâ†’ Q(A)ã«å¯¾å¿œã€‚
    fun p =>
      --Quot.liftã®ä¸­ã®fun q => Quot.mkãŒQ(A)â†’Q(A)ã«å¯¾å¿œã€‚
      --é–¢æ•°ï¼¦ã¨åŒå€¤ï½ã«ã¤ã„ã¦ã€aï½b â†’ F(a)=F(b)ãŒæˆã‚Šç«‹ã¤ãªã‚‰ã€F(c)=F([c])ãŒæˆã‚Šç«‹ã¤ã¨ã„ã†ã®ãŒQuot.lift
      Quot.lift
         --qãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰æ—¢ã«å­˜åœ¨ã™ã‚‹pã‚’æŒã£ã¦ãã¦addrepã§è¶³ã—ç®—ã—ãŸå¾Œã«setoidã§åŒå€¤é¡ã«ã™ã‚‹ã€‚
         --ã™ãªã‚ã¡ã€ ä»¥ä¸‹ã®funãŒã‚„ã£ã¦ã„ã‚‹ã“ã¨ã¯ q â†’ [p + q]ã§ã‚ã‚‹ã€‚
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' ã®ã¨ãwell-definedã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã€‚
          intro q q' hq
          --aã¨bãŒé–¢ä¿‚rã§åŒå€¤ãªã‚‰ã°ã€åŒå€¤é¡ã¨ã—ã¦ã¯ã‚¤ã‚³ãƒ¼ãƒ«ã®é–¢ä¿‚ã«ãªã‚‹ã€‚
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let addCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      --ä»Šå›å†™åƒã¯FracCarrierã‹ã‚‰pã‚’å–ã‚ŒãŸæ™‚ç‚¹ã§ã‚ã¨ã¯addcoreâ‚ã«ã™ã¹ã¦ä»»ã›ã‚Œã°ã‚ˆã„ã€‚
      (fun p => addCoreâ‚ p)
      (by
        -- p ~ p' ãªã‚‰ã€é–¢æ•° addCoreâ‚ p = addCoreâ‚ p'ã‚’ç¤ºã™ã€‚
        intro p p' hp
        apply funext
        intro y
        -- yãŒå•†ã®å…ƒãªã®ã§ä»£è¡¨ã«æˆ»ã—ã¦ã‚ã’ã‚‹
        refine Quot.induction_on y ?_
        intro q
        -- ç›®æ¨™ã‚’æ›¸ãæ›ãˆã‚‹addcoreâ‚p [q]ï¼[p+q]ãªã®ã§ã€æ¬¡ã®2ã¤ã®mkã®ç­‰ã—ã•ã‚’ç¤ºã›ã°ã‚ˆã„
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- ä»¥ä¸Šã‚’ä½¿ã£ã¦ x, y ã«é©ç”¨
  exact addCoreâ‚‚ x y


-- Q(A) ä¸Šã®ä¹—æ³• 
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCoreâ‚ :
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCoreâ‚ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCoreâ‚‚ x y

namespace Q

variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

--[p]+[q]=[p+q]
@[simp] lemma add_mk (p q : FracCarrier A) :
  Q.add (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.addRep (A:=A) hC p q) := rfl

--[p][q]=[pq]
@[simp] lemma mul_mk (p q : FracCarrier A) :
  Q.mul (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.mulRep (A:=A) hC p q) := rfl

end Q


end QAddMul


open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  --1â‰ 0 

--Q(a)ã®0ã‚’0/1ã¨å®šç¾©ã€‚(åˆ†æ¯ãŒï¼ã§ãªã„è¨¼æ˜ä»˜ãã§)
def Q.zero : Q (A:=A) hC :=
  Q.mk (A:=A) hC 0 1 (by simp[NeZero.ne (1 : A)])

--Q(a)ã®1ã‚’1/1ã¨å®šç¾©ã€‚(åˆ†æ¯ãŒï¼ã§ãªã„è¨¼æ˜ä»˜ãã§)
def Q.one  : Q (A:=A) hC :=
  Q.mk (A:=A) hC 1 1 (by simp[NeZero.ne (1 : A)])

--Q(A)ã®0ã¨1ã‚’ä½¿ã„ãŸã„éš›ã«ãƒã‚°ãŒå‡ºã‚„ã™ã„ã®ã§instanceã¨ã—ã¦è¿½åŠ 
instance : Zero (Q (A:=A) hC) := âŸ¨Q.zero (A:=A) hCâŸ©
instance : One  (Q (A:=A) hC) := âŸ¨Q.one  (A:=A) hCâŸ©

--OfNat A nã¯nã‚’Aã®è¦ç´ ã¨ã—ã¦èª­ã¿ãªã•ã„ã¨ã„ã†æŒ‡ç¤ºã‚’ä¸ãˆã‚‹instance
--(0 : ...)ã‚„(1 : ...)ãƒã‚°ãŒç™ºç”Ÿã—ã‚„ã™ã„ã®ã§ãã‚Œã‚’å›é¿ã™ã‚‹ãŸã‚ã€‚
--ZeroãŒå­˜åœ¨ã™ã‚‹ã®ã§ã€Q(A)ã®ï¼ã‚’zeroã§å‘¼ã³å‡ºã™ã¨ã„ã†å†…å®¹ã‚’ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã¯è¿°ã¹ã¦ã„ã‚‹ã€‚
noncomputable instance instOfNat0Q :
    OfNat (Q (A:=A) hC) 0 where
  ofNat := (Zero.zero : Q (A:=A) hC)

noncomputable instance instOfNat1Q :
    OfNat (Q (A:=A) hC) 1 where
  ofNat := (One.one : Q (A:=A) hC)

noncomputable instance : Add  (Q (A:=A) hC) := âŸ¨Q.add (A:=A) hCâŸ©
noncomputable instance : Mul  (Q (A:=A) hC) := âŸ¨Q.mul (A:=A) hCâŸ©
end QSemiring

--11/21
namespace FracCarrier

variable {hC}
variable {A : Type u} [Semiring A]

-- åŠ æ³•ã®å¯æ›æ€§ã€‚åˆ†æ•°ã®ã‚¤ã‚³ãƒ¼ãƒ«ã¯Relã‚’ã—ã‚ã›ã°ã‚ˆã„ã€‚
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  unfold Rel addRep num den
  -- ç›®æ¨™ã¯
  --(p.num*q.den + q.num*p.den) * (q.den*p.den) = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          ac_rfl

-- åŠ æ³•ã®çµåˆæ€§
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  unfold Rel addRep
  --è¦‹é€šã—ã‚’ã‚ˆãã—ãŸã„ã®ã§å³åŠ¹æ€§ã®ã‚ã‚‹set
  set a := p.num 
  set b := p.den
  set c := q.num
  set d := q.den
  set e := r.num
  set f := r.den
  --ä½¿ã„ã©ã“ã‚ã‚’é¸ã‚“ã§é©ç”¨ã—ãŸã„ã®ã§let
  let kâ‚ := b * (d * f)
  let kâ‚‚ := (b * d) * f
  --è¨¼æ˜ã®æœ¬é¡Œ
  --å·¦è¾ºã«ã¤ã„ã¦
  --kâ‚ã®åˆ†é…
  have HL1 :
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = ((a*d + c*b) * f) * kâ‚ + (e * (b*d)) * kâ‚ := by
    simpa using
      (Semiring.right_distrib (R:=A) ((a*d + c*b) * f) (e * (b*d)) kâ‚)

  --åˆ†é…æ¸¬ ((a*d + c*b) * f) * kâ‚ = (a*d)*(f*kâ‚) + (c*b)*(f*kâ‚)
  have HL2 :
      ((a*d + c*b) * f) * kâ‚
        = (a*d) * (f * kâ‚) + (c*b) * (f * kâ‚) := by
    have := Semiring.right_distrib (R:=A) (a*d) (c*b) (f * kâ‚)
    --mul_assocã§((x+y)*f)*kâ‚ = (x+y)*(f*kâ‚) ã®å½¢ã¸çµåˆå‰‡ã§ä¸¦ã³æ›¿ãˆã¦ã‹ã‚‰simpã‚’é©ç”¨
    simpa [mul_assoc] using this

  --HL1ã¨HL2ã‚’çµ±åˆ
  have HL :
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := by
    calc
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
          = ((a*d + c*b) * f) * kâ‚ + (e * (b*d)) * kâ‚ := HL1
      _ = ((a*d) * (f * kâ‚) + (c*b) * (f * kâ‚)) + (e * (b*d)) * kâ‚ := by
            simp [HL2]
      _ = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := by
            simp [mul_assoc]
  --å³è¾ºã«ã¤ã„ã¦
  --kâ‚‚ã®åˆ†é…
  have HR1 :
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
        = (a * (d*f)) * kâ‚‚ + ((c*f + e*d) * b) * kâ‚‚ := by
    simpa using
      (Semiring.right_distrib (R:=A) (a * (d*f)) ((c*f + e*d) * b) kâ‚‚)

  --åˆ†é…æ¸¬((c*f + e*d) * b) * kâ‚‚ = (c*f)*(b*kâ‚‚) + (e*d)*(b*kâ‚‚)
  have HR2 :
      ((c*f + e*d) * b) * kâ‚‚
        = (c*f) * (b * kâ‚‚) + (e*d) * (b * kâ‚‚) := by
    have := Semiring.right_distrib (R:=A) (c*f) (e*d) (b * kâ‚‚)
    simpa [mul_assoc] using this

  --HR1ã¨HR2ã‚’çµ±åˆ
  have HR :
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
        = a * (d*f) * kâ‚‚ + (c*f) * b * kâ‚‚ + (e*d) * b * kâ‚‚ := by
    calc
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
          = (a * (d*f)) * kâ‚‚ + ((c*f + e*d) * b) * kâ‚‚ := HR1
      _ = (a * (d*f)) * kâ‚‚ + ((c*f) * (b * kâ‚‚) + (e*d) * (b * kâ‚‚)) := by
            simp [HR2]
      _ = a * (d*f) * kâ‚‚ + (c*f) * b * kâ‚‚ + (e*d) * b * kâ‚‚ := by
            simp [mul_assoc, add_assoc]

  -- kâ‚ ã¨ kâ‚‚ ã¯çµåˆæ¸¬ãŒæˆã‚Šç«‹ã¤ã¨ãã‚¤ã‚³ãƒ¼ãƒ«ã¨ãªã‚‹
  have k_same : kâ‚ = kâ‚‚ := by
    simp [kâ‚, kâ‚‚, mul_assoc]

  -- 3é …ã®å’Œã®ä¸¦ã³æ›¿ãˆï¼ˆæ‹¬å¼§ã®ä»˜ã‘æ›¿ãˆã‚’å«ã‚€ï¼‰
  have align :
      a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚
        = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := by 
        simp [k_same, mul_assoc, mul_comm, mul_left_comm]

  -- ã¾ã¨ã‚
  calc
    ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := HL
    _   = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := align
    _   = (a * (d*f) + (c*f + e*d) * b) * kâ‚‚ := HR.symm


-- ä¹—æ³•ã®å¯æ›æ€§
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  simp [mul_comm,  mul_assoc]

-- ä¹—æ³•ã®çµåˆæ€§
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  simp [mul_comm,  mul_assoc]

-- å·¦åˆ†é…å‰‡(p(q+r)=pq+pr)
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- ã¾ãš p,q,r ã®ä¸­èº«ã‚’åˆ†æ¯ã€åˆ†å­ã€åˆ†æ¯â‰ 0æ¡ä»¶ã®3ã¤ã«ãƒãƒ©ã™
  rcases p with âŸ¨âŸ¨pn, pdâŸ©, hp0âŸ©
  rcases q with âŸ¨âŸ¨qn, qdâŸ©, hq0âŸ©
  rcases r with âŸ¨âŸ¨rn, rdâŸ©, hr0âŸ©

  unfold Rel addRep mulRep
  --ä¾‹ãˆã°num(pn,pd)ã¯pnã®ã“ã¨ã§ã‚ã‚‹ã€‚simpã§è¦‹ã‚„ã™ãã™ã‚‹ã€‚
  simp [FracCarrier.num, FracCarrier.den]

  -- ã¾ãšåˆ†æ¯ã®ç©ã«åå‰ä»˜ã‘ã—ã¦ãŠã
  set X : A := pd * qd * (pd * rd) with hX
  set Y : A := pd * (qd * rd) with hY

  -- (1) å·¦è¾ºã‚’ pn * (qn*rd + rn*qd) * X ã¨ã„ã†å½¢ã«ã™ã‚‹
  have lhs_reassoc :
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
        =
      pn * (qn * rd + rn * qd) * X := by
    --(pd * (qd * (pd * rd))) ã‚’ assoc ã§ (pd * qd) * (pd * rd) å‹ã«ã™ã‚‹
    have tail_assoc :
        pd * (qd * (pd * rd))
          = pd * qd * (pd * rd) := by
      -- (pd * (qd * Z)) = (pd * qd) * Zã‚’mul_assocã§è§£æ±ºã™ã‚‹
      simp [mul_assoc]
    calc
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
          = pn * ((qn * rd + rn * qd) * (pd * qd * (pd * rd))) := by
              simp [tail_assoc]
      _   = pn * (qn * rd + rn * qd) * (pd * qd * (pd * rd)) := by
              simp [mul_assoc]
      _   = pn * (qn * rd + rn * qd) * X := by
              simp [hX]

  have left_expand :
      pn * (qn * rd + rn * qd) * X = pn * (qn * rd) * X + pn * (rn * qd) * X := by
    -- ã¾ãš (qn*rd + rn*qd) * X ã®å³åˆ†é…ã‚’ç¤ºã™
    have inner :
        (qn * rd + rn * qd) * X = (qn * rd) * X + (rn * qd) * X := by
      have tmp :=
        Semiring.right_distrib (R:=A) (qn * rd) (rn * qd) X
      simpa using tmp
    -- æ¬¡ã«pn * ((qn * rd) * X + (rn * qd) * X)ã®å·¦åˆ†é…ã‚’ç¤ºã™
    have tmp2 :=
      Semiring.left_distrib (R:=A) pn ((qn * rd) * X) ((rn * qd) * X)
    simpa [inner, mul_assoc] using tmp2

  --Yã®å³åˆ†é…æ¸¬
  have right_expand :
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y
        = pn * qn * (pd * rd) * Y + pn * rn * (pd * qd) * Y := by
    have tmp :=
      Semiring.right_distrib (R:=A) (pn * qn * (pd * rd)) (pn * rn * (pd * qd)) Y
    simpa [mul_assoc] using tmp

  have term1_match :
      pn * (qn * rd) * X = pn * qn * (pd * rd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  have term2_match :
      pn * (rn * qd) * X = pn * rn * (pd * qd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  have rhs_reassoc :
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
        =
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
    calc
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
          =
        ((pn * qn * (pd * rd)) + (pn * rn * (pd * qd)))
          * (pd * (qd * rd)) := by
            simp [mul_assoc]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
            simp [hY]

  have mid_chain :
      pn * (qn * rd + rn * qd) * X
        =
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := by
    calc
      pn * (qn * rd + rn * qd) * X
          =
        pn * (qn * rd) * X + pn * (rn * qd) * X := left_expand
      _ =
        pn * qn * (pd * rd) * Y
        + pn * rn * (pd * qd) * Y := by
          simp [term1_match, term2_match]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y :=
          (right_expand.symm)
      _ =
        (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := rhs_reassoc.symm

  grind
  --exact lhs_reassoc.trans mid_chain

-- å³åˆ†é…å‰‡
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by

  rcases p with âŸ¨âŸ¨pn, pdâŸ©, hp0âŸ©
  rcases q with âŸ¨âŸ¨qn, qdâŸ©, hq0âŸ©
  rcases r with âŸ¨âŸ¨rn, rdâŸ©, hr0âŸ©

  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  set X : A := (pd * rd) * (qd * rd) with hX
  set Y : A := (pd * qd) * rd with hY

  have lhs_reassoc :
      ((pn * qd + qn * pd) * rn) * X
        =
      (pn * qd + qn * pd) * rn * X := by
    simp [X, mul_assoc]

  have left_expand :
      (pn * qd + qn * pd) * rn * X
        =
      (pn * qd) * rn * X + (qn * pd) * rn * X := by
    have step1 :
        (pn * qd + qn * pd) * rn
          =
        (pn * qd) * rn + (qn * pd) * rn := by
      simpa using
        Semiring.right_distrib (R:=A) (pn * qd) (qn * pd) rn
    calc
      (pn * qd + qn * pd) * rn * X
          = ((pn * qd) * rn + (qn * pd) * rn) * X := by
              simp [step1]
      _   = (pn * qd) * rn * X + (qn * pd) * rn * X := by
              simpa [mul_assoc] using
                Semiring.right_distrib (R:=A)
                  ((pn * qd) * rn) ((qn * pd) * rn) X

  have right_expand :
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y
        =
      (pn * rn) * (qd * rd) * Y + (qn * rn) * (pd * rd) * Y := by
    simpa [mul_assoc] using
      Semiring.right_distrib (R:=A)
        ((pn * rn) * (qd * rd)) ((qn * rn) * (pd * rd)) Y

  have term1_match :
      (pn * qd) * rn * X
        =
      (pn * rn) * (qd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  have term2_match :
      (qn * pd) * rn * X
        =
      (qn * rn) * (pd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  have mid_chain :
      (pn * qd + qn * pd) * rn * X
        =
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
    calc
      (pn * qd + qn * pd) * rn * X
          = (pn * qd) * rn * X + (qn * pd) * rn * X := left_expand
      _   = (pn * rn) * (qd * rd) * Y
            + (qn * rn) * (pd * rd) * Y := by
              simp [term1_match, term2_match]
      _   = ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
              simpa [mul_assoc] using right_expand.symm
  grind
  --exact lhs_reassoc.trans mid_chain



end FracCarrier

--11/28

-- Q(A)ã¯å¯æ›ãªåŠ æ³•ãƒ¢ãƒã‚¤ãƒ‰ã§ã‚ã‚‹
section
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

noncomputable instance instAddCommMonoidQ :
    AddCommMonoid (Q (A:=A) hC) where
  add  := (Â· + Â·)
  zero := (0 : Q (A:=A) hC)

  add_assoc := by
    intro x y z 
    refine Quot.induction_on x ?_ --inductionã§ä»£è¡¨å…ƒã«ã¤ã„ã¦ã®è­°è«–ã«æŒã¡è¾¼ã‚€
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.addRep_assoc (A:=A) hC p q r

  zero_add := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    -- ç›®æ¨™ã‚’Q.addã§è¨˜è¿°ã•ã‚ŒãŸå½¢ã«ã™ã‚‹ã€‚
    change
      Q.add (A:=A) hC (Q.zero (A:=A) hC) (Quot.mk _ p)
        = Quot.mk _ p
    -- å·¦è¾ºã®Q.zeroã‚’å…·ä½“çš„ãª0/1ã«å¤‰æ›´
    simp [Q.zero]  
    apply Quot.sound
    -- setoid ã®é–¢ä¿‚ã‚’FracCarrier.Relã®å…·ä½“çš„ãªå½¢ã€ã™ãªã‚ã¡(0/1) + p ~ pã«å¤‰ãˆã‚‹
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC âŸ¨(0,1), by
          simp[NeZero.ne (1 : A)]âŸ© p)
        p
    -- å±•é–‹ã—ã¦simpã§é–‰ã˜ã‚‹
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm, Semiring.mul_zero]

  add_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Q.add (A:=A) hC (Quot.mk _ p) (Q.zero (A:=A) hC)
        = Quot.mk _ p
    simp [Q.zero]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC p âŸ¨(0,1), by
          simp[NeZero.ne (1 : A)]âŸ©)
        p
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm,Semiring.mul_zero]


  add_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q

  -- è‡ªç„¶æ•°å€ã®å®šç¾©
  nsmul := fun n x => Nat.recOn n (0 : Q (A:=A) hC) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

end




--Q(A)ã¯å¯æ›ãªä¹—æ³•ãƒ¢ãƒã‚¤ãƒ‰ã§ã‚ã‚‹
section QCommMonoid
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  

noncomputable instance : CommMonoid (Q (A:=A) hC) where
  mul := (Â· * Â·)
  one := (1 : Q (A:=A) hC)

  mul_assoc := by --FracCarrierã®ç©ã®è©±ã«æŒã¡è¾¼ã‚ã°mulRep_assocã§å®Œäº†ã™ã‚‹ã€‚
    intro x y z
    refine Quot.induction_on x ?_ 
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.mulRep_assoc (A:=A) hC p q r

  one_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
     Quot.mk (FracCarrier.setoid (A:=A) hC)
          (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), by simp[NeZero.ne (1 : A)]âŸ© p)
     =
     Quot.mk (FracCarrier.setoid (A:=A) hC) p
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), by
          simp[NeZero.ne (1 : A)]âŸ© p) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp 

  mul_one := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), by
        simp[NeZero.ne (1 : A)]âŸ©) = Quot.mk _ p
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), by
          simp[NeZero.ne (1 : A)]âŸ©) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp

  mul_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q

  npow := fun n x =>
    Nat.recOn n (1 : Q (A:=A) hC) (fun _ s => s * x)

end QCommMonoid

--Q(A)ã¯åŠç’°ã§ã‚ã‚‹
section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  

noncomputable instance : Semiring (Q (A:=A) hC) :=
{ (inferInstance : AddCommMonoid (Q (A:=A) hC)),
  (inferInstance : CommMonoid     (Q (A:=A) hC)) with
  mul_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), h10âŸ©)
        = Quot.mk _ âŸ¨(0, 1), h10âŸ©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), h10âŸ©)
        âŸ¨(0, 1), h10âŸ©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp  
    have hR : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hL : a * (0 : A) = 0 := TropicalGeometry.Semiring.mul_zero (R:=A) a
    simp [hL, hR]

  zero_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(0, 1), h10âŸ© âŸ¨(a, b), hbâŸ©)
        = Quot.mk _ âŸ¨(0, 1), h10âŸ©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(0, 1), h10âŸ© âŸ¨(a, b), hbâŸ©)
        âŸ¨(0, 1), h10âŸ©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp
    have hL : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hR : (0 : A) * a = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) a
    simp [hL, hR]

  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r

  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r
}
end QSemiring

namespace FracCarrier

--[a/b] = 0 â†” a = 0 ã€‚ 
lemma zero_iff_num_eq_zero
    {A : Type u} [TropicalGeometry.Semiring A]
     (h10 : (1 : A) â‰  0)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p âŸ¨(0, 1), h10âŸ© â†” p.num = 0 := by
  rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
  constructor
  Â· intro h
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at h
    have hz : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    have h1 : a * (1 : A) = 0 := by
      rw [hz] at h
      exact h
    have hm : a * (1 : A) = a := mul_one a
    rw [hm] at h1
    exact h1

  Â· intro hnum
    dsimp [FracCarrier.num] at hnum
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
    rw [hnum]
    have hL : (0 : A) * (1 : A) = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) (1 : A)
    have hR : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    rw [hL, hR]

end FracCarrier


open Classical

-- éé›¶å…ƒã¯åˆ†å­ãŒéé›¶ãªä»£è¡¨ã‚’æŒã¤ 
lemma nonzero_num_of_ne_zero
    {A : Type u} [TropicalGeometry.Semiring A]
    (hC : Cancellative A) [NeZero (1 : A)]
    {x : Q (A:=A) hC} (hx : x â‰  (0 : Q (A:=A) hC)) :
    âˆƒ p : FracCarrier A, Quot.mk _ p = x âˆ§ p.num â‰  0 := by
  rcases Quot.exists_rep x with âŸ¨p, rflâŸ© --hxã®ä»£ã‚ã‚Šã«rflã¨ã‹ãã¨rflã‚’é©ç”¨ã—ã¦ãã‚Œã‚‹ä¾¿åˆ©ãªè¨˜æ³•
  by_cases hpn : p.num = 0
  Â· rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    have ha : a = 0 := by
      dsimp [FracCarrier.num] at hpn
      exact hpn
    have hRel :
        (FracCarrier.setoid (A:=A) hC).r
          âŸ¨(a, b), hbâŸ©
          âŸ¨(0, 1), (NeZero.ne (1 : A))âŸ© := by
      change FracCarrier.Rel (A:=A)
               âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), NeZero.ne (1 : A)âŸ©
      dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
      rw [ha]
      simp [TropicalGeometry.Semiring.zero_mul]
    have hEq : (Quot.mk _ âŸ¨(a, b), hbâŸ© : Q (A:=A) hC)
             = (0 : Q (A:=A) hC) := Quot.sound hRel
    exact (hx hEq).elim
  Â· exact âŸ¨p, rfl, hpnâŸ©


variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

-- Q(A) ã¯ Semifield
noncomputable instance : Semifield (Q (A:=A) hC) :=
{ (inferInstance : Semiring (Q (A:=A) hC)) with

  -- 0 â‰  1
  zero_ne_one := by
    intro h01
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    have h01' :
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨((0 : A), (1 : A)), h10âŸ©
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨((1 : A), (1 : A)), h10âŸ© := by
      simpa [Q.zero, Q.one] using h01

    have hRel :
        FracCarrier.Rel (A:=A)
          âŸ¨((0 : A), (1 : A)), h10âŸ©
          âŸ¨((1 : A), (1 : A)), h10âŸ© :=
      Quotient.exact h01'
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at hRel
    have : (0 : A) = 1 := by
      simp at hRel
    exact h10 this.symm

  exists_inv := by
    intro x hx
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    rcases nonzero_num_of_ne_zero (A:=A) (hC:=hC) hx with âŸ¨p, rfl, hpâŸ©
    --é€†å…ƒã®å€™è£œã‚’p.den/p.numã«ã™ã‚‹ã€‚ãã®å ´åˆã€?_ã®(p.den/p.num)*(p.num/p.den)=1ãŒã‚´ãƒ¼ãƒ«ã¨ãªã‚‹
    refine âŸ¨
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(p.den, p.num), hpâŸ©,
      ?_âŸ©
    -- [p] * [p.den/p.num] = 1 ã‚’ç¤ºã™
    change
      Quot.mk (FracCarrier.setoid (A:=A) hC)
        (FracCarrier.mulRep (A:=A) hC p âŸ¨(p.den, p.num), hpâŸ©)
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨((1 : A), (1 : A)), h10âŸ©
    apply Quotient.sound
    change (p.num * p.den) * (1 : A) = (1 : A) * (p.den * p.num)
    simp[mul_comm]
}


--12/5

-- A ã®å…ƒ a ã‚’æ—¢ç´„åˆ†æ•° a/1 ã«åŸ‹ã‚è¾¼ã‚€å†™åƒ f : A â†’ Q(A)ãŒå˜å°„ã§ã‹ã¤åŠç’°æº–åŒå‹
section

variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) [NeZero (1 : A)]

-- è‡ªç„¶ãªåŸ‹ã‚è¾¼ã¿ f : A â†’ Q(A)ï¼ˆa â†¦ a/1ï¼‰ 
noncomputable def Emb : A â†’ Q (A:=A) hC :=
  fun a => Q.mk (A:=A) hC a 1 (by simp[NeZero.ne (1 : A)])

@[simp] lemma Emb_apply (a : A) :
    Emb (A:=A) hC a
      = Q.mk (A:=A) hC a 1 (by simp[NeZero.ne (1 : A)]) := rfl

lemma Emb_injective : Function.Injective (Emb (A:=A) hC) := by
  intro a b h
  have hmk :
      Quot.mk (FracCarrier.setoid (A:=A) hC)
              âŸ¨(a, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ©
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC)
              âŸ¨(b, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ© := by
    simpa [Emb, Emb_apply] using h
  have hRel :
      FracCarrier.Rel (A:=A)
        âŸ¨(a, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ©
        âŸ¨(b, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ© :=
    Quotient.exact hmk
  dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at hRel
  simpa [mul_one] using hRel

noncomputable def EmbHom :
    SemiringHomomorphism A (Q (A:=A) hC) :=
{ toFun := Emb (A:=A) hC

  map_add := by
    intro a b
    have h10 : (1 : A) â‰  0 := NeZero.ne (1 : A)
    simp [Emb]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        âŸ¨(a + b, 1), h10âŸ©
        (FracCarrier.addRep (A:=A) hC âŸ¨(a, 1), h10âŸ© âŸ¨(b, 1), h10âŸ©)
    unfold FracCarrier.Rel FracCarrier.addRep
           FracCarrier.num FracCarrier.den
    simp [mul_one]

  map_mul := by
    intro a b
    have h10 : (1 : A) â‰  0 := NeZero.ne (1 : A)
    simp [Emb]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        âŸ¨(a * b, 1), h10âŸ©
        (FracCarrier.mulRep (A:=A) hC âŸ¨(a, 1), h10âŸ© âŸ¨(b, 1), h10âŸ©)
    unfold FracCarrier.Rel FracCarrier.mulRep
           FracCarrier.num FracCarrier.den
    simp [mul_one]

  map_zero := by
    change Emb (A:=A) hC 0 = TropicalGeometry.Q.zero (A:=A) hC
    simp [Emb, TropicalGeometry.Q.zero]

  map_one := by
    change Emb (A:=A) hC 1 = TropicalGeometry.Q.one (A:=A) hC
    simp [Emb, TropicalGeometry.Q.one]
}


--12/12?
open Classical

--Max-Plus åŠä½“ T

-- å°é›†åˆï¼šå®Ÿæ•°ã« -âˆ ã‚’ adjoin ã—ãŸã‚‚ã®ã€‚-âˆ ã¯ `âŠ¥`. 
abbrev T : Type := WithBot â„

-- ãƒˆãƒ­ãƒ”ã‚«ãƒ«åŠ æ³•ï¼ˆâŠ•ï¼‰ï¼šmax. 
instance : Add T := âŸ¨fun a b => max a bâŸ©

-- ãƒˆãƒ­ãƒ”ã‚«ãƒ« 0ï¼ˆåŠ æ³•å˜ä½ï¼‰ï¼š-âˆ. 
instance : Zero T := âŸ¨(âŠ¥ : WithBot â„)âŸ©

-- ãƒˆãƒ­ãƒ”ã‚«ãƒ«ä¹—æ³•ï¼ˆâŠ—ï¼‰ï¼šå®Ÿæ•°åŠ æ³•ã€‚ãŸã ã— -âˆ ã¯å¸åå…ƒã€‚ 
instance : Mul T :=
  âŸ¨fun a b =>
    match a, b with
    | âŠ¥      , _       => (âŠ¥ : WithBot â„)
    | _       , âŠ¥      => (âŠ¥ : WithBot â„)
    | some x , some y  => some (x + y)âŸ©

-- ãƒˆãƒ­ãƒ”ã‚«ãƒ« 1ï¼ˆä¹—æ³•å˜ä½ï¼‰ï¼šå®Ÿæ•°ã® 0. 
instance : One T := âŸ¨(some (0 : â„))âŸ©

@[simp] lemma trop_add_def (a b : T) : a + b = max a b := rfl
@[simp] lemma trop_zero_def : (0 : T) = (âŠ¥ : WithBot â„) := rfl
@[simp] lemma trop_mul_def (a b : T) :
    a * b =
      match a, b with
      | âŠ¥     , _      => (âŠ¥ : WithBot â„)
      | _      , âŠ¥     => (âŠ¥ : WithBot â„)
      | some x, some y => some (x + y) := rfl
@[simp] lemma trop_one_def : (1 : T) = (some (0 : â„)) := rfl

/- å¯æ›æ€§ãƒ»çµåˆæ€§ãªã©ã€`Semiring` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å»ºã¦ã‚‹ã®ã«å¿…è¦ãªè£œé¡Œ
    ï¼ˆç´°éƒ¨ã¯ Mathlib ã® `WithBot` + å®Ÿæ•°åŠ æ³•ã®æ€§è³ªã§ã„ãšã‚Œè¨¼æ˜ã™ã‚‹ï¼‰. -/
lemma trop_add_comm (a b : T) : a + b = b + a := by
  simp [trop_add_def, max_comm]

lemma trop_add_assoc (a b c : T) :
    (a + b) + c = a + (b + c) := by 
  simp [trop_add_def, max_assoc, max_comm]

lemma trop_zero_add (a : T) : (0 : T) + a = a := by
  cases a <;> simp [trop_add_def, trop_zero_def, max_eq_right_iff,
                    max_eq_left_iff] <;> tauto

lemma trop_add_zero (a : T) : a + (0 : T) = a := by
  cases a <;> simp [trop_add_def, trop_zero_def, max_eq_right_iff,
                    max_eq_left_iff] <;> tauto

private def trop_nsmul (n : â„•) (a : T) : T :=
  Nat.recOn n (0 : T) (fun _ acc => acc + a)

private lemma trop_nsmul_zero (a : T) :
    trop_nsmul 0 a = (0 : T) := rfl
private lemma trop_nsmul_succ (n : â„•) (a : T) :
    trop_nsmul (n.succ) a = trop_nsmul n a + a := rfl

lemma trop_zero_mul (a : T) : (0 : T) * a = (0 : T) := by
  cases a <;> simp [trop_mul_def, trop_zero_def]

lemma trop_mul_zero (a : T) : a * (0 : T) = (0 : T) := by
  cases a <;> simp [trop_mul_def, trop_zero_def]

lemma trop_one_mul (a : T) : (1 : T) * a = a := by
  cases a <;> simp [trop_mul_def, trop_one_def]

lemma trop_mul_one (a : T) : a * (1 : T) = a := by
  cases a <;> simp [trop_mul_def, trop_one_def]

lemma trop_mul_comm (a b : T) : a * b = b * a := by
  cases a <;> cases b <;> simp [trop_mul_def, add_comm]

lemma trop_mul_assoc (a b c : T) :
    (a * b) * c = a * (b * c) := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, add_assoc]

private def trop_npow (n : â„•) (a : T) : T :=
  Nat.recOn n (1 : T) (fun _ acc => acc * a)

lemma trop_left_distrib (a b c : T) :
    a * (b + c) = a * b + a * c := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, trop_add_def, trop_zero_def,
          max_eq_left_iff, max_eq_right_iff,
          add_comm, add_left_comm, add_assoc,
          sup_eq_max] <;> try tauto

lemma trop_right_distrib (a b c : T) :
    (a + b) * c = a * c + b * c := by
  cases a <;> cases b <;> cases c <;>
    simp [trop_mul_def, trop_add_def, trop_zero_def,
          max_eq_left_iff, max_eq_right_iff,
          add_comm, add_left_comm, add_assoc,
          sup_eq_max] <;> try tauto

lemma trop_add_idempotent (a : T) : a + a = a := by
  simp [trop_add_def]

/- Max-Plus åŠä½“ `T` ã¯ã€ã‚ãªãŸãŒå®šç¾©ã—ãŸ `TropicalGeometry.Semiring` ã®
    ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã€‚ -/
noncomputable instance : TropicalGeometry.Semiring T where
  -- AddCommMonoid éƒ¨åˆ†
  add := (Â·+Â·)
  zero := (0 : T)
  add_assoc := trop_add_assoc
  zero_add := trop_zero_add
  add_zero := trop_add_zero
  add_comm := trop_add_comm
  nsmul := fun n a => trop_nsmul n a
  nsmul_zero := by intro a; simp [trop_nsmul_zero]
  nsmul_succ := by intro n a; simp [trop_nsmul_succ]
  -- CommMonoid éƒ¨åˆ†
  mul := (Â·*Â·)
  one := (1 : T)
  mul_assoc := trop_mul_assoc
  one_mul := trop_one_mul
  mul_one := trop_mul_one
  mul_comm := trop_mul_comm
  npow := fun n a => trop_npow n a
  -- Semiring å›ºæœ‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  mul_zero := by intro a; exact trop_mul_zero a
  zero_mul := by intro a; exact trop_zero_mul a
  left_distrib := by intro a b c; exact trop_left_distrib a b c
  right_distrib := by intro a b c; exact trop_right_distrib a b c


--nå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼(å½¢å¼çš„ã«ã¯ T[Xâ‚,â€¦,Xâ‚™])
abbrev TropMonomial (n : â„•) := (Fin n â†’â‚€ â„•)

abbrev TropPoly (n : â„•) := (TropMonomial n) â†’â‚€ T

-- å˜é …å¼ `c âŠ— X^u` ã‚’1é …ã ã‘æŒã¤ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ã¨ã—ã¦ä½œã‚‹ã€‚ 
noncomputable def TropPoly.monom {n : â„•}
    (u : TropMonomial n) (c : T) : TropPoly n :=
  Finsupp.single u c

notation "TropPoly[" n "]" => TropPoly n


-- nå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼(å½¢å¼çš„ã«ã¯ T[Xâ‚^{Â±1},â€¦,Xâ‚™^{Â±1}])
abbrev TropLaurentMonomial (n : â„•) := (Fin n â†’â‚€ â„¤)

abbrev TropLaurent (n : â„•) := (TropLaurentMonomial n) â†’â‚€ T

-- å˜é …ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ `c âŠ— X^u` ï¼ˆu ã¯ â„¤-ãƒ™ã‚¯ãƒˆãƒ«æŒ‡æ•°ï¼‰. 
noncomputable def TropLaurent.monom {n : â„•}
    (u : TropLaurentMonomial n) (c : T) : TropLaurent n :=
  Finsupp.single u c

notation "TropLaurent[" n "]" => TropLaurent n
open Classical
open scoped BigOperators



-- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ã®è©•ä¾¡ç‚¹ï¼ˆT^nï¼‰ã‚’ Lean çš„ã«ã€ŒFin n â†’ Tã€ã¨ã¿ãªã™ 
abbrev TropPoint (n : â„•) := Fin n â†’ T

-- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ã®è©•ä¾¡ç‚¹ï¼ˆâ„^nï¼‰ 
abbrev TropLaurentPoint (n : â„•) := Fin n â†’ â„

noncomputable def tropPow (a : T) (k : â„•) : T :=
  Nat.recOn k (1 : T) (fun _ acc => acc * a)

@[simp] lemma tropPow_zero (a : T) :
    tropPow a 0 = (1 : T) := rfl

@[simp] lemma tropPow_succ (a : T) (k : â„•) :
    tropPow a (k.succ) = tropPow a k * a := rfl

-- å®Ÿæ•°ã‚’ T (= WithBot â„) ã«å…¥ã‚Œã‚‹åŸ‹ã‚è¾¼ã¿ã€‚ 
@[simp] def toT (x : â„) : T := some x

@[simp] lemma toT_mul_toT (x y : â„) :
    toT (x + y) = (toT x * toT y) := rfl

@[simp] lemma toT_zero : toT (0 : â„) = (1 : T) := rfl
-- ï¼ˆ1 in T ã¯ some 0 ã¨ã„ã†è¨­è¨ˆã ã£ãŸã¯ãšï¼‰



noncomputable def tropPowZ (a : â„) (m : â„¤) : T :=
  some ((m : â„¤) â€¢ a)

noncomputable def monomialEval
    {n : â„•} (u : TropMonomial n) (x : TropPoint n) : T :=
  âˆ i in Finset.univ, tropPow (x i) (u i)

@[simp] lemma monomialEval_def
    {n : â„•} (u : TropMonomial n) (x : TropPoint n) :
    monomialEval u x
      = âˆ i in Finset.univ, tropPow (x i) (u i) := rfl

noncomputable def monomialLaurentEval
    {n : â„•} (u : TropLaurentMonomial n) (x : TropLaurentPoint n) : T :=
  âˆ i in Finset.univ, tropPowZ (x i) (u i)

@[simp] lemma monomialLaurentEval_def
    {n : â„•} (u : TropLaurentMonomial n) (x : TropLaurentPoint n) :
    monomialLaurentEval u x
      = âˆ i in Finset.univ, tropPowZ (x i) (u i) := rfl

noncomputable def TropPoly.eval {n : â„•}
    (F : TropPoly n) (x : TropPoint n) : T :=
  F.support.sup (fun u => F u * monomialEval u x)

noncomputable def TropLaurent.eval {n : â„•}
    (G : TropLaurent n) (x : TropLaurentPoint n) : T :=
  G.support.sup (fun u => G u * monomialLaurentEval u x)


-- FÌ„ : Tâ¿ â†’ T. ï¼ˆnå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼ F ãŒå®šã‚ã‚‹ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼é–¢æ•°ï¼‰ 
noncomputable def TropPoly.bar {n : â„•}
    (F : TropPoly n) : TropPoint n â†’ T :=
  fun x => TropPoly.eval F x

-- á¸  : â„â¿ â†’ T.  ï¼ˆnå¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G ãŒå®šã‚ã‚‹ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°ï¼‰ 
noncomputable def TropLaurent.bar {n : â„•}
    (G : TropLaurent n) : TropLaurentPoint n â†’ T :=
  fun x => TropLaurent.eval G x


/- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«å¤šé …å¼é–¢æ•°ï¼ˆãƒãƒ¼ä»˜ãå¤šé …å¼å…¨ä½“ï¼‰.  
    è¦ç´ ã¯ã€Œf : (Fin n â†’ T) â†’ T ã§ï¼ŒâˆƒFï¼Œå¤šé …å¼ F ãŒã‚ã£ã¦ f = FÌ„ã€ã€‚ -/
noncomputable abbrev TropPolyFunc (n : â„•) :=
  { f : TropPoint n â†’ T //
      âˆƒ F : TropPoly n, f = TropPoly.bar F }

/- n å¤‰æ•°ãƒˆãƒ­ãƒ”ã‚«ãƒ«ãƒ»ãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼é–¢æ•°ï¼ˆãƒãƒ¼ä»˜ããƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼å…¨ä½“ï¼‰.  
    è¦ç´ ã¯ã€Œg : (Fin n â†’ â„) â†’ T ã§ï¼ŒâˆƒGï¼Œãƒ­ãƒ¼ãƒ©ãƒ³å¤šé …å¼ G ãŒã‚ã£ã¦ g = á¸ ã€ã€‚ -/
noncomputable abbrev TropLaurentFunc (n : â„•) :=
  { g : TropLaurentPoint n â†’ T //
      âˆƒ G : TropLaurent n, g = TropLaurent.bar G }


@[simp] lemma mul_bot_left  (x : T) :
    (âŠ¥ : T) * x = (âŠ¥ : T) := by
  cases x <;> rfl

@[simp] lemma mul_bot_right (x : T) :
    x * (âŠ¥ : T) = (âŠ¥ : T) := by
  cases x <;> rfl

@[simp] lemma mul_some_some (a b : â„) :
    (some a : T) * (some b : T) = (some (a + b) : T) := rfl

@[simp] lemma mul_some_bot (a : â„) :
    (some a : T) * (âŠ¥ : T) = (âŠ¥ : T) := rfl

@[simp] lemma mul_bot_some (a : â„) :
    (âŠ¥ : T) * (some a : T) = (âŠ¥ : T) := rfl

lemma cancellative_T : Cancellative T := by
  intro a b c h
  cases a with
  | none =>
      left
      rfl
  | some ra =>
      cases b with
      | none =>
          have hb : (âŠ¥ : T) = (some ra : T) * c := by simpa using h
          cases c with
          | none =>
              right
              rfl
          | some rc =>
              cases hb
      | some rb =>
          have hb : (some (ra + rb) : T) = (some ra : T) * c := by
            simpa using h
          cases c with
          | none =>
              cases hb
          | some rc =>
              have h_inj : ra + rb = ra + rc := by
                cases hb
                rfl
              have h_eq : rb = rc := by
                exact add_left_cancel h_inj

              right

axiom cancellative_TropPoly1 :
  Cancellative (TropPoly (n:=1))

axiom cancellative_TropLaurent1 :
  Cancellative (TropLaurent (n:=1))

universe u v

variable {S : Type u} [Semiring S]


structure Ideal (S : Type u) [Semiring S] where
  carrier : S â†’ Prop
  add_mem :
    âˆ€ {a b : S}, carrier a â†’ carrier b â†’ carrier (a + b)
  mul_mem_right :
    âˆ€ {a b : S}, carrier b â†’ carrier (a * b)


/-I.carrier x ã‚’ x âˆˆ I ã¨æ›¸ããŸã„ -/
namespace Ideal
instance : SetLike (Ideal S) where
  coe I := I.carrier
  coe_injective' := by
    intro I J h; cases I; cases J; cases h; rfl

@[simp] lemma mem_carrier {I : Ideal S} {x : S} :
    x âˆˆ I â†” I.carrier x := Iff.rfl

@[simp] lemma add_mem {I : Ideal S} {a b : S}
    (ha : a âˆˆ I) (hb : b âˆˆ I) : a + b âˆˆ I :=
  I.add_mem ha hb

@[simp] lemma mul_mem_right {I : Ideal S} {a b : S}
    (hb : b âˆˆ I) : a * b âˆˆ I :=
  I.mul_mem_right hb

/-- 0 âˆˆ I ã¯ a=0 ã‚’ mul_mem_right with b=0 ã‹ã‚‰ã‚‚å‡ºã›ã‚‹ãŒã€
    æ˜ç¤ºçš„ã«è¨¼æ˜ã—ã¦ãŠãã¨ä¾¿åˆ© -/
lemma zero_mem (I : Ideal S) : (0 : S) âˆˆ I := by
  -- 0 = 0 + 0, and need membership of each 0
  -- ã¾ãšã¯ 0 * (some b) âˆˆ I ã‚’ä½¿ã†ã‚ã‘ã«ã¯ã„ã‹ãªã„ã®ã§ã€
  -- åŠ æ³•é–‰æ€§ã‹ã‚‰å¾—ã‚‹ãŸã‚ã«ã€0 âˆˆ I ã‚’ç¤ºã™ã®ã« 0 âˆˆ I ãŒè¦ã‚‹â€¦ã¨ã„ã†å·¡å›ã«ãªã‚‹ã€‚
  -- ã‚ˆã£ã¦ã“ã“ã¯ classical ã« (0 âˆˆ I) ã‚’ä»®å®šã—ã¦å‡ºã™ã®ã¯ç„¡ç†ãªã®ã§
  -- ã“ã®è£œé¡Œã¯ä½¿ã‚ãšã«å¾Œç¶šã§å¿…è¦ãªã‚‰ assumption ã‹ã‚‰å°ãå½¢ã«ã—ã¾ã™ã€‚
  -- ï¼ˆæœ¬æ›¸å®šç¾©ã§ã¯ 0âˆˆI ã‚’ä»®å®šã—ã¦ã„ãªã„ã®ã§ã“ã“ã§ã¯ `sorry` ã«ã¯ã—ãªã„ã€‚
  --  å˜ã«ç”¨æ„ã—ãªã„ã“ã¨ã«ã™ã‚‹ã€‚ï¼‰
  -- å‰Šé™¤ã—ã¦ãŠãã€‚
  admit

end Ideal


structure SemiringCongruence (S : Type u) [Semiring S] where
  rel : S â†’ S â†’ Prop

  -- (C1) åå°„
  refl  : âˆ€ a : S, rel a a
  -- (C2) å¯¾ç§°
  symm  : âˆ€ {a b : S}, rel a b â†’ rel b a
  -- (C3) æ¨ç§»
  trans : âˆ€ {a b c : S}, rel a b â†’ rel b c â†’ rel a c

  -- (C4) åŠ æ³•ã«é–¢ã—ã¦ä¸¡ç«‹
  add_compat :
    âˆ€ {a b a' b' : S}, rel a b â†’ rel a' b' â†’ rel (a + a') (b + b')
  -- (C5) ä¹—æ³•ã«é–¢ã—ã¦ä¸¡ç«‹
  mul_compat :
    âˆ€ {a b a' b' : S}, rel a b â†’ rel a' b' â†’ rel (a * a') (b * b')

  -- (0,0),(1,1) âˆˆ C ã¯ refl ã‹ã‚‰å¾“ã†ã®ã§åˆ¥æ ã§ã¯æŒãŸãªã„


namespace SemiringCongruence

/-- è¨˜æ³•: a â‰ˆ[C] b -/
infixl:50 " â‰ˆ["  C:0 "] " => (C.rel Â· Â·)

@[simp] lemma refl' (C : SemiringCongruence S) (a : S) : C.rel a a :=
  C.refl a

@[simp] lemma symm' (C : SemiringCongruence S) {a b : S}
    (h : C.rel a b) : C.rel b a :=
  C.symm h

@[simp] lemma trans' (C : SemiringCongruence S) {a b c : S}
    (h1 : C.rel a b) (h2 : C.rel b c) : C.rel a c :=
  C.trans h1 h2

/-- åŠ æ³•é©åˆæ€§ -/
lemma add_compat' (C : SemiringCongruence S)
    {a b a' b' : S} (h : C.rel a b) (h' : C.rel a' b') :
    C.rel (a + a') (b + b') :=
  C.add_compat h h'

/-- ä¹—æ³•é©åˆæ€§ -/
lemma mul_compat' (C : SemiringCongruence S)
    {a b a' b' : S} (h : C.rel a b) (h' : C.rel a' b') :
    C.rel (a * a') (b * b') :=
  C.mul_compat h h'

/-- å¯¾è§’é›†åˆ Î” = {(a,a) | aâˆˆS} ã¯è‡ªæ˜ãªåˆåŒ (trivial congruence). -/
def trivial (S : Type u) [Semiring S] : SemiringCongruence S where
  rel := fun a b => a = b
  refl := by intro a; rfl
  symm := by intro a b h; simpa [h.symm]
  trans := by intro a b c h1 h2; simpa [h1, h2]
  add_compat := by
    intro a b a' b' h h'
    -- h : a=b, h':a'=b'
    -- goal: a+a' = b+b'
    simpa [h, h'] 
  mul_compat := by
    intro a b a' b' h h'
    simpa [h, h']

/-- "çœŸã§ãªã„åˆåŒ" SÃ—S å…¨ä½“ï¼ˆimproper congruenceï¼‰ã‚‚åˆåŒã«ãªã‚‹ -/
def indiscrete (S : Type u) [Semiring S] : SemiringCongruence S where
  rel := fun _ _ => True
  refl := by intro _; trivial
  symm := by intro _ _ _; trivial
  trans := by intro _ _ _ _ _; trivial
  add_compat := by intro _ _ _ _ _ _; trivial
  mul_compat := by intro _ _ _ _ _ _; trivial

end SemiringCongruence


def SemiringCongruence.Ker
    (C : SemiringCongruence S) : Ideal S :=
{ carrier := fun a => C.rel a (0 : S)
  , add_mem := by
      intro a b ha hb
      have h' := C.add_compat ha hb
      simpa using h'
  , mul_mem_right := by
      intro a b hb
      have h' := C.mul_compat (C.refl a) hb
      have hz : a * 0 = (0 : S) := (Semiring.mul_zero (R:=S) a)
      simpa [hz]
}

lemma Ker_isIdeal (C : SemiringCongruence S) :
    Ideal S :=
  SemiringCongruence.Ker (S:=S) C

namespace SemiringCongruence

variable (C : SemiringCongruence S)

/-- åŒå€¤é–¢ä¿‚ã¨ã—ã¦ã® setoid ã«å¤‰æ› -/
def toSetoid : Setoid S where
  r := C.rel
  iseqv :=
    âŸ¨ C.refl
    , C.symm
    , C.trans âŸ©

/-- å•†é›†åˆ S â§¸ C ï¼ˆæ•™ç§‘æ›¸ã® S/Cï¼‰ -/
def Quotient := Quot (C.toSetoid)

/-- å•†é›†åˆä¸Šã®åŠ æ³•ã®å®šç¾©ï¼š
    [a] + [b] := [a+b]
    well-definedæ€§ã¯ add_compat ã§æ‹…ä¿
-/
noncomputable def qAdd :
    Quotient (C:=C) â†’ Quotient (C:=C) â†’ Quotient (C:=C)
| Quot.mk _ a, Quot.mk _ b =>
    Quot.mk _ (a + b)
termination_by _ _ => 0
decreasing_by simp_wf

noncomputable def qMul :
    Quotient (C:=C) â†’ Quotient (C:=C) â†’ Quotient (C:=C)
| Quot.mk _ a, Quot.mk _ b =>
    Quot.mk _ (a * b)
termination_by _ _ => 0
decreasing_by simp_wf

/-- 0,1 on the quotient -/
noncomputable def qZero : Quotient (C:=C) := Quot.mk _ (0 : S)
noncomputable def qOne  : Quotient (C:=C) := Quot.mk _ (1 : S)

/-- è‡ªç„¶ãªå°„å½± Ï€_C : S â†’ S/C -/
def proj (a : S) : Quotient (C:=C) := Quot.mk _ a

noncomputable def quotientSemiringStructure :
    Semiring (Quotient (C:=C)) := by
  -- ã“ã“ã¯å®Ÿéš›ã«ã¯ `refine` ã§å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŸ‹ã‚ã¦ã„ãå¿…è¦ã‚ã‚Šã€‚
  -- ã‚ãªãŸã®æ—¢å­˜ã® Q(A) ã§ã‚„ã£ãŸã‚ˆã†ã«ã€Quot.lift ã‚’é§†ä½¿ã—ã¦
  -- AddCommMonoid ã¨ CommMonoid ã¨åˆ†é…å…¬ç†ã‚’é †ã«è¨¼æ˜ã—ã¦ã„ã‘ã°å®Œæˆã™ã‚‹ã€‚
  -- ä»Šå›ã¯è¨­è¨ˆå›³ã¨ã—ã¦ `sorry` ã§ç½®ãã€‚
  admit

noncomputable def projHom :
    SemiringHomomorphism S (Quotient (C:=C)) :=
{ toFun := proj (C:=C)
, map_add := by
    intro a b; rfl    -- [a+b] by definition
, map_mul := by
    intro a b; rfl
, map_zero := rfl
, map_one  := rfl
}

lemma proj_surjective :
    Function.Surjective (proj (C:=C)) := by
  intro q
  refine Quot.induction_on q ?_
  intro a
  refine âŸ¨a, rflâŸ©

end SemiringCongruence



structure KernelCongruence
    {Sâ‚ : Type u} {Sâ‚‚ : Type v}
    [Semiring Sâ‚] [Semiring Sâ‚‚]
    (Ïˆ : SemiringHomomorphism Sâ‚ Sâ‚‚) : Prop :=
  (isCong :
    SemiringCongruence Sâ‚
      -- rel a b := Ïˆ a = Ïˆ b
      (
        { rel := fun a b => Ïˆ a = Ïˆ b
        , refl := by intro a; rfl
        , symm := by intro a b h; exact h.symm
        , trans := by
            intro a b c h1 h2
            exact h1.trans h2
        , add_compat := by
            intro a b a' b' h h'
            -- want Ïˆ(a+a')=Ïˆ(b+b')
            -- Ïˆ.map_add ã‚’ä½¿ã†
            calc
              Ïˆ (a + a')
                  = Ïˆ a + Ïˆ a' := Ïˆ.map_add a a' |> Eq.symm
              _ = Ïˆ b + Ïˆ b' := by simp [h, h']
              _ = Ïˆ (b + b') := Ïˆ.map_add b b'
        , mul_compat := by
            intro a b a' b' h h'
            -- Ïˆ(a*a') = Ïˆ(b*b')
            calc
              Ïˆ (a * a')
                  = Ïˆ a * Ïˆ a' := Ïˆ.map_mul a a' |> Eq.symm
              _ = Ïˆ b * Ïˆ b' := by simp [h, h']
              _ = Ïˆ (b * b') := Ïˆ.map_mul b b'
        } )
  )

/--
  ä¸Šã® KernelCongruence ã‹ã‚‰å®Ÿéš›ã® `SemiringCongruence Sâ‚` ã‚’å–ã‚Šå‡ºã—ãŸã„ã®ã§
  å…·ä½“çš„ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä¸ãˆã‚‹ helperã€‚
-/
def kerCongruence
    {Sâ‚ : Type u} {Sâ‚‚ : Type v}
    [Semiring Sâ‚] [Semiring Sâ‚‚]
    (Ïˆ : SemiringHomomorphism Sâ‚ Sâ‚‚) :
    SemiringCongruence Sâ‚ :=
{ rel := fun a b => Ïˆ a = Ïˆ b
, refl := by intro a; rfl
, symm := by intro a b h; exact h.symm
, trans := by
    intro a b c h1 h2
    exact h1.trans h2
, add_compat := by
    intro a b a' b' h h'
    calc
      Ïˆ (a + a')
          = Ïˆ a + Ïˆ a' := Ïˆ.map_add a a' |> Eq.symm
      _ = Ïˆ b + Ïˆ b' := by simp [h, h']
      _ = Ïˆ (b + b') := Ïˆ.map_add b b'
, mul_compat := by
    intro a b a' b' h h'
    calc
      Ïˆ (a * a')
          = Ïˆ a * Ïˆ a' := Ïˆ.map_mul a a' |> Eq.symm
      _ = Ïˆ b * Ïˆ b' := by simp [h, h']
      _ = Ïˆ (b * b') := Ïˆ.map_mul b b'
}

structure SemiringIso (R : Type u) (S : Type v)
  [Semiring R] [Semiring S] : Type (max u v) where
  toFun    : R â†’ S
  invFun   : S â†’ R
  -- æº–åŒå‹æ€§
  map_add  : âˆ€ a b, toFun (a + b) = toFun a + toFun b
  map_mul  : âˆ€ a b, toFun (a * b) = toFun a * toFun b
  map_zero : toFun 0 = 0
  map_one  : toFun 1 = 1
  left_inv  : âˆ€ x, invFun (toFun x) = x
  right_inv : âˆ€ y, toFun (invFun y) = y


namespace SemiringIso

noncomputable def quotientKernelIso
    {Sâ‚ : Type u} {Sâ‚‚ : Type v}
    [Semiring Sâ‚] [Semiring Sâ‚‚]
    (Ïˆ : SemiringHomomorphism Sâ‚ Sâ‚‚)
    (hÏˆsurj : Function.Surjective Ïˆ) :
    SemiringIso
      (SemiringCongruence.Quotient (S:=Sâ‚)
        (kerCongruence (Sâ‚:=Sâ‚) (Sâ‚‚:=Sâ‚‚) Ïˆ))
      Sâ‚‚ :=
by
  -- è¨˜å·çŸ­ç¸®
  let C := kerCongruence (Sâ‚:=Sâ‚) (Sâ‚‚:=Sâ‚‚) Ïˆ
  -- å®šç¾©: Ï†Ì„([a]) := Ïˆ(a)
  let forward :
      SemiringCongruence.Quotient (S:=Sâ‚) C â†’ Sâ‚‚ :=
    fun q => Quot.induction_on q (fun a => Ïˆ a)
  -- é€†å†™åƒã¯ surjectivity ã‹ã‚‰ä»£è¡¨å…ƒã‚’å–ã‚‹
  choose pre pre_spec using hÏˆsurj
  -- pre : Sâ‚‚ â†’ Sâ‚  ã‹ã¤  Ïˆ (pre y) = y
  let backward : Sâ‚‚ â†’
      SemiringCongruence.Quotient (S:=Sâ‚) C :=
    fun y => Quot.mk _ (pre y)

  refine
  { toFun    := forward
  , invFun   := backward
  , map_add  := ?map_add
  , map_mul  := ?map_mul
  , map_zero := ?map_zero
  , map_one  := ?map_one
  , left_inv := ?left
  , right_inv:= ?right
  }
  Â· -- map_add
    intro q1 q2
    -- unfold forward; do Quot.induction_on q1 q2
    refine Quot.induction_on q1 ?hq1
    intro a
    refine Quot.induction_on q2 ?hq2
    intro b
    -- forward([a]+[b]) = Ïˆ(a+b) = Ïˆ(a)+Ïˆ(b) = forward[a]+forward[b]
    simp [forward,
          SemiringCongruence.qAdd,
          Ïˆ.map_add]
  Â· -- map_mul
    refine Quot.induction_on q1 ?hq1
    intro a
    refine Quot.induction_on q2 ?hq2
    intro b
    simp [forward,
          SemiringCongruence.qMul,
          Ïˆ.map_mul]
  Â· -- map_zero
    simp [forward, SemiringCongruence.qZero, Ïˆ.map_zero]
  Â· -- map_one
    simp [forward, SemiringCongruence.qOne, Ïˆ.map_one]
  Â· -- left_inv : backward âˆ˜ forward = id
    refine Quot.induction_on q1 ?hq1
    intro a
    -- backward(forward([a])) = backward(Ïˆ a) = [pre (Ïˆ a)]
    -- ã—ã‹ã— pre_spec : Ïˆ (pre y) = y, ç‰¹ã« y=Ïˆ a â‡’ Ïˆ(pre (Ïˆ a)) = Ïˆ a
    -- ã‚ˆã£ã¦ a ã¨ pre(Ïˆ a) ã¯ kerCongruence Ïˆ ã§åŒå€¤ãªã®ã§åŒã˜åŒå€¤é¡
    -- ã“ã‚Œã‚’ç¤ºã—ã¦ rfl
    have hker : (kerCongruence Ïˆ).rel a (pre (Ïˆ a)) := by
      -- need Ïˆ a = Ïˆ (pre (Ïˆ a))
      simpa [pre_spec (Ïˆ a)]
    -- 2ã¤ã®Quot.mkãŒåŒã˜ã«ãªã‚‹ã“ã¨ã‚’ç¤ºã™
    -- Quot.sound : rel a b â†’ Quot.mk _ a = Quot.mk _ b
    -- æœ€å¾Œã« `simp`
    apply Quot.sound
    exact hker
  Â· -- right_inv : forward âˆ˜ backward = id on Sâ‚‚
    intro y
    -- forward(backward y) = forward([pre y]) = Ïˆ(pre y) = y
    simpa [forward, backward, pre_spec y]

end SemiringIso




#min_imports
