/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1ï¼ˆå®‹å…ˆç”Ÿã®å®šç¾©ã«å¿ å®Ÿã«å¾“ã£ãŸ(å¯æ›ãª)Semiringã®å®šç¾©ï¼‰
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

--ã¤ã„ã§ã«åŠä½“ã‚’å®šç¾©
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

--åŠ æ³•çš„å†ªç­‰ã®å®šç¾©
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

--Ex2.1.2 ğ”¹=({0,-âˆ},max,+)ã¯åŠä½“ã§ã‚ã‚‹
inductive ğ”¹ : Type
| negInf
| zero

/-
ã¤ã‘ã¦ãŠãã¨ã„ã„ã“ã¨ãŒã‚ã‚‹ã¨GPTã‹ã‚‰ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Š
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

/- åŠ æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- ä¹—æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(åŠç’°æº–åŒå‹ã®å®šç¾©)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--ä»Šå¾ŒãŸã ã®æ§‹é€ ã ã£ã¦Semiringhomomorphismã‚’é–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã„ã¡ã„ã¡f.toFun xã¨æ›¸ã‹ãªãã‚ƒã„ã‘ãªããªã‚‹ã€‚
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

--simpã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--æ’ç­‰æº–åŒå‹ã®å®šç¾©
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--æº–åŒå‹ã®åˆæˆã®å®šç¾©ã€‚åŠç’°æº–åŒå‹ã«å¿…è¦ãªï¼•è¦ç´ ã‚’é †ã«è¨¼æ˜
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgã¯ä¸¡è¾ºã«åŒã˜é–¢æ•°ã‚’é©ç”¨ã—ã¦ã‚ˆã„ã¨ã„ã†è£œé¡Œã€‚f.map_addã®ä¸¡è¾ºã«gã‚’é©ç”¨ã—ãŸã¨ã„ã†ã“ã¨
      _ = g (f a) + g (f b) := by --_ã¯g (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

--Sâ‚ä»£æ•°ã®å®šç¾©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©
--semiringhomoã«ã¯åå‰ã®ã¤ã„ã¦ã„ãªã„é–¢æ•°ãŒã‚ã‚‹ã®ã§ãã‚Œã‚’Î¨ã¨åä»˜ã‘ã‚‹ã€‚

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--Aã¨Bã®é–“ã«å¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’ä¸€ã¤å–ã‚Šå‡ºã™ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚reducibleã«ã™ã‚‹ã“ã¨ã§algeMapã‚’ä½¿ã†ã¨è‡ªå‹•ã§h.homã®ã‚ˆã†ãªå¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’å‘¼ã³å‡ºã—ã¦ãã‚Œã‚‹ã€‚

--simpç”¨
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-ä»£æ•°æº–åŒå‹ã®å®šç¾©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A â†’ X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A â†’ Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å¯æ›å›³å¼--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g ã« a ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) h.comm

end AlgHom


--A-ä»£æ•°æº–åŒå‹ã®å­˜åœ¨
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--å…·ä½“çš„ãª Î¨ ã¨å¯æ›æ€§
theorem intro
  (Î¨ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Î¨
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  âŸ¨Î¨, hâŸ©

--ã²ã¨ã¤Î¨ã‚’å–ã‚Šå‡ºã™ã€‚ 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

--å–ã‚Šå‡ºã—ãŸÎ¨ãŒå›³å¼ã‚’å¯æ›ã«ã™ã‚‹ã€‚ 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--å¯æ›æ€§ã®ç‚¹ã”ã¨ver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commã‚’å–ã‚Šå‡ºã—ã¦congrArgã‚’é©ç”¨ã™ã‚‹ã ã‘
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) hc

end AlgebraRel

-- A-ä»£æ•°åŒå‹ã®å®šç¾©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- äº’ã„ã«é€†ï¼ˆAlgHom ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ toHom ã‚’ä¸€åº¦ã ã‘å–ã‚Šå‡ºã—ã¦ä½¿ã†ï¼‰
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- åŒå‹ã®é †æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- åŒå‹ã®é€†æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv âˆ˜ eã¯identity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idã«xã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism X X) => Ï† x) e.left_inv

--e âˆ˜ e.invã¯identity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idã«yã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism Y Y) => Ï† y) e.right_inv

--å¯¾ç§°æ€§
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--ğ”¹ã®å°å…¥
instance : Semiring ğ”¹ where
  mul_zero := by intro a; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl

--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl

--AãŒåŠ æ³•å†ªç­‰ã®ã¨ãï¼Œğ”¹ â†’ Aã§åŠç’°æº–åŒå‹ã¨ãªã‚‹
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1,
  map_add := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 + 0
      exact (zero_add (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š1 = 0 + 1
      exact (zero_add (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š1 = 1 + 0
      exact (add_zero (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 + 1ï¼ˆå†ªç­‰æ€§ï¼‰
      exact (h (1 : A)).symm,
  map_mul := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 * 1
      exact (one_mul (1 : A)).symm,
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 ã€ŒA ãŒåŠ æ³•å†ªç­‰ã€â†”ã€ŒA ãŒ ğ”¹-ä»£æ•°ï¼ˆå­˜åœ¨ã™ã‚‹ï¼‰ã€ -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· -- (â†’) åŠ æ³•å†ªç­‰ â‡’ ğ”¹-ä»£æ•°ãŒå­˜åœ¨
    intro h
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©
  Â· -- (â†) ğ”¹-ä»£æ•°ãŒå­˜åœ¨ â‡’ åŠ æ³•å†ªç­‰
    intro hAlg
    rcases hAlg with âŸ¨instâŸ©
    -- Ïˆ : ğ”¹ â†’ A
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    -- 1_A = 1_A + 1_A
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)      -- Ïˆ(1+1) = Ïˆ1 + Ïˆ1
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    -- ä»»æ„ã® a ã«ã¤ã„ã¦ a + a = a
    intro a
    -- ã¾ãš a*1 = a*1 + a*1 ã‚’ä½œã‚‹ï¼ˆå·¦åˆ†é…ã¨ h11Aï¼‰
    have hmul : a * 1 = a * 1 + a * 1 := by
      -- a*(1+1) = a*1 + a*1 ã«å¯¾ã—ã¦ï¼Œ(1+1) â†’ 1 ã¸æ›¸ãæ›ãˆã‚‹
     simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- ã‚ã¨ã¯ mul_one ã§ä»•ä¸Šã’
    -- ï¼ˆå‘ãã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¯¾ç§°ã‚’å–ã‚‹ï¼‰
    have : a + a = a := by
      simpa [mul_one] using hmul.symm
    exact this



--â‰¤â‚ã®å®šç¾©

section OrderFromAddIdem

variable (A : Type u) [Semiring A]

--a â‰¤â‚ bã‚’a + b = bã¨ã™ã‚‹ã€‚
def leA (a b : A) : Prop := a + b = b

--åå°„å¾‹
theorem leA_refl (h : AddIdempotent A) (a : A) : leA (A:=A) a a := by
  unfold leA
  simpa using h a

--æ¨ç§»å¾‹
theorem leA_trans {a b c : A}
    (hab : leA (A:=A) a b) (hbc : leA (A:=A) b c) :
    leA (A:=A) a c := by
  unfold leA at hab hbc âŠ¢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--åå¯¾ç§°å¾‹
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0ã¯æœ€å°å…ƒ
theorem bot_leA (a : A) : leA (A:=A) (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA (A:=A) a b) :
    leA (A:=A) (c * a) (c * b) := by
  unfold leA at hab âŠ¢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  âˆ€ â¦ƒa b c : Aâ¦„, a * b = a * c â†’ a = (0 : A) âˆ¨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--ã“ã‚“ã”ä¾¿åˆ©ã«ãªã‚‹(ã‚‰ã—ã„)è£œé¡Œ
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a â‰  (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  Â· exact (ha hzero).elim
  Â· exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--åˆ†æ¯ãŒ 0 ã§ãªã„çµ„ (a,b)ã®é›†åˆã‚’å®šç¾©
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A Ã— A // p.2 â‰  (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- åˆ†å­ / åˆ†æ¯ã‚’è¨˜å·ã§çŸ­ç¸®
def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b â‰  0) :
    num (A:=A) âŸ¨(a,b), hbâŸ© = a := rfl
@[simp] lemma den_mk (a b : A) (hb : b â‰  0) :
    den (A:=A) âŸ¨(a,b), hbâŸ© = b := rfl
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p â‰  0 := p.2

--åŒå€¤é–¢ä¿‚
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--åå°„å¾‹
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--å¯¾ç§°å¾‹
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

--æ¨ç§»å¾‹
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q r â†’ Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q â‰  (0 : A) := den_ne_zero (A:=A) q

  -- â‘  (hpq) ã‚’å³ã‹ã‚‰ r.den ã§æ›ã‘ã€å½¢ã‚’ q.den * (p.num * r.den) = r.den * (q.num * p.den)ã«æ•´ãˆã‚‹
  have h1' :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- â‘¡ (hqr) ã‚’å³ã‹ã‚‰ p.den ã§æ›ã‘ã€å½¢ã‚’ q.den * (r.num * p.den) = r.den * (q.num * p.den)ã«æ•´ãˆã‚‹
  have h2' :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- â‘¢ åŒã˜å³è¾ºã‚’çµŒç”±ã—ã¦ q.den ã‚’å·¦ã‹ã‚‰æ¶ˆå»
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1'.trans h2'.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aã®Relã¯ï¼ˆcancellativeã®ä¸‹ã§ï¼‰åŒå€¤é–¢ä¿‚ã«ãªã‚‹ã€‚  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    âŸ¨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) âŸ©

end FracCarrier
end TropicalGeometry

namespace TropicalGeometry
open Classical

/- å•†é›†åˆ Q(A) ã‚’ä½œã‚Šã€è¦ç´ ã‚’ a/b ã¨æ›¸ã‘ã‚‹ã‚ˆã†ã«ã™ã‚‹ -/

section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

/-- A ã®åˆ†æ•°ã®å•†é›†åˆï¼š`Q(A) := {(a,b) | b â‰  0}/âˆ¼` -/
def Q : Type u := Quot (FracCarrier.setoid (A:=A) hC)

/-- åŸºæœ¬ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼š`a/b`ï¼ˆãŸã ã— `b â‰  0`ï¼‰ã‚’åŒå€¤é¡ã«æŒã¡ä¸Šã’ã‚‹ã€‚ -/
def Q.mk (a b : A) (hb : b â‰  0) : Q (A:=A) hC :=
  Quot.mk _ âŸ¨(a,b), hbâŸ©

/-- ã€Œéé›¶ã®åˆ†æ¯ã€ã‚’åŒ…ã‚€ãƒŸãƒ‹æ§‹é€ ä½“ã€‚`âŸ¨b, hbâŸ© : NZDen A`ã€‚ -/
structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val â‰  0

namespace Q

/-- è¨˜æ³• `a / âŸ¨b, hbâŸ©` ã®æœ¬ä½“ï¼š`Q.mk a b hb`ã€‚ -/
def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-! ### è¨˜æ³•

- ã¾ãšã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã ã‘æœ‰åŠ¹ãª **ãƒ­ãƒ¼ã‚«ãƒ«è¨˜æ³•**ã€‚
  ã‚»ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ•° `hC` ãŒè¦‹ãˆã‚‹ã®ã§ã€`a / b` ãŒãã®ã¾ã¾ä½¿ãˆã¾ã™ã€‚
- ä½µã›ã¦ã€ä»»æ„ã®å ´æ‰€ã§ä½¿ãˆã‚‹ **ã‚¹ã‚³ãƒ¼ãƒ—ä»˜ãè¨˜æ³•** `a /[hC] b` ã‚‚ç”¨æ„ã€‚
  ã“ã¡ã‚‰ã¯ `hC` ã‚’æ˜ç¤ºã™ã‚‹ã®ã§å‰ãƒã‚§ãƒƒã‚¯ã«å¼•ã£ã‹ã‹ã‚Šã¾ã›ã‚“ã€‚
-/

/-- ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…é™å®šï¼š`a / b : Q(A,hC)` ï¼ˆ`b : NZDen A`ï¼‰ --/
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

/-- ã©ã“ã§ã‚‚ä½¿ãˆã‚‹ç‰ˆï¼š`a /[hC] b` ï¼ˆ`b : NZDen A`ï¼‰ --/
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic
end TropicalGeometry

namespace TropicalGeometry
open Classical


section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

-- ã“ã“ã§ã® Q ã¯ã€ŒQuotBasicã€ã§å®šç¾©ã—ãŸã‚‚ã®ã‚’ä½¿ã†ï¼ˆé‡è¤‡å®šç¾©ã—ãªã„ï¼‰

namespace FracCarrier

/-- åˆ†æ¯åŒå£«ã®ç©ã¯ 0 ã«ãªã‚‰ãªã„ï¼ˆ`Cancellative` ã‚’åˆ©ç”¨ï¼‰ -/
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den â‰  0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 ã‹ã‚‰ p.den * q.den = p.den * 0 ã‚’å¾—ã‚‹
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _
    exact h.trans hz.symm
  -- å·¦ã‹ã‚‰ cancel
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

/-- å•†å’Œã®ã€Œä»£è¡¨ã€ï¼š (a/b) + (c/d) := (ad + cb) / (bd) -/
def addRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

/-- å•†ç©ã®ã€Œä»£è¡¨ã€ï¼š (a/b) * (c/d) := (ac) / (bd) -/
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

/-- åŠ æ³•ãŒåŒå€¤é–¢ä¿‚ã¨ä¸¡ç«‹ï¼ˆwell-definedï¼‰ -/
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  -- ç›®æ¨™ï¼š (p.num*q.den + q.num*p.den)*(p'.den*q'.den)
  --     = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
  unfold Rel addRep
  -- (x+y)*z = x*z + y*z
  have Hâ‚€ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  -- 1æ®µç›®ï¼šå˜ç´”åˆ†é…
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by
            simpa using Hâ‚€
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by
            -- ã‹ã‘ç®—ã®é †åºãƒ»çµåˆã®å…¥ã‚Œæ›¿ãˆ
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            -- å³è¾ºã®ãƒšã‚¢ã®é †åºã‚‚å…¥ã‚Œæ›¿ãˆã‚‹
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by
            -- é€†å‘ãã®åˆ†é…ï¼ˆ(a*c)+(b*c) = (a+b)*cï¼‰
            have Hâ‚ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            -- é …ã®é †åºã‚’ `simp` ã§åˆã‚ã›ã¦ã‹ã‚‰å¯¾ç§°ã‚’ä½¿ã†
            simpa [mul_comm, mul_left_comm, mul_assoc] using Hâ‚.symm

/-- ä¹—æ³•ãŒåŒå€¤é–¢ä¿‚ã¨ä¸¡ç«‹ï¼ˆwell-definedï¼‰ -/
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  -- ç›®æ¨™ï¼š (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den)
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

/-- Q(A) ä¸Šã®åŠ æ³•ï¼ˆ2æ®µéš `Quot.lift` æ–¹å¼ï¼‰ -/
noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  -- ã¾ãšã€Œå³å¼•æ•° q ã‚’ä»£è¡¨ã«æˆ»ã—ã¦ã‹ã‚‰ addRep ã‚’æŒã¡ä¸Šã’ã‚‹ã€é–¢æ•°ã‚’ä½œã‚‹
  let addCoreâ‚ :
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' ã®ã¨ãã‚‚ well-defined
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  -- æ¬¡ã«ã€Œå·¦å¼•æ•° p ã‚’ä»£è¡¨ã«æˆ»ã—ã€addCoreâ‚ p ã‚’é¸ã¶ã€é–¢æ•°ã‚’ä½œã‚‹
  let addCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      (fun p => addCoreâ‚ p)
      (by
        -- p ~ p' ãªã‚‰ã€é–¢æ•° addCoreâ‚ p = addCoreâ‚ p'
        intro p p' hp
        apply funext
        intro y
        -- y ã‚‚ä»£è¡¨ã«æˆ»ã—ã¦åŒå€¤ã‚’ä½œã‚‹
        refine Quot.induction_on y ?_
        intro q
        -- ç›®æ¨™ã‚’æ›¸ãæ›ãˆï¼ˆ2ã¤ã® mk ã®ç­‰ã—ã•ã‚’ç¤ºã›ã°ã‚ˆã„ï¼‰
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        -- ã“ã‚Œã¯ addRep_compat ã® (hp, refl) ã§æˆç«‹
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- ä»¥ä¸Šã‚’ä½¿ã£ã¦ x, y ã«é©ç”¨
  exact addCoreâ‚‚ x y


/-- Q(A) ä¸Šã®ä¹—æ³•ï¼ˆ2æ®µéš `Quot.lift` æ–¹å¼ï¼‰ -/
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCoreâ‚ :
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCoreâ‚ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCoreâ‚‚ x y

end QAddMul
end TropicalGeometry

namespace TropicalGeometry
open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) (h10 : (1 : A) â‰  0)

-- 0,1 ã®ä»£è¡¨ï¼ˆåˆ†æ¯ 1 ã‚’ä½¿ç”¨ï¼‰
def Q.zero : Q (A:=A) hC := Q.mk (A:=A) hC 0 1 h10
def Q.one  : Q (A:=A) hC := Q.mk (A:=A) hC 1 1 h10

-- æ—¢ã«å®šç¾©æ¸ˆã¿ã® Q.add / Q.mul ã‚’ä½¿ã£ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–


instance : Zero (Q (A:=A) hC) := âŸ¨Q.zero (A:=A) hC h10âŸ©
instance : One  (Q (A:=A) hC) := âŸ¨Q.one  (A:=A) hC h10âŸ©
instance : Add  (Q (A:=A) hC) := âŸ¨Q.add (A:=A) hCâŸ©
instance : Mul  (Q (A:=A) hC) := âŸ¨Q.mul (A:=A) hCâŸ©

namespace FracCarrier

variable {hC}

/-- åŠ æ³•ã®å¯æ›æ€§ï¼ˆä»£è¡¨ç‰ˆï¼‰ -/
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  -- Rel ã¨ addRep, num, den ã‚’å±•é–‹ã—ã¦ç›®æ¨™å¼ã‚’ç´ ã®ç­‰å¼ã«è½ã¨ã™
  unfold Rel addRep num den
  -- ç›®æ¨™ï¼š
  -- (p.num*q.den + q.num*p.den) * (q.den*p.den)
  --   = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  -- å’Œã®é †åºã¨åˆ†æ¯å´ã®ç©ã®é †åºã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã ã‘ã§ä¸€è‡´
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          -- å’Œã®é †åºã ã‘ã‚’å¯æ›æ³•å‰‡ã§å…¥ã‚Œæ›¿ãˆ
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          -- åˆ†æ¯å´ã®ç©ã®é †åºã‚’å¯æ›æ³•å‰‡ã§å…¥ã‚Œæ›¿ãˆ
          ac_rfl

/-- åŠ æ³•ã®çµåˆæ€§ï¼ˆä»£è¡¨ç‰ˆï¼‰ -/
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  -- ã©ã¡ã‚‰å´ã‚‚åˆ†æ¯ã¯ p.den*q.den*r.den ã®é †åºé•ã„ã€‚åˆ†å­ã¯åˆ†é…ã§ä¸€è‡´ã€‚
  -- ã²ãŸã™ã‚‰åˆ†é…ï¼‹å¯æ›çµåˆã§ä¸¦ã¹æ›¿ãˆã€‚
  unfold Rel addRep
  -- çœç•¥ã›ãšæ­£æ”»æ³•ï¼š ( (p.num*q.den + q.num*p.den)*r.den + r.num*(p.den*q.den) ) * ( (p.den*q.den)*r.den )
  -- ã¨ ( p.num*(q.den*r.den) + (q.num*r.den + r.num*q.den)*p.den ) * ( p.den*(q.den*r.den) )
  -- ã‚’ ac ã¨åˆ†é…ã‚’é§†ä½¿ã—ã¦ä¸€è‡´ã•ã›ã‚‹ã€‚
  -- è¨ˆç®—ã¯é•·ã„ãŒã€`right_distrib` ã‚’2å›ãšã¤å½“ã¦ã¦å„é …ã‚’åŒå‹ã«ä¸¦ã¹æ›¿ãˆã‚Œã°ã‚ˆã„ã€‚
  -- æ›¸ãæ›ãˆç”¨ã®è£œåŠ©ï¼š
  have Dpq : p.den * q.den = q.den * p.den := by ac_rfl
  have Drp : r.den * p.den = p.den * r.den := by ac_rfl
  have Dqr : q.den * r.den = r.den * q.den := by ac_rfl
  -- å±•é–‹ã—ã¦åˆã‚ã›ã‚‹ï¼ˆ`calc`ï¼‹`simp` ã§æŠ¼ã—åˆ‡ã‚‹ï¼‰
  -- ï¼ˆè©³ç´°å±•é–‹ã¯æ©Ÿæ¢°çš„ã€‚ä»¥ä¸‹ã¯ä¸€æ‹¬ã§ç‰‡ä»˜ã‘ã‚‹ãŸã‚ã® `simp` ãƒ–ãƒ­ãƒƒã‚¯ï¼‰
  -- Lean ã®å¯æ›çµåˆè£œé¡Œç¾¤ï¼ˆ`mul_comm`, `mul_left_comm`, `mul_assoc`ï¼‰ã¨
  -- å³åˆ†é… `right_distrib` ã‚’é©å®œ `simpa` ã§ä½¿ã„ã¾ã™ã€‚
  -- ã¾ãšå·¦è¾ºã‚’ 3 é …ã®å’Œã®å’Œã«å±•é–‹
  have L :
    (p.num*q.den + q.num*p.den) * r.den
      + r.num * (p.den*q.den)
    = p.num*q.den*r.den + q.num*p.den*r.den + r.num*p.den*q.den := by
    -- 2å›ã®åˆ†é…ï¼‹çµåˆå¯æ›ã§æ•´å½¢
    have := Semiring.right_distrib (R:=A)
                (p.num*q.den) (q.num*p.den) r.den
    -- (x+y)*z = x*z + y*z
    -- ã•ã‚‰ã«å„é …ã«çµåˆã‚’é©ç”¨
    -- ä»•ä¸Šã’ï¼š
    simpa [mul_comm, mul_left_comm, mul_assoc] using
      congrArg (fun t => t + r.num * (p.den*q.den)) this
  have R :
    p.num*(q.den*r.den)
      + (q.num*r.den + r.num*q.den)*p.den
    = p.num*q.den*r.den + q.num*r.den*p.den + r.num*q.den*p.den := by
    have := Semiring.right_distrib (R:=A)
                (q.num*r.den) (r.num*q.den) p.den
    -- ã“ã¡ã‚‰ã‚‚åŒæ§˜ã«æ•´å½¢
    simpa [mul_comm, mul_left_comm, mul_assoc] using
      congrArg (fun t => p.num*(q.den*r.den) + t) this
  -- ã™ã‚‹ã¨ä¸¡è¾ºã¯å¯æ›çµåˆã§ä¸€è‡´
  -- ï¼ˆq.den*p.den ã¨ p.den*q.den ã®å…¥ã‚Œæ›¿ãˆãªã©ï¼‰
  have : (p.num*q.den*r.den + q.num*p.den*r.den + r.num*p.den*q.den)
       = (p.num*q.den*r.den + q.num*r.den*p.den + r.num*q.den*p.den) := by
    -- ç¬¬2ãƒ»ç¬¬3é …ã®é †åºã‚’åˆã‚ã›ã‚‹ã ã‘
    simp [mul_comm, mul_left_comm, mul_assoc]
  -- ä»¥ä¸Šã‚’åˆ†æ¯ã®ä¸¦ã¹æ›¿ãˆã¨åˆã‚ã›ã‚Œã° OK
  -- ä»Šå›ã¯ç­‰å¼ã‚’ â€œåˆ†å­åŒå£«ã‚’ä¸€è‡´ã•ã›ãŸâ€ å½¢ã§ç¤ºã—ãŸã®ã§ã€ãã®ã¾ã¾ `simp` ã§çµ‚ãˆã‚‹
  simpa [L, R, mul_comm, mul_left_comm, mul_assoc]

/-- ä¹—æ³•ã®å¯æ›æ€§ï¼ˆä»£è¡¨ç‰ˆï¼‰ -/
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  -- (p.num*q.num)*(p.den*q.den) ã¨ (q.num*p.num)*(q.den*p.den)
  -- ã¯ ac ã§ä¸€è‡´
  simp [mul_comm,  mul_assoc]

/-- ä¹—æ³•ã®çµåˆæ€§ï¼ˆä»£è¡¨ç‰ˆï¼‰ -/
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  -- ã©ã¡ã‚‰ã‚‚åˆ†å­ p.num*q.num*r.numï¼Œåˆ†æ¯ p.den*q.den*r.den ï¼ˆé †åºé•ã„ï¼‰ã«ãªã‚‹ã®ã§ ac
  simp [mul_comm,  mul_assoc]

/-- å·¦åˆ†é…ï¼ˆä»£è¡¨ç‰ˆï¼‰ -/
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- ç›®æ¨™ï¼š(p.num*(q.num*r.den + r.num*q.den))*(p.den*(q.den*r.den))
  --     = ((p.num*q.num)*r.den + (p.num*r.num)*q.den) * ((p.den*q.den)*r.den)
  unfold Rel addRep mulRep
  -- å±•é–‹â†’åˆ†é…â†’é †åºå…¥æ›¿ã§ä¸€è‡´
  -- å·¦å´ã®åˆ†å­ï¼š
  have L :
    (p.num * (q.num * r.den + r.num * q.den))
    = p.num*q.num*r.den + p.num*r.num*q.den := by
    have := Semiring.left_distrib (R:=A) p.num (q.num * r.den) (r.num * q.den)
    simpa [mul_comm, mul_left_comm, mul_assoc] using this
  -- å…¨ä½“ã¨ã—ã¦ã¯å³åˆ†é…ä¸€å›ã§å½¢ãŒä¸€è‡´ã™ã‚‹
  have Hâ‚ :=
    Semiring.right_distrib (R:=A)
      (p.num*q.num*r.den) (p.num*r.num*q.den) (p.den*(q.den*r.den))
  -- å³è¾ºã®åˆ†é…å½¢
  have Hâ‚‚ :=
    Semiring.right_distrib (R:=A)
      ((p.num*q.num)*r.den) ((p.num*r.num)*q.den) ((p.den*q.den)*r.den)
  -- ä»•ä¸Šã’
  simpa [L, mul_comm, mul_left_comm, mul_assoc] using Hâ‚‚.symm

/-- å³åˆ†é…ï¼ˆä»£è¡¨ç‰ˆï¼‰ -/
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by
  -- å·¦åˆ†é…ã®å¯¾ç§°ç‰ˆï¼ˆcomm ã‚’æŒŸã‚“ã§ã‚‚è‰¯ã„ï¼‰
  -- ã“ã“ã¯ç›´æ¥å±•é–‹ã—ã¦ã‚‚çŸ­ã„
  unfold Rel addRep mulRep
  -- (p.num*q.den + q.num*p.den)*r.num = ...
  have L :
    (p.num*q.den + q.num*p.den) * r.num
      = p.num*r.num*q.den + q.num*r.num*p.den := by
    have := Semiring.left_distrib (R:=A) r.num (p.num*q.den) (q.num*p.den)
    -- (r*(x+y) = r*x + r*y) ã‚’å¯æ›çµåˆã§æ•´å½¢
    simpa [mul_comm, mul_left_comm, mul_assoc] using this.symm
  have Hâ‚ :=
    Semiring.right_distrib (R:=A)
      (p.num*r.num*q.den) (q.num*r.num*p.den) ((p.den*q.den)*r.den)
  have Hâ‚‚ :=
    Semiring.right_distrib (R:=A)
      ((p.num*r.num)*q.den) ((q.num*r.num)*p.den) ((p.den*q.den)*r.den)
  simpa [L, mul_comm, mul_left_comm, mul_assoc] using Hâ‚‚.symm

end FracCarrier

/************************ ã“ã“ã‹ã‚‰æ§‹é€ ã‚’æŒã¡ä¸Šã’ã‚‹ ************************/

-- åŠ æ³•ç¾¤å¾‹ï¼ˆåŠ æ³•ï¼šå¯æ›ãƒ»çµåˆãƒ»0 ã¯å˜ä½ï¼‰
instance : AddCommMonoid (Q (A:=A) hC) where
  add := (Â· + Â·)
  zero := (0 : Q (A:=A) hC)
  add_assoc := by
    intro x y z
    -- 3 å¤‰æ•°ã® `Quot` é™ã‚ã— â†’ ä»£è¡¨ç‰ˆè£œé¡Œ â†’ `Quot.sound`
    refine Quot.induction_on x ?hx |>.trans ?_
    Â· intro p; refine Quot.induction_on y ?hy
      Â· intro q; refine Quot.induction_on z ?hz
        Â· intro r
          apply Quot.sound
          exact FracCarrier.addRep_assoc (A:=A) hC p q r
    Â· -- åˆä½“
      rfl
  zero_add := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    -- 0 + p = p
    -- ä»£è¡¨ 0 ã¯ (0,1)
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC
                   âŸ¨(0,1), h10âŸ© p)
        = Quot.mk _ p
    apply Quot.sound
    -- (0/1)+ (a/b) ~ (a/b)
    -- ã“ã‚Œã¯ addRep_compat ã« rel_refl ã¨ã€(0,1) ~ (0,1) ã‚’ä½¿ãˆã°OKï¼ˆè‡ªæ˜ï¼‰
    -- ç›´æ¥ç­‰å¼ã§ã‚‚è‰¯ã„ãŒã€Rel ã§æŠ¼ã™ï¼š
    -- addRep_compat (refl, refl) ã§ã¯è¶³ã‚Šãªã„ã®ã§ã€å®Ÿéš›ã®ç­‰å¼ã§è¨¼æ˜
    -- 0/1 + a/b = (0*b + a*1)/(1*b) ~ a/b ã¯ä»£è¡¨è¨ˆç®—ã§åˆ†å­ãŒ a*b ã«ä¸€è‡´
    -- ã™ãªã‚ã¡ Rel: (a*1)*(1*b) = (a*b)*(1*1)
    -- ç›´æ¥æ›¸ãï¼š
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]

  add_zero := by
    intro x
    refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.addRep (A:=A) hC p âŸ¨(0,1), h10âŸ©)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.addRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero,
          Semiring.one_mul]
  add_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q
  nsmul := fun n x =>
    Nat.recOn n (0) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

-- ä¹—æ³•ãƒ¢ãƒã‚¤ãƒ‰ï¼ˆå¯æ›ï¼‰
instance : CommMonoid (Q (A:=A) hC) where
  mul := (Â· * Â·)
  one := (1 : Q (A:=A) hC)
  mul_assoc := by
    intro x y z
    refine Quot.induction_on x ?hx |>.trans ?_
    Â· intro p; refine Quot.induction_on y ?hy
      Â· intro q; refine Quot.induction_on z ?hz
        Â· intro r
          apply Quot.sound
          exact FracCarrier.mulRep_assoc (A:=A) hC p q r
    Â· rfl
  one_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), h10âŸ© p)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_one := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), h10âŸ©)
        = Quot.mk _ p
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.one_mul]
  mul_comm := by
    intro x y
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q
  npow := fun n x =>
    Nat.recOn n (1) (fun _ s => s * x)

/-- åˆ†é…ãƒ»é›¶å¸åã‚’æŒã¡ä¸Šã’ã¦ Semiring ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ -/
instance : Semiring (Q (A:=A) hC) where
  mul_zero := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    -- p * 0 = 0
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p âŸ¨(0,1), h10âŸ©)
        = (0 : Q (A:=A) hC)
    -- å³è¾ºã® 0 ã¯ âŸ¨(0,1),h10âŸ© ã®åŒå€¤é¡
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p âŸ¨(0,1), h10âŸ©)
        = Quot.mk _ âŸ¨(0,1), h10âŸ©
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  zero_mul := by
    intro x; refine Quot.induction_on x ?hx
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(0,1), h10âŸ© p)
        = Quot.mk _ âŸ¨(0,1), h10âŸ©
    apply Quot.sound
    unfold FracCarrier.mulRep FracCarrier.Rel FracCarrier.num FracCarrier.den
    simp [mul_comm, mul_left_comm, mul_assoc,
          Semiring.zero_mul, Semiring.mul_zero, Semiring.one_mul]
  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    -- p * (q + r) = p*q + p*r  ã‚’ `Rel` ã§ä¸»å¼µ
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r
  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?hx
    intro p; refine Quot.induction_on y ?hy
    intro q; refine Quot.induction_on z ?hz
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r

/********************* é€†å…ƒã®å­˜åœ¨ï¼šSemifield ä»•ä¸Šã’ *********************/

-- ã€Œ0 ã§ãªã„å…ƒ x ã¯ã€ä½•ã‚‰ã‹ã®ä»£è¡¨ p ã§ p.num â‰  0ã€ã‚’ä½¿ã£ã¦é€†ã‚’ç«‹ã¦ã‚‹ã€‚
-- x = [a/b]ï¼ˆbâ‰ 0ï¼‰ã§ a â‰  0 ãªã‚‰é€†ã¯ [b/a]ã€‚
-- x = 0 ã®ã¨ãï¼ˆã¤ã¾ã‚Šä»»æ„ä»£è¡¨ãŒ a=0ï¼‰ä»¥å¤–ã¯ã“ã‚Œã§ååˆ†ã€‚
-- ãã“ã§ã¾ãšã€0 åˆ¤å®šã®è£œé¡Œã‚’ä½œã‚‹ã€‚

namespace FracCarrier

/-- [a/b] = 0 ã§ã‚ã‚‹ã“ã¨ã®ä»£è¡¨ç‰ˆåˆ¤å®šï¼ša = 0 -/
lemma zero_iff_num_eq_zero (hC : Cancellative A)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p âŸ¨(0,1), by exact (show (1:A) â‰  0 from ?_)âŸ©
      â†” p.num = 0 := by
  -- ã“ã“ã§ã¯ `?_.` ã« `h10` ã‚’å…¥ã‚ŒãŸã„ã®ã§ã€å¤–å´ã§ä½¿ã†å½¢ã«æ›¸ãæ›ãˆã¾ã™ã€‚
  -- å®Ÿé‹ç”¨ã§ã¯ç›´æ¥ä½¿ã‚ãšã€ä¸‹ã® `nonzero_num_of_ne_zero` ã§ `h10` ã‚’å—ã‘æ¸¡ã—ã¾ã™ã€‚
  admit

end FracCarrier

/-- éé›¶å…ƒã¯åˆ†å­ãŒéé›¶ãªä»£è¡¨ã‚’æŒã¤ -/
lemma nonzero_num_of_ne_zero
    {x : Q (A:=A) hC} (hx : x â‰  0) :
    âˆƒ p : FracCarrier A, Quot.mk _ p = x âˆ§ p.num â‰  0 := by
  -- x ã‚’ä»£è¡¨ p ã«é™ã‚ã™ã€‚ã‚‚ã— p.num = 0 ãªã‚‰ x = 0 ã«çŸ›ç›¾ã€‚
  refine Quot.induction_on x (fun p => ?_) 
  intro p
  by_cases hp : p.num = 0
  Â· -- ã“ã®å ´åˆã€[p] = 0 ã«ãªã£ã¦ã—ã¾ã†
    have : Quot.mk _ p = (0 : Q (A:=A) hC) := by
      -- 0 ã¯ âŸ¨(0,1),h10âŸ© ã®åŒå€¤é¡
      change Quot.mk _ p = Quot.mk _ âŸ¨(0,1), h10âŸ©
      apply Quot.sound
      -- Rel: p.num*1 = 0 * p.den
      unfold FracCarrier.Rel FracCarrier.num FracCarrier.den
      simp [hp, Semiring.one_mul, Semiring.zero_mul]
    exact (hx (by simpa using this)).elim
  Â· exact âŸ¨p, rfl, hpâŸ©

/-- Q(A) ã¯ Semifieldï¼š0â‰ 1 ã¨ã€Œéé›¶ã«é€†ã€ -/
noncomputable instance : Semifield (Q (A:=A) hC) where
  -- æ—¢ã« Semiring ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã‚ã‚‹
  zero_ne_one := by
    -- 0 â‰  1 ã¯ä»£è¡¨ 0/1 ã¨ 1/1 ãŒç•°ãªã‚‹ã“ã¨ã«å¸°ç€ï¼ˆh10 ã‚’ä½¿ç”¨ï¼‰
    -- Rel ã§ç­‰ã—ã„ã¨ä»®å®šã™ã‚‹ã¨ 0=1 ã«çŸ›ç›¾
    intro h01
    -- 0 = 1 ãªã‚‰ã€ãã®ä»£è¡¨ãŒ Rel ã§ç­‰ã—ã„
    -- (0*1) * (1*1) = (1*1) * (0*1) ã‚’è¦‹ã‚‹ã¨ 0=1 ã‚’å¼·ã„ã‚‹
    have : (0 : A) = 1 := by
      -- `Quot.eqv_iff_eq` ã¯ä½¿ãˆãªã„ã®ã§ã€ç­‰ã—ã„ã¨ä»®å®šã—ãŸã‚‰ Rel ãŒæˆã‚Šç«‹ã¤ã¯ãš
      -- ã“ã“ã¯æ‰‹çŸ­ã«ï¼šã‚‚ã— 0=1 ãªã‚‰ h10 ã«åã™ã‚‹ã€ã¨ã„ã†å½¢ã«å¤‰æ›
      -- å®Ÿéš›ã«ã¯ 0=1 ã‚’å°ãä»£è¡¨è¨ˆç®—ã§ã‚‚ OK
      -- ç°¡ç•¥åŒ–ã®ãŸã‚ã«åè¨¼æ³•ï¼šh10 : 1 â‰  0
      exact (h10 (by simpa))
    -- çŸ›ç›¾
    exact (by have := this.symm; simpa using this)
  exists_inv := by
    intro x hx
    -- éé›¶ãªã‚‰ä»£è¡¨ p ã§ p.num â‰  0 ãŒå–ã‚Œã‚‹
    rcases nonzero_num_of_ne_zero (A:=A) hC h10 hx with âŸ¨p, rfl, hpâŸ©
    -- é€†ã¯ [p.den/p.num]
    refine âŸ¨
      Quot.mk _ âŸ¨(p.den, p.num), hpâŸ©,
      ?goal
    âŸ©
    -- è¨¼æ˜ï¼š [p]*[p.den/p.num] = 1
    -- ä»£è¡¨è¨ˆç®—ï¼š (p.num/p.den) * (p.den/p.num) = (p.num*p.den)/(p.den*p.num) ~ 1/1
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p âŸ¨(p.den, p.num), hpâŸ©)
        = (1 : Q (A:=A) hC)
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC
                  p âŸ¨(p.den, p.num), hpâŸ©)
        = Quot.mk _ âŸ¨(1,1), h10âŸ©
    apply Quot.sound
    -- Rel ã®å¼ã«è½ã¨ã™
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    -- (p.num*p.den) * (1*1) = (1*p.num) * (p.den*p.num)
    -- å¯æ›çµåˆã§ `ac_rfl`
    have h1 : (p.num * p.den) * (1 * 1)
            = p.num * p.den := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    have h2 : (1 * p.num) * (p.den * p.num)
            = p.num * p.den * p.num := by
      simp [Semiring.one_mul, mul_comm, mul_left_comm, mul_assoc]
    -- å·¦å³ã¨ã‚‚ p.num*p.den*p.num ã«è½ã¡ã‚‹
    simpa [h1, h2, Semiring.one_mul,
           mul_comm, mul_left_comm, mul_assoc]

end QSemiring
end TropicalGeometry




#min_imports
