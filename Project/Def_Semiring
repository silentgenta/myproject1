/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1ï¼ˆå®‹å…ˆç”Ÿã®å®šç¾©ã«å¿ å®Ÿã«å¾“ã£ãŸ(å¯æ›ãª)Semiringã®å®šç¾©ï¼‰
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

--ã¤ã„ã§ã«åŠä½“ã‚’å®šç¾©
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

--åŠ æ³•çš„å†ªç­‰ã®å®šç¾©
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

--Ex2.1.2 ğ”¹=({0,-âˆ},max,+)ã¯åŠä½“ã§ã‚ã‚‹
inductive ğ”¹ : Type
| negInf
| zero

/-
ã¤ã‘ã¦ãŠãã¨ã„ã„ã“ã¨ãŒã‚ã‚‹ã¨GPTã‹ã‚‰ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Š
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

/- åŠ æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- ä¹—æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(åŠç’°æº–åŒå‹ã®å®šç¾©)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--ä»Šå¾Œé–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã„ã¡ã„ã¡f.toFun xã¨æ›¸ã‹ãªãã‚ƒã„ã‘ãªããªã‚‹ã€‚
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

--simpã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

/-- æ’ç­‰æº–åŒå‹ -/
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

/-- æº–åŒå‹ã®åˆæˆï¼ˆ`simp` ã‚’ä½¿ã‚ãšæ˜ç¤ºçš„ã«è¨¼æ˜ï¼‰ -/
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b)
      _ = g (f a) + g (f b) := by
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

--Sâ‚ä»£æ•°ã®å®šç¾©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom

--simpç”¨


variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-ä»£æ•°æº–åŒå‹ã®å®šç¾©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A â†’ X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A â†’ Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å¯æ›å›³å¼--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g ã« a ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) h.comm

end AlgHom


/-- A-ä»£æ•°æº–åŒå‹ã®å­˜åœ¨ã®å‘½é¡Œï¼ˆPropï¼‰ï¼š
    æ—¢å­˜ã® `[Algebra X A]` ã¨ `[Algebra Y A]` ã®ã‚‚ã¨ã§
    ã€Œ`âˆƒ Î¨, g = Î¨ âˆ˜ f`ã€ã‚’ä¸»å¼µã™ã‚‹ã€‚ -/
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

/-- 3å¼•æ•°ã®å­˜åœ¨å‘½é¡Œã®ãŸã‚ã®**å°‚ç”¨ã‚¹ã‚³ãƒ¼ãƒ—è¨˜æ³•**ã€‚
    `open scoped TGAlgRel` ã§ `AlgRel A X Y` ã¨æ›¸ã‘ã‚‹ã€‚ -/
scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å…·ä½“çš„ãª Î¨ ã¨å¯æ›æ€§ã‹ã‚‰ã€å­˜åœ¨å‘½é¡Œã‚’å°å…¥ã€‚ -/
theorem intro
  (Î¨ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Î¨
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  âŸ¨Î¨, hâŸ©

/-- å­˜åœ¨å‘½é¡Œã‹ã‚‰ **ã²ã¨ã¤**ã® Î¨ ã‚’ï¼ˆé¸æŠã§ï¼‰å–ã‚Šå‡ºã™ã€‚ -/
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

/-- å–ã‚Šå‡ºã—ãŸ Î¨ ã¯ä¸‰è§’å½¢ã‚’å¯æ›ã«ã™ã‚‹ã€‚ -/
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

/-- å¯æ›æ€§ã®ç‚¹ã”ã¨ç‰ˆã€‚ -/
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- `comm` ã‚’å–ã‚Šå‡ºã—ã¦ `congrArg` ã‚’é©ç”¨ã™ã‚‹ã ã‘
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) hc

end AlgebraRel

-- A-ä»£æ•°åŒå‹ã®å®šç¾©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- äº’ã„ã«é€†ï¼ˆAlgHom ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ toHom ã‚’ä¸€åº¦ã ã‘å–ã‚Šå‡ºã—ã¦ä½¿ã†ï¼‰
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- åŒå‹ã®é †æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ -/
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
/-- åŒå‹ã®é€†æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ -/
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

/-- å·¦é€†ï¼ˆç‚¹ã”ã¨ç‰ˆï¼‰ï¼š`e.inv âˆ˜ e` ã¯æ’ç­‰ã€‚ -/
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- `left_inv : comp inv to = id` ã« `x` ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism X X) => Ï† x) e.left_inv

/-- å³é€†ï¼ˆç‚¹ã”ã¨ç‰ˆï¼‰ï¼š`e âˆ˜ e.inv` ã¯æ’ç­‰ã€‚ -/
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- `right_inv : comp to inv = id` ã« `y` ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism Y Y) => Ï† y) e.right_inv

/-- å¯¾ç§°æ€§ï¼ˆé€†åŒå‹ï¼‰ã€‚ -/
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso


/-! ğ”¹ ã‚’ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã® `Semiring` ã«ã™ã‚‹ï¼ˆæœªå®šç¾©ãªã‚‰æœ‰åŠ¹åŒ–ï¼‰ -/
instance : Semiring ğ”¹ where
  mul_zero := by intro a; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl

/-- ğ”¹ ã§ã¯ `1 + 1 = 1`ï¼ˆå®šç¾©é€šã‚Šï¼‰ -/
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl

/-- `A` ãŒåŠ æ³•å†ªç­‰ãªã‚‰ï¼Œæ¨™æº–å†™åƒ `ğ”¹ â†’ A` ã‚’åŠç’°æº–åŒå‹ã¨ã—ã¦æ§‹æˆã€‚ -/
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1,
  map_add := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 + 0
      exact (zero_add (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š1 = 0 + 1
      exact (zero_add (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š1 = 1 + 0
      exact (add_zero (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 + 1ï¼ˆå†ªç­‰æ€§ï¼‰
      exact (h (1 : A)).symm,
  map_mul := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 * 1
      exact (one_mul (1 : A)).symm,
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 ã€ŒA ãŒåŠ æ³•å†ªç­‰ã€â†”ã€ŒA ãŒ ğ”¹-ä»£æ•°ï¼ˆå­˜åœ¨ã™ã‚‹ï¼‰ã€ -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· -- (â†’) åŠ æ³•å†ªç­‰ â‡’ ğ”¹-ä»£æ•°ãŒå­˜åœ¨
    intro h
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©
  Â· -- (â†) ğ”¹-ä»£æ•°ãŒå­˜åœ¨ â‡’ åŠ æ³•å†ªç­‰
    intro hAlg
    rcases hAlg with âŸ¨instâŸ©
    -- Ïˆ : ğ”¹ â†’ A
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    -- 1_A = 1_A + 1_A
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)      -- Ïˆ(1+1) = Ïˆ1 + Ïˆ1
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    -- ä»»æ„ã® a ã«ã¤ã„ã¦ a + a = a
    intro a
    -- ã¾ãš a*1 = a*1 + a*1 ã‚’ä½œã‚‹ï¼ˆå·¦åˆ†é…ã¨ h11Aï¼‰
    have hmul : a * 1 = a * 1 + a * 1 := by
      -- a*(1+1) = a*1 + a*1 ã«å¯¾ã—ã¦ï¼Œ(1+1) â†’ 1 ã¸æ›¸ãæ›ãˆã‚‹
     simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- ã‚ã¨ã¯ mul_one ã§ä»•ä¸Šã’
    -- ï¼ˆå‘ãã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¯¾ç§°ã‚’å–ã‚‹ï¼‰
    have : a + a = a := by
      simpa [mul_one] using hmul.symm
    exact this

end TropicalGeometry

#min_imports
