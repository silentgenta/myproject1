/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1（宋先生の定義に忠実に従った(可換な)Semiringの定義）
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : ∀ a : R, a * 0 = 0
  zero_mul : ∀ a : R, 0 * a = 0
  left_distrib  : ∀ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

--ついでに半体を定義
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) ≠ 1)
  (exists_inv  : ∀ {a : R}, a ≠ 0 → ∃ b : R, a * b = 1)

--加法的冪等の定義
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  ∀ a : R, a + a = a

--Ex2.1.2 𝔹=({0,-∞},max,+)は半体である
inductive 𝔹 : Type
| negInf
| zero

/-
つけておくといいことがあるとGPTからアドバイスあり
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero 𝔹 := ⟨𝔹.negInf⟩
instance : One  𝔹 := ⟨𝔹.zero⟩

instance : Add 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zero⟩

instance : Mul 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInf⟩

/- 加法について可換モノイド -/
instance : AddCommMonoid 𝔹 where
  add := (·+·)
  zero := (0 : 𝔹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- 乗法について可換モノイド -/
instance : CommMonoid 𝔹 where
  mul := (·*·)
  one := (1 : 𝔹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(半環準同型の定義)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 → S2
  map_add : ∀ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : ∀ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--今後関数として使えるようにする。これがないといちいちf.toFun xと書かなきゃいけなくなる。
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 → S2) where
  coe f := f.toFun

--simpを使えるように
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

/-- 恒等準同型 -/
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

/-- 準同型の合成（`simp` を使わず明示的に証明） -/
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b)
      _ = g (f a) + g (f b) := by
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

--S₁代数の定義
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Ψ : SemiringHomomorphism B A) : Algebra A B :=
  ⟨Ψ⟩

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom

--simp用


variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-代数準同型の定義
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A → X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A → Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 可換図式--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g に a を適用
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) h.comm

end AlgHom


/-- A-代数準同型の存在の命題（Prop）：
    既存の `[Algebra X A]` と `[Algebra Y A]` のもとで
    「`∃ Ψ, g = Ψ ∘ f`」を主張する。 -/
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  ∃ (Ψ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Ψ
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

/-- 3引数の存在命題のための**専用スコープ記法**。
    `open scoped TGAlgRel` で `AlgRel A X Y` と書ける。 -/
scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 具体的な Ψ と可換性から、存在命題を導入。 -/
theorem intro
  (Ψ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Ψ
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  ⟨Ψ, h⟩

/-- 存在命題から **ひとつ**の Ψ を（選択で）取り出す。 -/
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

/-- 取り出した Ψ は三角形を可換にする。 -/
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

/-- 可換性の点ごと版。 -/
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- `comm` を取り出して `congrArg` を適用するだけ
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) hc

end AlgebraRel

-- A-代数同型の定義
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- 互いに逆（AlgHom のフィールド toHom を一度だけ取り出して使う）
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 同型の順方向の底の準同型を取り出す。 -/
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
/-- 同型の逆方向の底の準同型を取り出す。 -/
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

/-- 左逆（点ごと版）：`e.inv ∘ e` は恒等。 -/
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- `left_inv : comp inv to = id` に `x` を適用
  exact congrArg (fun (φ : SemiringHomomorphism X X) => φ x) e.left_inv

/-- 右逆（点ごと版）：`e ∘ e.inv` は恒等。 -/
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- `right_inv : comp to inv = id` に `y` を適用
  exact congrArg (fun (φ : SemiringHomomorphism Y Y) => φ y) e.right_inv

/-- 対称性（逆同型）。 -/
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso


/-! 𝔹 をこのファイルの `Semiring` にする（未定義なら有効化） -/
instance : Semiring 𝔹 where
  mul_zero := by intro a; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl

/-- 𝔹 では `1 + 1 = 1`（定義通り） -/
@[simp] lemma B_one_add_one : ((1 : 𝔹) + (1 : 𝔹)) = (1 : 𝔹) := rfl

/-- `A` が加法冪等なら，標準写像 `𝔹 → A` を半環準同型として構成。 -/
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism 𝔹 A :=
{ toFun := fun x =>
    match x with
    | 𝔹.negInf => 0
    | 𝔹.zero   => 1,
  map_add := by
    intro x y
    cases x <;> cases y
    · -- (⊥, ⊥)：0 = 0 + 0
      exact (zero_add (0 : A)).symm
    · -- (⊥, 0)：1 = 0 + 1
      exact (zero_add (1 : A)).symm
    · -- (0, ⊥)：1 = 1 + 0
      exact (add_zero (1 : A)).symm
    · -- (0, 0)：1 = 1 + 1（冪等性）
      exact (h (1 : A)).symm,
  map_mul := by
    intro x y
    cases x <;> cases y
    · -- (⊥, ⊥)：0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    · -- (⊥, 0)：0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    · -- (0, ⊥)：0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    · -- (0, 0)：1 = 1 * 1
      exact (one_mul (1 : A)).symm,
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 「A が加法冪等」↔「A が 𝔹-代数（存在する）」 -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A ↔ Nonempty (Algebra A 𝔹) := by
  constructor
  · -- (→) 加法冪等 ⇒ 𝔹-代数が存在
    intro h
    exact ⟨Algebra.ofHom (boolHomOfAddIdem A h)⟩
  · -- (←) 𝔹-代数が存在 ⇒ 加法冪等
    intro hAlg
    rcases hAlg with ⟨inst⟩
    -- ψ : 𝔹 → A
    let ψ : SemiringHomomorphism 𝔹 A := inst.hom
    -- 1_A = 1_A + 1_A
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := ψ.map_add (1 : 𝔹) (1 : 𝔹)      -- ψ(1+1) = ψ1 + ψ1
      have h1 : ψ 1 = ψ 1 + ψ 1 := by
        simpa [B_one_add_one] using h0
      simpa [ψ.map_one] using h1
    -- 任意の a について a + a = a
    intro a
    -- まず a*1 = a*1 + a*1 を作る（左分配と h11A）
    have hmul : a * 1 = a * 1 + a * 1 := by
      -- a*(1+1) = a*1 + a*1 に対して，(1+1) → 1 へ書き換える
     simpa [← h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- あとは mul_one で仕上げ
    -- （向きを合わせるために対称を取る）
    have : a + a = a := by
      simpa [mul_one] using hmul.symm
    exact this



/-! # 「B 代数（= 加法冪等半環）」で定める順序 `≤ₐ` の基本性質 -/

section OrderFromAddIdem

variable (A : Type u) [Semiring A]

/-- 定義：`a ≤ₐ b` を `a + b = b` とする。 -/
def leA (a b : A) : Prop := a + b = b

/-- 反射律：`a ≤ₐ a`。ここだけ加法冪等性を使う。 -/
theorem leA_refl (h : AddIdempotent A) (a : A) : leA (A:=A) a a := by
  unfold leA
  simpa using h a

/-- 推移律：`a ≤ₐ b → b ≤ₐ c → a ≤ₐ c`。 -/
theorem leA_trans {a b c : A}
    (hab : leA (A:=A) a b) (hbc : leA (A:=A) b c) :
    leA (A:=A) a c := by
  unfold leA at hab hbc ⊢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

/-- 反対称律：`a ≤ₐ b ∧ b ≤ₐ a → a = b`。 -/
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

/-- `0` は最小元：`0 ≤ₐ a`。 -/
theorem bot_leA (a : A) : leA (A:=A) (0 : A) a := by
  unfold leA
  simp [zero_add a]

/-- 左からの乗法は単調：`a ≤ₐ b → c*a ≤ₐ c*b`。 -/
theorem mul_left_mono_leA {a b c : A}
    (hab : leA (A:=A) a b) :
    leA (A:=A) (c * a) (c * b) := by
  unfold leA at hab ⊢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem




/-! ## まとめ（図の主張と対応）

- `leA_refl / leA_trans / leA_antisymm` で `≤ₐ` が半順序。
- `bot_leA` により `0` はこの順序の最小元。
- `mul_left_mono_leA` により，任意の `c` で左からの乗法は単調。

ここでの「B 代数」は（先に示した）`AddIdempotent A` に同値な構造だと見做しているので，
仮定は `h : AddIdempotent A` に集約している。
-/

end TropicalGeometry

universe u

namespace TropicalGeometry

/-- 半環 `A` が**消去的 (cancellative)** であるとは，
`∀ a b c, a*b = a*c → (a = 0 ∨ b = c)` が成り立つこと。 -/
def Cancellative (A : Type u) [Semiring A] : Prop :=
  ∀ ⦃a b c : A⦄, a * b = a * c → a = (0 : A) ∨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

/-- 便利補題：`a ≠ 0` の下での左消去形。 -/
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a ≠ (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  · exact (ha hzero).elim
  · exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

/-- 分数の台集合：分母が 0 でない組 `(a,b)`。 -/
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A × A // p.2 ≠ (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

/-- 分子 / 分母（記号短縮） -/
def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b ≠ 0) :
    num (A:=A) ⟨(a,b), hb⟩ = a := rfl
@[simp] lemma den_mk (a b : A) (hb : b ≠ 0) :
    den (A:=A) ⟨(a,b), hb⟩ = b := rfl
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p ≠ 0 := p.2

/-- 同値関係の元の関係：`(a,b) ∼ (a',b') :≡ a*b' = a'*b`。 -/
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

/-- 反射律。 -/
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

/-- 対称律。 -/
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

/-- 推移律（`A` が消去的であることを使用）。 -/
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q → Rel (A:=A) q r → Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q ≠ (0 : A) := den_ne_zero (A:=A) q

  -- ① (hpq) を右から r.den で掛け、形を `q.den * (p.num * r.den) = r.den * (q.num * p.den)` に整える
  have h1' :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- ② (hqr) を右から p.den で掛け、形を `q.den * (r.num * p.den) = r.den * (q.num * p.den)` に整える
  have h2' :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- ③ 同じ右辺を経由して `q.den` を左から消去
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1'.trans h2'.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


/-- Lem2.1.9-a`Rel` は（消去性の仮定の下で）同値関係になる。  
    インスタンスではなく，引数つきの `Setoid` として定義。 -/
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    ⟨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) ⟩

end FracCarrier
end TropicalGeometry















#min_imports
