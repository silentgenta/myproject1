/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1ï¼ˆå®‹å…ˆç”Ÿã®å®šç¾©ã«å¿ å®Ÿã«å¾“ã£ãŸ(å¯æ›ãª)Semiringã®å®šç¾©ï¼‰
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

--ã¤ã„ã§ã«åŠä½“ã‚’å®šç¾©
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

--åŠ æ³•çš„å†ªç­‰ã®å®šç¾©
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

--Ex2.1.2 ğ”¹=({0,-âˆ},max,+)ã¯åŠä½“ã§ã‚ã‚‹
inductive ğ”¹ : Type
| negInf
| zero

/-
ã¤ã‘ã¦ãŠãã¨ã„ã„ã“ã¨ãŒã‚ã‚‹ã¨GPTã‹ã‚‰ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Š
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

/- åŠ æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- ä¹—æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(åŠç’°æº–åŒå‹ã®å®šç¾©)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--ä»Šå¾Œé–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã„ã¡ã„ã¡f.toFun xã¨æ›¸ã‹ãªãã‚ƒã„ã‘ãªããªã‚‹ã€‚
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

--simpã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

/-- æ’ç­‰æº–åŒå‹ -/
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

/-- æº–åŒå‹ã®åˆæˆï¼ˆ`simp` ã‚’ä½¿ã‚ãšæ˜ç¤ºçš„ã«è¨¼æ˜ï¼‰ -/
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b)
      _ = g (f a) + g (f b) := by
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

--Sâ‚ä»£æ•°ã®å®šç¾©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom

--simpç”¨


variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-ä»£æ•°æº–åŒå‹ã®å®šç¾©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A â†’ X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A â†’ Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å¯æ›å›³å¼--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g ã« a ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) h.comm

end AlgHom


/-- A-ä»£æ•°æº–åŒå‹ã®å­˜åœ¨ã®å‘½é¡Œï¼ˆPropï¼‰ï¼š
    æ—¢å­˜ã® `[Algebra X A]` ã¨ `[Algebra Y A]` ã®ã‚‚ã¨ã§
    ã€Œ`âˆƒ Î¨, g = Î¨ âˆ˜ f`ã€ã‚’ä¸»å¼µã™ã‚‹ã€‚ -/
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

/-- 3å¼•æ•°ã®å­˜åœ¨å‘½é¡Œã®ãŸã‚ã®**å°‚ç”¨ã‚¹ã‚³ãƒ¼ãƒ—è¨˜æ³•**ã€‚
    `open scoped TGAlgRel` ã§ `AlgRel A X Y` ã¨æ›¸ã‘ã‚‹ã€‚ -/
scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å…·ä½“çš„ãª Î¨ ã¨å¯æ›æ€§ã‹ã‚‰ã€å­˜åœ¨å‘½é¡Œã‚’å°å…¥ã€‚ -/
theorem intro
  (Î¨ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Î¨
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  âŸ¨Î¨, hâŸ©

/-- å­˜åœ¨å‘½é¡Œã‹ã‚‰ **ã²ã¨ã¤**ã® Î¨ ã‚’ï¼ˆé¸æŠã§ï¼‰å–ã‚Šå‡ºã™ã€‚ -/
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

/-- å–ã‚Šå‡ºã—ãŸ Î¨ ã¯ä¸‰è§’å½¢ã‚’å¯æ›ã«ã™ã‚‹ã€‚ -/
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

/-- å¯æ›æ€§ã®ç‚¹ã”ã¨ç‰ˆã€‚ -/
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- `comm` ã‚’å–ã‚Šå‡ºã—ã¦ `congrArg` ã‚’é©ç”¨ã™ã‚‹ã ã‘
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) hc

end AlgebraRel

-- A-ä»£æ•°åŒå‹ã®å®šç¾©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- äº’ã„ã«é€†ï¼ˆAlgHom ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ toHom ã‚’ä¸€åº¦ã ã‘å–ã‚Šå‡ºã—ã¦ä½¿ã†ï¼‰
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- åŒå‹ã®é †æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ -/
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
/-- åŒå‹ã®é€†æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ -/
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

/-- å·¦é€†ï¼ˆç‚¹ã”ã¨ç‰ˆï¼‰ï¼š`e.inv âˆ˜ e` ã¯æ’ç­‰ã€‚ -/
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- `left_inv : comp inv to = id` ã« `x` ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism X X) => Ï† x) e.left_inv

/-- å³é€†ï¼ˆç‚¹ã”ã¨ç‰ˆï¼‰ï¼š`e âˆ˜ e.inv` ã¯æ’ç­‰ã€‚ -/
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- `right_inv : comp to inv = id` ã« `y` ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism Y Y) => Ï† y) e.right_inv

/-- å¯¾ç§°æ€§ï¼ˆé€†åŒå‹ï¼‰ã€‚ -/
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso


/-! ğ”¹ ã‚’ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã® `Semiring` ã«ã™ã‚‹ï¼ˆæœªå®šç¾©ãªã‚‰æœ‰åŠ¹åŒ–ï¼‰ -/
instance : Semiring ğ”¹ where
  mul_zero := by intro a; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl

/-- ğ”¹ ã§ã¯ `1 + 1 = 1`ï¼ˆå®šç¾©é€šã‚Šï¼‰ -/
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl

/-- `A` ãŒåŠ æ³•å†ªç­‰ãªã‚‰ï¼Œæ¨™æº–å†™åƒ `ğ”¹ â†’ A` ã‚’åŠç’°æº–åŒå‹ã¨ã—ã¦æ§‹æˆã€‚ -/
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1,
  map_add := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 + 0
      exact (zero_add (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š1 = 0 + 1
      exact (zero_add (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š1 = 1 + 0
      exact (add_zero (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 + 1ï¼ˆå†ªç­‰æ€§ï¼‰
      exact (h (1 : A)).symm,
  map_mul := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 * 1
      exact (one_mul (1 : A)).symm,
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 ã€ŒA ãŒåŠ æ³•å†ªç­‰ã€â†”ã€ŒA ãŒ ğ”¹-ä»£æ•°ï¼ˆå­˜åœ¨ã™ã‚‹ï¼‰ã€ -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· -- (â†’) åŠ æ³•å†ªç­‰ â‡’ ğ”¹-ä»£æ•°ãŒå­˜åœ¨
    intro h
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©
  Â· -- (â†) ğ”¹-ä»£æ•°ãŒå­˜åœ¨ â‡’ åŠ æ³•å†ªç­‰
    intro hAlg
    rcases hAlg with âŸ¨instâŸ©
    -- Ïˆ : ğ”¹ â†’ A
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    -- 1_A = 1_A + 1_A
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)      -- Ïˆ(1+1) = Ïˆ1 + Ïˆ1
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    -- ä»»æ„ã® a ã«ã¤ã„ã¦ a + a = a
    intro a
    -- ã¾ãš a*1 = a*1 + a*1 ã‚’ä½œã‚‹ï¼ˆå·¦åˆ†é…ã¨ h11Aï¼‰
    have hmul : a * 1 = a * 1 + a * 1 := by
      -- a*(1+1) = a*1 + a*1 ã«å¯¾ã—ã¦ï¼Œ(1+1) â†’ 1 ã¸æ›¸ãæ›ãˆã‚‹
     simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- ã‚ã¨ã¯ mul_one ã§ä»•ä¸Šã’
    -- ï¼ˆå‘ãã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¯¾ç§°ã‚’å–ã‚‹ï¼‰
    have : a + a = a := by
      simpa [mul_one] using hmul.symm
    exact this



/-! # ã€ŒB ä»£æ•°ï¼ˆ= åŠ æ³•å†ªç­‰åŠç’°ï¼‰ã€ã§å®šã‚ã‚‹é †åº `â‰¤â‚` ã®åŸºæœ¬æ€§è³ª -/

section OrderFromAddIdem

variable (A : Type u) [Semiring A]

/-- å®šç¾©ï¼š`a â‰¤â‚ b` ã‚’ `a + b = b` ã¨ã™ã‚‹ã€‚ -/
def leA (a b : A) : Prop := a + b = b

/-- åå°„å¾‹ï¼š`a â‰¤â‚ a`ã€‚ã“ã“ã ã‘åŠ æ³•å†ªç­‰æ€§ã‚’ä½¿ã†ã€‚ -/
theorem leA_refl (h : AddIdempotent A) (a : A) : leA (A:=A) a a := by
  unfold leA
  simpa using h a

/-- æ¨ç§»å¾‹ï¼š`a â‰¤â‚ b â†’ b â‰¤â‚ c â†’ a â‰¤â‚ c`ã€‚ -/
theorem leA_trans {a b c : A}
    (hab : leA (A:=A) a b) (hbc : leA (A:=A) b c) :
    leA (A:=A) a c := by
  unfold leA at hab hbc âŠ¢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

/-- åå¯¾ç§°å¾‹ï¼š`a â‰¤â‚ b âˆ§ b â‰¤â‚ a â†’ a = b`ã€‚ -/
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

/-- `0` ã¯æœ€å°å…ƒï¼š`0 â‰¤â‚ a`ã€‚ -/
theorem bot_leA (a : A) : leA (A:=A) (0 : A) a := by
  unfold leA
  simp [zero_add a]

/-- å·¦ã‹ã‚‰ã®ä¹—æ³•ã¯å˜èª¿ï¼š`a â‰¤â‚ b â†’ c*a â‰¤â‚ c*b`ã€‚ -/
theorem mul_left_mono_leA {a b c : A}
    (hab : leA (A:=A) a b) :
    leA (A:=A) (c * a) (c * b) := by
  unfold leA at hab âŠ¢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem




/-! ## ã¾ã¨ã‚ï¼ˆå›³ã®ä¸»å¼µã¨å¯¾å¿œï¼‰

- `leA_refl / leA_trans / leA_antisymm` ã§ `â‰¤â‚` ãŒåŠé †åºã€‚
- `bot_leA` ã«ã‚ˆã‚Š `0` ã¯ã“ã®é †åºã®æœ€å°å…ƒã€‚
- `mul_left_mono_leA` ã«ã‚ˆã‚Šï¼Œä»»æ„ã® `c` ã§å·¦ã‹ã‚‰ã®ä¹—æ³•ã¯å˜èª¿ã€‚

ã“ã“ã§ã®ã€ŒB ä»£æ•°ã€ã¯ï¼ˆå…ˆã«ç¤ºã—ãŸï¼‰`AddIdempotent A` ã«åŒå€¤ãªæ§‹é€ ã ã¨è¦‹åšã—ã¦ã„ã‚‹ã®ã§ï¼Œ
ä»®å®šã¯ `h : AddIdempotent A` ã«é›†ç´„ã—ã¦ã„ã‚‹ã€‚
-/

end TropicalGeometry

universe u

namespace TropicalGeometry

/-- åŠç’° `A` ãŒ**æ¶ˆå»çš„ (cancellative)** ã§ã‚ã‚‹ã¨ã¯ï¼Œ
`âˆ€ a b c, a*b = a*c â†’ (a = 0 âˆ¨ b = c)` ãŒæˆã‚Šç«‹ã¤ã“ã¨ã€‚ -/
def Cancellative (A : Type u) [Semiring A] : Prop :=
  âˆ€ â¦ƒa b c : Aâ¦„, a * b = a * c â†’ a = (0 : A) âˆ¨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

/-- ä¾¿åˆ©è£œé¡Œï¼š`a â‰  0` ã®ä¸‹ã§ã®å·¦æ¶ˆå»å½¢ã€‚ -/
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a â‰  (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  Â· exact (ha hzero).elim
  Â· exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

/-- åˆ†æ•°ã®å°é›†åˆï¼šåˆ†æ¯ãŒ 0 ã§ãªã„çµ„ `(a,b)`ã€‚ -/
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A Ã— A // p.2 â‰  (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

/-- åˆ†å­ / åˆ†æ¯ï¼ˆè¨˜å·çŸ­ç¸®ï¼‰ -/
def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b â‰  0) :
    num (A:=A) âŸ¨(a,b), hbâŸ© = a := rfl
@[simp] lemma den_mk (a b : A) (hb : b â‰  0) :
    den (A:=A) âŸ¨(a,b), hbâŸ© = b := rfl
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p â‰  0 := p.2

/-- åŒå€¤é–¢ä¿‚ã®å…ƒã®é–¢ä¿‚ï¼š`(a,b) âˆ¼ (a',b') :â‰¡ a*b' = a'*b`ã€‚ -/
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

/-- åå°„å¾‹ã€‚ -/
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

/-- å¯¾ç§°å¾‹ã€‚ -/
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

/-- æ¨ç§»å¾‹ï¼ˆ`A` ãŒæ¶ˆå»çš„ã§ã‚ã‚‹ã“ã¨ã‚’ä½¿ç”¨ï¼‰ã€‚ -/
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q r â†’ Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q â‰  (0 : A) := den_ne_zero (A:=A) q

  -- â‘  (hpq) ã‚’å³ã‹ã‚‰ r.den ã§æ›ã‘ã€å½¢ã‚’ `q.den * (p.num * r.den) = r.den * (q.num * p.den)` ã«æ•´ãˆã‚‹
  have h1' :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- â‘¡ (hqr) ã‚’å³ã‹ã‚‰ p.den ã§æ›ã‘ã€å½¢ã‚’ `q.den * (r.num * p.den) = r.den * (q.num * p.den)` ã«æ•´ãˆã‚‹
  have h2' :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- â‘¢ åŒã˜å³è¾ºã‚’çµŒç”±ã—ã¦ `q.den` ã‚’å·¦ã‹ã‚‰æ¶ˆå»
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1'.trans h2'.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


/-- Lem2.1.9-a`Rel` ã¯ï¼ˆæ¶ˆå»æ€§ã®ä»®å®šã®ä¸‹ã§ï¼‰åŒå€¤é–¢ä¿‚ã«ãªã‚‹ã€‚  
    ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ãªãï¼Œå¼•æ•°ã¤ãã® `Setoid` ã¨ã—ã¦å®šç¾©ã€‚ -/
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    âŸ¨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) âŸ©

end FracCarrier
end TropicalGeometry















#min_imports
