/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1ï¼ˆå®‹å…ˆç”Ÿã®å®šç¾©ã«å¿ å®Ÿã«å¾“ã£ãŸ(å¯æ›ãª)Semiringã®å®šç¾©ï¼‰
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

--ã¤ã„ã§ã«åŠä½“ã‚’å®šç¾©
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

--åŠ æ³•çš„å†ªç­‰ã®å®šç¾©
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

--Ex2.1.2 ğ”¹=({0,-âˆ},max,+)ã¯åŠä½“ã§ã‚ã‚‹
inductive ğ”¹ : Type
| negInf
| zero

/-
ã¤ã‘ã¦ãŠãã¨ã„ã„ã“ã¨ãŒã‚ã‚‹ã¨GPTã‹ã‚‰ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Š
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

/- åŠ æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- ä¹—æ³•ã«ã¤ã„ã¦å¯æ›ãƒ¢ãƒã‚¤ãƒ‰ -/
instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(åŠç’°æº–åŒå‹ã®å®šç¾©)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--ä»Šå¾ŒãŸã ã®æ§‹é€ ã ã£ã¦Semiringhomomorphismã‚’é–¢æ•°ã¨ã—ã¦ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã„ã¡ã„ã¡f.toFun xã¨æ›¸ã‹ãªãã‚ƒã„ã‘ãªããªã‚‹ã€‚
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

--simpã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

--æ’ç­‰æº–åŒå‹ã®å®šç¾©
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl



variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--æº–åŒå‹ã®åˆæˆã®å®šç¾©ã€‚åŠç’°æº–åŒå‹ã«å¿…è¦ãªï¼•è¦ç´ ã‚’é †ã«è¨¼æ˜
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArgã¯ä¸¡è¾ºã«åŒã˜é–¢æ•°ã‚’é©ç”¨ã—ã¦ã‚ˆã„ã¨ã„ã†è£œé¡Œã€‚f.map_addã®ä¸¡è¾ºã«gã‚’é©ç”¨ã—ãŸã¨ã„ã†ã“ã¨
      _ = g (f a) + g (f b) := by --_ã¯g (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

--Sâ‚ä»£æ•°ã®å®šç¾©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©
--semiringhomoã«ã¯åå‰ã®ã¤ã„ã¦ã„ãªã„é–¢æ•°ãŒã‚ã‚‹ã®ã§ãã‚Œã‚’Î¨ã¨åä»˜ã‘ã‚‹ã€‚

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--Aã¨Bã®é–“ã«å¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’ä¸€ã¤å–ã‚Šå‡ºã™ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚reducibleã«ã™ã‚‹ã“ã¨ã§algeMapã‚’ä½¿ã†ã¨è‡ªå‹•ã§h.homã®ã‚ˆã†ãªå¿…ãšå­˜åœ¨ã™ã‚‹åŠç’°æº–åŒå‹ã‚’å‘¼ã³å‡ºã—ã¦ãã‚Œã‚‹ã€‚

--simpç”¨
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-ä»£æ•°æº–åŒå‹ã®å®šç¾©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A â†’ X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A â†’ Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- å¯æ›å›³å¼--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g ã« a ã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) h.comm

end AlgHom


--A-ä»£æ•°æº–åŒå‹ã®å­˜åœ¨
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--å…·ä½“çš„ãª Î¨ ã¨å¯æ›æ€§
theorem intro
  (Î¨ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Î¨
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  âŸ¨Î¨, hâŸ©

--ã²ã¨ã¤Î¨ã‚’å–ã‚Šå‡ºã™ã€‚ 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

--å–ã‚Šå‡ºã—ãŸÎ¨ãŒå›³å¼ã‚’å¯æ›ã«ã™ã‚‹ã€‚ 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--å¯æ›æ€§ã®ç‚¹ã”ã¨ver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- commã‚’å–ã‚Šå‡ºã—ã¦congrArgã‚’é©ç”¨ã™ã‚‹ã ã‘
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (Ï† : SemiringHomomorphism A Y) => Ï† a) hc

end AlgebraRel

-- A-ä»£æ•°åŒå‹ã®å®šç¾©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- äº’ã„ã«é€†ï¼ˆAlgHom ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ toHom ã‚’ä¸€åº¦ã ã‘å–ã‚Šå‡ºã—ã¦ä½¿ã†ï¼‰
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- åŒå‹ã®é †æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- åŒå‹ã®é€†æ–¹å‘ã®åº•ã®æº–åŒå‹ã‚’å–ã‚Šå‡ºã™ã€‚ 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv âˆ˜ eã¯identity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = idã«xã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism X X) => Ï† x) e.left_inv

--e âˆ˜ e.invã¯identity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = idã«yã‚’é©ç”¨
  exact congrArg (fun (Ï† : SemiringHomomorphism Y Y) => Ï† y) e.right_inv

--å¯¾ç§°æ€§
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--ğ”¹ã®å°å…¥
instance : Semiring ğ”¹ where
  mul_zero := by intro a; cases a <;> rfl
  zero_mul := by intro a; cases a <;> rfl
  left_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl

--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl

--AãŒåŠ æ³•å†ªç­‰ã®ã¨ãï¼Œğ”¹ â†’ Aã§åŠç’°æº–åŒå‹ã¨ãªã‚‹
def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1,
  map_add := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 + 0
      exact (zero_add (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š1 = 0 + 1
      exact (zero_add (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š1 = 1 + 0
      exact (add_zero (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 + 1ï¼ˆå†ªç­‰æ€§ï¼‰
      exact (h (1 : A)).symm,
  map_mul := by
    intro x y
    cases x <;> cases y
    Â· -- (âŠ¥, âŠ¥)ï¼š0 = 0 * 0
      exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    Â· -- (âŠ¥, 0)ï¼š0 = 0 * 1
      exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    Â· -- (0, âŠ¥)ï¼š0 = 1 * 0
      exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    Â· -- (0, 0)ï¼š1 = 1 * 1
      exact (one_mul (1 : A)).symm,
  map_zero := rfl,
  map_one  := rfl }


/--Lemma2.1.5 ã€ŒA ãŒåŠ æ³•å†ªç­‰ã€â†”ã€ŒA ãŒ ğ”¹-ä»£æ•°ï¼ˆå­˜åœ¨ã™ã‚‹ï¼‰ã€ -/
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· -- (â†’) åŠ æ³•å†ªç­‰ â‡’ ğ”¹-ä»£æ•°ãŒå­˜åœ¨
    intro h
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©
  Â· -- (â†) ğ”¹-ä»£æ•°ãŒå­˜åœ¨ â‡’ åŠ æ³•å†ªç­‰
    intro hAlg
    rcases hAlg with âŸ¨instâŸ©
    -- Ïˆ : ğ”¹ â†’ A
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    -- 1_A = 1_A + 1_A
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)      -- Ïˆ(1+1) = Ïˆ1 + Ïˆ1
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    -- ä»»æ„ã® a ã«ã¤ã„ã¦ a + a = a
    intro a
    -- ã¾ãš a*1 = a*1 + a*1 ã‚’ä½œã‚‹ï¼ˆå·¦åˆ†é…ã¨ h11Aï¼‰
    have hmul : a * 1 = a * 1 + a * 1 := by
      -- a*(1+1) = a*1 + a*1 ã«å¯¾ã—ã¦ï¼Œ(1+1) â†’ 1 ã¸æ›¸ãæ›ãˆã‚‹
     simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)

    -- ã‚ã¨ã¯ mul_one ã§ä»•ä¸Šã’
    -- ï¼ˆå‘ãã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¯¾ç§°ã‚’å–ã‚‹ï¼‰
    have : a + a = a := by
      simpa [mul_one] using hmul.symm
    exact this



--â‰¤â‚ã®å®šç¾©

section OrderFromAddIdem

variable (A : Type u) [Semiring A]

--a â‰¤â‚ bã‚’a + b = bã¨ã™ã‚‹ã€‚
def leA (a b : A) : Prop := a + b = b

--åå°„å¾‹
theorem leA_refl (h : AddIdempotent A) (a : A) : leA (A:=A) a a := by
  unfold leA
  simpa using h a

--æ¨ç§»å¾‹
theorem leA_trans {a b c : A}
    (hab : leA (A:=A) a b) (hbc : leA (A:=A) b c) :
    leA (A:=A) a c := by
  unfold leA at hab hbc âŠ¢
  have t1 : a + c = a + (b + c) := by simp [hbc]
  have t2 : a + (b + c) = (a + b) + c := by simp [add_assoc]
  have t3 : (a + b) + c = b + c := by simp [hab]
  exact t1.trans (t2.trans (t3.trans hbc))

--åå¯¾ç§°å¾‹
theorem leA_antisymm {a b : A}
    (hab : leA (A:=A) a b) (hba : leA (A:=A) b a) :
    a = b := by
  unfold leA at hab hba
  have : a = a + b := by simpa [add_comm] using hba.symm
  exact this.trans hab

--0ã¯æœ€å°å…ƒ
theorem bot_leA (a : A) : leA (A:=A) (0 : A) a := by
  unfold leA
  simp [zero_add a]

--mul_left
theorem mul_left_mono_leA {a b c : A}
    (hab : leA (A:=A) a b) :
    leA (A:=A) (c * a) (c * b) := by
  unfold leA at hab âŠ¢
  calc
    c * a + c * b = c * (a + b) := (Semiring.left_distrib (R:=A) c a b).symm
    _ = c * b := by
      have := congrArg (fun t => c * t) hab
      simpa using this

end OrderFromAddIdem
end TropicalGeometry

universe u

namespace TropicalGeometry

--cancellative
def Cancellative (A : Type u) [Semiring A] : Prop :=
  âˆ€ â¦ƒa b c : Aâ¦„, a * b = a * c â†’ a = (0 : A) âˆ¨ b = c

namespace Cancellative

variable {A : Type u} [Semiring A]

--ã“ã‚“ã”ä¾¿åˆ©ã«ãªã‚‹(ã‚‰ã—ã„)è£œé¡Œ
theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a â‰  (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  Â· exact (ha hzero).elim
  Â· exact hbc

end Cancellative

end TropicalGeometry

namespace TropicalGeometry

--åˆ†æ¯ãŒ 0 ã§ãªã„çµ„ (a,b)ã®é›†åˆã‚’å®šç¾©
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A Ã— A // p.2 â‰  (0 : A) }

namespace FracCarrier

variable {A : Type u} [Semiring A]

-- åˆ†å­ / åˆ†æ¯ã‚’è¨˜å·ã§çŸ­ç¸®
def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b â‰  0) :
    num (A:=A) âŸ¨(a,b), hbâŸ© = a := rfl
@[simp] lemma den_mk (a b : A) (hb : b â‰  0) :
    den (A:=A) âŸ¨(a,b), hbâŸ© = b := rfl
@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p â‰  0 := p.2

--åŒå€¤é–¢ä¿‚
def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

--åå°„å¾‹
@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

--å¯¾ç§°å¾‹
@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

--æ¨ç§»å¾‹
lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q r â†’ Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q â‰  (0 : A) := den_ne_zero (A:=A) q

  -- â‘  (hpq) ã‚’å³ã‹ã‚‰ r.den ã§æ›ã‘ã€å½¢ã‚’ q.den * (p.num * r.den) = r.den * (q.num * p.den)ã«æ•´ãˆã‚‹
  have h1' :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    calc
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
          = (num (A:=A) p * den (A:=A) q) * den (A:=A) r := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) p) * den (A:=A) r := t
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- â‘¡ (hqr) ã‚’å³ã‹ã‚‰ p.den ã§æ›ã‘ã€å½¢ã‚’ q.den * (r.num * p.den) = r.den * (q.num * p.den)ã«æ•´ãˆã‚‹
  have h2' :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    calc
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
          = (num (A:=A) r * den (A:=A) q) * den (A:=A) p := by ac_rfl
      _ = (num (A:=A) q * den (A:=A) r) * den (A:=A) p := t.symm
      _ = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by ac_rfl

  -- â‘¢ åŒã˜å³è¾ºã‚’çµŒç”±ã—ã¦ q.den ã‚’å·¦ã‹ã‚‰æ¶ˆå»
  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1'.trans h2'.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4


-- Lem2.1.9-aã®Relã¯ï¼ˆcancellativeã®ä¸‹ã§ï¼‰åŒå€¤é–¢ä¿‚ã«ãªã‚‹ã€‚  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    âŸ¨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) âŸ©

end FracCarrier
end TropicalGeometry

#min_imports
