/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
--Def2.1.1（宋先生の定義に忠実に従った(可換な)Semiringの定義）
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : ∀ a : R, a * 0 = 0
  zero_mul : ∀ a : R, 0 * a = 0
  left_distrib  : ∀ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

--ついでに半体を定義
class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) ≠ 1)
  (exists_inv  : ∀ {a : R}, a ≠ 0 → ∃ b : R, a * b = 1)

--加法的冪等の定義
def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  ∀ a : R, a + a = a

--Ex2.1.2 𝔹=({0,-∞},max,+)は半体である
inductive 𝔹 : Type
| negInf
| zero

/-
つけておくといいことがあるとGPTからアドバイスあり
deriving DecidableEq, Repr, Inhabited
-/


instance : Zero 𝔹 := ⟨𝔹.negInf⟩
instance : One  𝔹 := ⟨𝔹.zero⟩

instance : Add 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zero⟩

instance : Mul 𝔹 :=
  ⟨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInf⟩

/- 加法について可換モノイド -/
instance : AddCommMonoid 𝔹 where
  add := (·+·)
  zero := (0 : 𝔹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

/- 乗法について可換モノイド -/
instance : CommMonoid 𝔹 where
  mul := (·*·)
  one := (1 : 𝔹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1) (fun _ s => s * a)

--Def2.1.3(半環準同型の定義)
universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 → S2
  map_add : ∀ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : ∀ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

--今後関数として使えるようにする。これがないといちいちf.toFun xと書かなきゃいけなくなる。
instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 → S2) where
  coe f := f.toFun

--simpを使えるように
@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

/-- 恒等準同型 -/
def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl

/-- 準同型の合成 -/
def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    -- g (f (a + b)) → g (f a + f b) → g (f a) + g (f b)
    simp
  map_mul := by
    intro a b
    -- g (f (a * b)) → g (f a * f b) → g (f a) * g (f b)
    simp
  map_zero := by
    -- g (f 0) → g 0 → 0
    simp
  map_one := by
    -- g (f 1) → g 1 → 1
    simp

end SemiringHomomorphism

--S₁代数の定義
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Ψ : SemiringHomomorphism B A) : Algebra A B :=
  ⟨Ψ⟩

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom

--simp用
@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y := by
  simp 

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y := by
  simp

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) := by
  simp

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) := by
  simp

end Algebra

-- A-代数準同型の定義
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))  -- f : A → X
    = (Algebra.algebraMap (A:=Y) (B:=A))  -- g : A → Y

namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 可換図式の **点ごと**版。 -/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g に a を適用
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) h.comm

end AlgHom


/-- A-代数準同型の**存在**を言う命題（Prop）：
    既存の `[Algebra X A]` と `[Algebra Y A]` のもとで
    「`∃ Ψ, g = Ψ ∘ f`」を主張する。 -/
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  ∃ (Ψ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Ψ
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

/-- 3引数の存在命題のための**専用スコープ記法**。
    `open scoped TGAlgRel` で `AlgRel A X Y` と書ける。 -/
scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 具体的な Ψ と可換性から、存在命題を導入。 -/
theorem intro
  (Ψ : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Ψ
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  ⟨Ψ, h⟩

/-- 存在命題から **ひとつ**の Ψ を（選択で）取り出す。 -/
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

/-- 取り出した Ψ は三角形を可換にする。 -/
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

/-- 可換性の点ごと版。 -/
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- `comm` を取り出して `congrArg` を適用するだけ
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (φ : SemiringHomomorphism A Y) => φ a) hc

end AlgebraRel

-- A-代数同型（A-algebra isomorphism）
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- 互いに逆
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- 同型の順方向の底の準同型を取り出す（記号短縮用）。 -/
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
/-- 同型の逆方向の底の準同型を取り出す（記号短縮用）。 -/
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

/-- 左逆（点ごと版）：`e.inv ∘ e` は恒等。 -/
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- `left_inv : comp inv to = id` に `x` を適用
  exact congrArg (fun (φ : SemiringHomomorphism X X) => φ x) e.left_inv

/-- 右逆（点ごと版）：`e ∘ e.inv` は恒等。 -/
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- `right_inv : comp to inv = id` に `y` を適用
  exact congrArg (fun (φ : SemiringHomomorphism Y Y) => φ y) e.right_inv

/-- 対称性（逆同型）。 -/
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom    := e.invHom
  invHom   := e.toHom
  left_inv := e.right_inv
  right_inv := e.left_inv

end AlgIso


end TropicalGeometry




