/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : âˆ€ a : R, a * 0 = 0
  zero_mul : âˆ€ a : R, 0 * a = 0
  left_distrib  : âˆ€ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c

class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) â‰  1)
  (exists_inv  : âˆ€ {a : R}, a â‰  0 â†’ âˆƒ b : R, a * b = 1)

def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  âˆ€ a : R, a + a = a

inductive ğ”¹ : Type
| negInf
| zero

instance : Zero ğ”¹ := âŸ¨ğ”¹.negInfâŸ©
instance : One  ğ”¹ := âŸ¨ğ”¹.zeroâŸ©

instance : Add ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zeroâŸ©

instance : Mul ğ”¹ :=
  âŸ¨fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInfâŸ©

instance : AddCommMonoid ğ”¹ where
  add := (Â·+Â·)
  zero := (0 : ğ”¹)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0 : ğ”¹) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

instance : CommMonoid ğ”¹ where
  mul := (Â·*Â·)
  one := (1 : ğ”¹)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1 : ğ”¹) (fun _ s => s * a)

instance : Semiring ğ”¹ where
  mul_zero := by
    intro a
    cases a <;> rfl
  zero_mul := by
    intro a
    cases a <;> rfl
  left_distrib := by
    intro a b c
    cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c
    cases a <;> cases b <;> cases c <;> rfl

instance : Semifield ğ”¹ where
  zero_ne_one := by
    intro h
    cases h
  exists_inv := by
    intro a ha
    cases a with
    | negInf =>
        cases (ha rfl)
    | zero =>
        refine âŸ¨(1 : ğ”¹), ?_âŸ©
        rfl

universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 â†’ S2
  map_add : âˆ€ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : âˆ€ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 â†’ S2) where
  coe f := f.toFun

@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl

def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
      _ = g (f a) + g (f b) := by 
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism

class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Î¨ : SemiringHomomorphism B A) : Algebra A B :=
  âŸ¨Î¨âŸ©

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'

end Algebra

structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  âˆƒ (Î¨ : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Î¨
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y

namespace AlgebraRel
variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]


noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H

@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

end AlgebraRel

structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : ğ”¹) + (1 : ğ”¹)) = (1 : ğ”¹) := rfl


def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ğ”¹ A :=
{ toFun := fun x =>
    match x with
    | ğ”¹.negInf => 0
    | ğ”¹.zero   => 1

  map_add := by
    intro x y
    cases x <;> cases y <;> simp
    exact (h (1 : A)).symm

  map_mul := by
    intro x y
    cases x <;> cases y 
    exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    exact (one_mul (1 : A)).symm,

  map_zero := rfl,

  map_one  := rfl }

--ä½¿ç”¨
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A â†” Nonempty (Algebra A ğ”¹) := by
  constructor
  Â· intro h
    exact âŸ¨Algebra.ofHom (boolHomOfAddIdem A h)âŸ©

  Â· intro hAlg
    rcases hAlg with âŸ¨instâŸ©
    let Ïˆ : SemiringHomomorphism ğ”¹ A := inst.hom
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := Ïˆ.map_add (1 : ğ”¹) (1 : ğ”¹)
      have h1 : Ïˆ 1 = Ïˆ 1 + Ïˆ 1 := by
        simpa [B_one_add_one] using h0
      simpa [Ïˆ.map_one] using h1
    intro a
    have hmul : a * 1 = a * 1 + a * 1 := by
      simpa [â† h11A] using (Semiring.left_distrib (R:=A) a 1 1)
    simpa [mul_one] using hmul.symm

def Cancellative (A : Type u) [Semiring A] : Prop :=
  âˆ€ (a b c : A), a * b = a * c â†’ a = (0 : A) âˆ¨ b = c

namespace Cancellative
variable {A : Type u} [Semiring A]

theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a â‰  (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  Â· exact (ha hzero).elim
  Â· exact hbc

end Cancellative

--åˆ†æ¯ãŒ 0 ã§ãªã„çµ„ (a,b)ã®é›†åˆã‚’å®šç¾©ã€‚//ã¯å‰ã«æ›¸ã‹ã‚ŒãŸæƒ…å ±ã«æ¡ä»¶ã‚’ä»˜ã‘åŠ ãˆã‚‹éš›ã«ç”¨ã„ã‚‰ã‚Œã‚‹è¡¨è¨˜æ³•ã€‚ä»Šå›ã¯p(çœç•¥ã•ã‚Œã¦ã„ã‚‹ãŒæ­£ã—ãã¯p.1ï¼‰ã«p.2(p.1ã®äºŒã¤ç›®ã®å…ƒã«å¯¾ã™ã‚‹æ¡ä»¶ãªã®ã§æ­£ç¢ºã«ã¯p.1.2)ã®æ¡ä»¶ã‚’ä»˜ã‘ãã‚ãˆã¦ã„ã‚‹ã€‚
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A Ã— A // p.2 â‰  (0 : A) }

namespace FracCarrier
variable {A : Type u} [Semiring A]

def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b â‰  0) :
    num (A:=A) âŸ¨(a,b), hbâŸ© = a := rfl

@[simp] lemma den_mk (a b : A) (hb : b â‰  0) :
    den (A:=A) âŸ¨(a,b), hbâŸ© = b := rfl

@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p â‰  0 := p.2

def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q â†’ Rel (A:=A) q r â†’ Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q â‰  (0 : A) := den_ne_zero (A:=A) q

  have h1 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    grind

  have h2 :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    grind

  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1.trans h2.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4
  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    âŸ¨ (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) âŸ©

end FracCarrier

open Classical
section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

def Q : Type u := Quotient (FracCarrier.setoid (A:=A) hC)

def Q.mk (a b : A) (hb : b â‰  0) : Q (A:=A) hC :=
  Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(a,b), hbâŸ©

structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val â‰  0

namespace Q

def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

open Classical

section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

namespace FracCarrier

lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den â‰  0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 ã‹ã‚‰ p.den * q.den = p.den * 0 ã‚’å¾—ã‚‹
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _ --_ã¯p.den
    exact h.trans hz.symm
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

def addRep (hC : Cancellative A) (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©
 
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  âŸ¨ (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q âŸ©

lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  unfold Rel addRep
  have Hâ‚€ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by 
            simpa using Hâ‚€
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by 
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl 
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by 
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by 
            have Hâ‚ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            simpa [mul_comm, mul_left_comm, mul_assoc] using Hâ‚.symm

lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let addCoreâ‚ :
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    fun p =>
     Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let addCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      (fun p => addCoreâ‚ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact addCoreâ‚‚ x y

noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCoreâ‚ :
      FracCarrier A â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCoreâ‚‚ : Q (A:=A) hC â†’ (Q (A:=A) hC â†’ Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCoreâ‚ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCoreâ‚‚ x y

namespace Q
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

@[simp] lemma add_mk (p q : FracCarrier A) :
  Q.add (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.addRep (A:=A) hC p q) := rfl

@[simp] lemma mul_mk (p q : FracCarrier A) :
  Q.mul (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.mulRep (A:=A) hC p q) := rfl

end Q
end QAddMul


open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  --1â‰ 0 

def Q.zero : Q (A:=A) hC :=
  Q.mk (A:=A) hC 0 1 (by simp[NeZero.ne (1 : A)])

def Q.one  : Q (A:=A) hC :=
  Q.mk (A:=A) hC 1 1 (by simp[NeZero.ne (1 : A)])

instance : Zero (Q (A:=A) hC) := âŸ¨Q.zero (A:=A) hCâŸ©
instance : One  (Q (A:=A) hC) := âŸ¨Q.one  (A:=A) hCâŸ©

noncomputable instance instOfNat0Q :
    OfNat (Q (A:=A) hC) 0 where
  ofNat := (Zero.zero : Q (A:=A) hC)

noncomputable instance instOfNat1Q :
    OfNat (Q (A:=A) hC) 1 where
  ofNat := (One.one : Q (A:=A) hC)

noncomputable instance : Add  (Q (A:=A) hC) := âŸ¨Q.add (A:=A) hCâŸ©
noncomputable instance : Mul  (Q (A:=A) hC) := âŸ¨Q.mul (A:=A) hCâŸ©
end QSemiring

namespace FracCarrier

variable {hC}
variable {A : Type u} [Semiring A]

lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  unfold Rel addRep num den
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          ac_rfl

lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  unfold Rel addRep
  set a := p.num 
  set b := p.den
  set c := q.num
  set d := q.den
  set e := r.num
  set f := r.den
  let kâ‚ := b * (d * f)
  let kâ‚‚ := (b * d) * f
  have HL1 :
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = ((a*d + c*b) * f) * kâ‚ + (e * (b*d)) * kâ‚ := by
    simpa using
      (Semiring.right_distrib (R:=A) ((a*d + c*b) * f) (e * (b*d)) kâ‚)

  have HL2 :
      ((a*d + c*b) * f) * kâ‚
        = (a*d) * (f * kâ‚) + (c*b) * (f * kâ‚) := by
    have := Semiring.right_distrib (R:=A) (a*d) (c*b) (f * kâ‚)
    simpa [mul_assoc] using this

  have HL :
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := by
    calc
      ((a*d + c*b) * f + e * (b*d)) * kâ‚
          = ((a*d + c*b) * f) * kâ‚ + (e * (b*d)) * kâ‚ := HL1
      _ = ((a*d) * (f * kâ‚) + (c*b) * (f * kâ‚)) + (e * (b*d)) * kâ‚ := by
            simp [HL2]
      _ = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := by
            simp [mul_assoc]
  have HR1 :
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
        = (a * (d*f)) * kâ‚‚ + ((c*f + e*d) * b) * kâ‚‚ := by
    simpa using
      (Semiring.right_distrib (R:=A) (a * (d*f)) ((c*f + e*d) * b) kâ‚‚)

  have HR2 :
      ((c*f + e*d) * b) * kâ‚‚
        = (c*f) * (b * kâ‚‚) + (e*d) * (b * kâ‚‚) := by
    have := Semiring.right_distrib (R:=A) (c*f) (e*d) (b * kâ‚‚)
    simpa [mul_assoc] using this

  have HR :
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
        = a * (d*f) * kâ‚‚ + (c*f) * b * kâ‚‚ + (e*d) * b * kâ‚‚ := by
    calc
      (a * (d*f) + (c*f + e*d) * b) * kâ‚‚
          = (a * (d*f)) * kâ‚‚ + ((c*f + e*d) * b) * kâ‚‚ := HR1
      _ = (a * (d*f)) * kâ‚‚ + ((c*f) * (b * kâ‚‚) + (e*d) * (b * kâ‚‚)) := by
            simp [HR2]
      _ = a * (d*f) * kâ‚‚ + (c*f) * b * kâ‚‚ + (e*d) * b * kâ‚‚ := by
            simp [mul_assoc, add_assoc]

  have k_same : kâ‚ = kâ‚‚ := by
    simp [kâ‚, kâ‚‚, mul_assoc]

  have align :
      a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚
        = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := by 
        simp [k_same, mul_assoc, mul_comm, mul_left_comm]

  calc
    ((a*d + c*b) * f + e * (b*d)) * kâ‚
        = a*d*f*kâ‚ + c*b*f*kâ‚ + e*(b*d)*kâ‚ := HL
    _   = a*(d*f)*kâ‚‚ + (c*f)*b*kâ‚‚ + (e*d)*b*kâ‚‚ := align
    _   = (a * (d*f) + (c*f + e*d) * b) * kâ‚‚ := HR.symm


lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  simp [mul_comm,  mul_assoc]

lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  simp [mul_comm,  mul_assoc]

lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  rcases p with âŸ¨âŸ¨pn, pdâŸ©, hp0âŸ©
  rcases q with âŸ¨âŸ¨qn, qdâŸ©, hq0âŸ©
  rcases r with âŸ¨âŸ¨rn, rdâŸ©, hr0âŸ©

  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  set X : A := pd * qd * (pd * rd) with hX
  set Y : A := pd * (qd * rd) with hY

  have lhs_reassoc :
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
        =
      pn * (qn * rd + rn * qd) * X := by
    have tail_assoc :
        pd * (qd * (pd * rd))
          = pd * qd * (pd * rd) := by
      simp [mul_assoc]
    calc
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
          = pn * ((qn * rd + rn * qd) * (pd * qd * (pd * rd))) := by
              simp [tail_assoc]
      _   = pn * (qn * rd + rn * qd) * (pd * qd * (pd * rd)) := by
              simp [mul_assoc]
      _   = pn * (qn * rd + rn * qd) * X := by
              simp [hX]

  have left_expand :
      pn * (qn * rd + rn * qd) * X = pn * (qn * rd) * X + pn * (rn * qd) * X := by
    have inner :
        (qn * rd + rn * qd) * X = (qn * rd) * X + (rn * qd) * X := by
      have tmp :=
        Semiring.right_distrib (R:=A) (qn * rd) (rn * qd) X
      simpa using tmp
    have tmp2 :=
      Semiring.left_distrib (R:=A) pn ((qn * rd) * X) ((rn * qd) * X)
    simpa [inner, mul_assoc] using tmp2

  have right_expand :
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y
        = pn * qn * (pd * rd) * Y + pn * rn * (pd * qd) * Y := by
    have tmp :=
      Semiring.right_distrib (R:=A) (pn * qn * (pd * rd)) (pn * rn * (pd * qd)) Y
    simpa [mul_assoc] using tmp

  have term1_match :
      pn * (qn * rd) * X = pn * qn * (pd * rd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  have term2_match :
      pn * (rn * qd) * X = pn * rn * (pd * qd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  have rhs_reassoc :
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
        =
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
    calc
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
          =
        ((pn * qn * (pd * rd)) + (pn * rn * (pd * qd)))
          * (pd * (qd * rd)) := by
            simp [mul_assoc]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
            simp [hY]

  have mid_chain :
      pn * (qn * rd + rn * qd) * X
        =
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := by
    calc
      pn * (qn * rd + rn * qd) * X
          =
        pn * (qn * rd) * X + pn * (rn * qd) * X := left_expand
      _ =
        pn * qn * (pd * rd) * Y
        + pn * rn * (pd * qd) * Y := by
          simp [term1_match, term2_match]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y :=
          (right_expand.symm)
      _ =
        (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := rhs_reassoc.symm

  grind

lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by

  rcases p with âŸ¨âŸ¨pn, pdâŸ©, hp0âŸ©
  rcases q with âŸ¨âŸ¨qn, qdâŸ©, hq0âŸ©
  rcases r with âŸ¨âŸ¨rn, rdâŸ©, hr0âŸ©

  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  set X : A := (pd * rd) * (qd * rd) with hX
  set Y : A := (pd * qd) * rd with hY

  have lhs_reassoc :
      ((pn * qd + qn * pd) * rn) * X
        =
      (pn * qd + qn * pd) * rn * X := by
    simp [X, mul_assoc]

  have left_expand :
      (pn * qd + qn * pd) * rn * X
        =
      (pn * qd) * rn * X + (qn * pd) * rn * X := by
    have step1 :
        (pn * qd + qn * pd) * rn
          =
        (pn * qd) * rn + (qn * pd) * rn := by
      simpa using
        Semiring.right_distrib (R:=A) (pn * qd) (qn * pd) rn
    calc
      (pn * qd + qn * pd) * rn * X
          = ((pn * qd) * rn + (qn * pd) * rn) * X := by
              simp [step1]
      _   = (pn * qd) * rn * X + (qn * pd) * rn * X := by
              simpa [mul_assoc] using
                Semiring.right_distrib (R:=A)
                  ((pn * qd) * rn) ((qn * pd) * rn) X

  have right_expand :
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y
        =
      (pn * rn) * (qd * rd) * Y + (qn * rn) * (pd * rd) * Y := by
    simpa [mul_assoc] using
      Semiring.right_distrib (R:=A)
        ((pn * rn) * (qd * rd)) ((qn * rn) * (pd * rd)) Y

  have term1_match :
      (pn * qd) * rn * X
        =
      (pn * rn) * (qd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  have term2_match :
      (qn * pd) * rn * X
        =
      (qn * rn) * (pd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  have mid_chain :
      (pn * qd + qn * pd) * rn * X
        =
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
    calc
      (pn * qd + qn * pd) * rn * X
          = (pn * qd) * rn * X + (qn * pd) * rn * X := left_expand
      _   = (pn * rn) * (qd * rd) * Y
            + (qn * rn) * (pd * rd) * Y := by
              simp [term1_match, term2_match]
      _   = ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
              simpa [mul_assoc] using right_expand.symm
  grind

end FracCarrier

--11/28

-- Q(A)ã¯å¯æ›ãªåŠ æ³•ãƒ¢ãƒã‚¤ãƒ‰ã§ã‚ã‚‹
section
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

noncomputable instance instAddCommMonoidQ :
    AddCommMonoid (Q (A:=A) hC) where
  add  := (Â· + Â·)
  zero := (0 : Q (A:=A) hC)

  add_assoc := by
    intro x y z 
    refine Quot.induction_on x ?_ 
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.addRep_assoc (A:=A) hC p q r

  zero_add := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Q.add (A:=A) hC (Q.zero (A:=A) hC) (Quot.mk _ p)
        = Quot.mk _ p
    simp [Q.zero]  
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC âŸ¨(0,1), by
          simp[NeZero.ne (1 : A)]âŸ© p)
        p
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm, Semiring.mul_zero]

  add_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Q.add (A:=A) hC (Quot.mk _ p) (Q.zero (A:=A) hC)
        = Quot.mk _ p
    simp [Q.zero]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC p âŸ¨(0,1), by
          simp[NeZero.ne (1 : A)]âŸ©)
        p
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm,Semiring.mul_zero]


  add_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q

  nsmul := fun n x => Nat.recOn n (0 : Q (A:=A) hC) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

end

section QCommMonoid
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  

noncomputable instance : CommMonoid (Q (A:=A) hC) where
  mul := (Â· * Â·)
  one := (1 : Q (A:=A) hC)

  mul_assoc := by
    intro x y z
    refine Quot.induction_on x ?_ 
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.mulRep_assoc (A:=A) hC p q r

  one_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
     Quot.mk (FracCarrier.setoid (A:=A) hC)
          (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), by simp[NeZero.ne (1 : A)]âŸ© p)
     =
     Quot.mk (FracCarrier.setoid (A:=A) hC) p
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(1,1), by
          simp[NeZero.ne (1 : A)]âŸ© p) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp 

  mul_one := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), by
        simp[NeZero.ne (1 : A)]âŸ©) = Quot.mk _ p
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC p âŸ¨(1,1), by
          simp[NeZero.ne (1 : A)]âŸ©) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp

  mul_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q

  npow := fun n x =>
    Nat.recOn n (1 : Q (A:=A) hC) (fun _ s => s * x)

end QCommMonoid

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  

noncomputable instance : Semiring (Q (A:=A) hC) :=
{ (inferInstance : AddCommMonoid (Q (A:=A) hC)),
  (inferInstance : CommMonoid     (Q (A:=A) hC)) with
  mul_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), h10âŸ©)
        = Quot.mk _ âŸ¨(0, 1), h10âŸ©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), h10âŸ©)
        âŸ¨(0, 1), h10âŸ©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp  
    have hR : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hL : a * (0 : A) = 0 := TropicalGeometry.Semiring.mul_zero (R:=A) a
    simp [hL, hR]

  zero_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC âŸ¨(0, 1), h10âŸ© âŸ¨(a, b), hbâŸ©)
        = Quot.mk _ âŸ¨(0, 1), h10âŸ©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC âŸ¨(0, 1), h10âŸ© âŸ¨(a, b), hbâŸ©)
        âŸ¨(0, 1), h10âŸ©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp
    have hL : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hR : (0 : A) * a = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) a
    simp [hL, hR]

  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r

  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r
}
end QSemiring

namespace FracCarrier
 
lemma zero_iff_num_eq_zero
    {A : Type u} [TropicalGeometry.Semiring A]
     (h10 : (1 : A) â‰  0)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p âŸ¨(0, 1), h10âŸ© â†” p.num = 0 := by
  rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
  constructor
  Â· intro h
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at h
    have hz : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    have h1 : a * (1 : A) = 0 := by
      rw [hz] at h
      exact h
    have hm : a * (1 : A) = a := mul_one a
    rw [hm] at h1
    exact h1

  Â· intro hnum
    dsimp [FracCarrier.num] at hnum
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
    rw [hnum]
    have hL : (0 : A) * (1 : A) = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) (1 : A)
    have hR : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    rw [hL, hR]

end FracCarrier


open Classical

lemma nonzero_num_of_ne_zero
    {A : Type u} [TropicalGeometry.Semiring A]
    (hC : Cancellative A) [NeZero (1 : A)]
    {x : Q (A:=A) hC} (hx : x â‰  (0 : Q (A:=A) hC)) :
    âˆƒ p : FracCarrier A, Quot.mk _ p = x âˆ§ p.num â‰  0 := by
  rcases Quot.exists_rep x with âŸ¨p, rflâŸ© 
  by_cases hpn : p.num = 0
  Â· rcases p with âŸ¨âŸ¨a, bâŸ©, hbâŸ©
    have ha : a = 0 := by
      dsimp [FracCarrier.num] at hpn
      exact hpn
    have hRel :
        (FracCarrier.setoid (A:=A) hC).r
          âŸ¨(a, b), hbâŸ©
          âŸ¨(0, 1), (NeZero.ne (1 : A))âŸ© := by
      change FracCarrier.Rel (A:=A)
               âŸ¨(a, b), hbâŸ© âŸ¨(0, 1), NeZero.ne (1 : A)âŸ©
      dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
      rw [ha]
      simp [TropicalGeometry.Semiring.zero_mul]
    have hEq : (Quot.mk _ âŸ¨(a, b), hbâŸ© : Q (A:=A) hC)
             = (0 : Q (A:=A) hC) := Quot.sound hRel
    exact (hx hEq).elim
  Â· exact âŸ¨p, rfl, hpnâŸ©


variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

noncomputable instance : Semifield (Q (A:=A) hC) :=
{ (inferInstance : Semiring (Q (A:=A) hC)) with

  zero_ne_one := by
    intro h01
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    have h01' :
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨((0 : A), (1 : A)), h10âŸ©
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨((1 : A), (1 : A)), h10âŸ© := by
      simpa [Q.zero, Q.one] using h01

    have hRel :
        FracCarrier.Rel (A:=A)
          âŸ¨((0 : A), (1 : A)), h10âŸ©
          âŸ¨((1 : A), (1 : A)), h10âŸ© :=
      Quotient.exact h01'
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at hRel
    have : (0 : A) = 1 := by
      simp at hRel
    exact h10 this.symm

  exists_inv := by
    intro x hx
    let h10 : (1 : A) â‰  0 := (NeZero.ne (1 : A))
    rcases nonzero_num_of_ne_zero (A:=A) (hC:=hC) hx with âŸ¨p, rfl, hpâŸ©
    refine âŸ¨
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨(p.den, p.num), hpâŸ©,
      ?_âŸ©
    change
      Quot.mk (FracCarrier.setoid (A:=A) hC)
        (FracCarrier.mulRep (A:=A) hC p âŸ¨(p.den, p.num), hpâŸ©)
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC) âŸ¨((1 : A), (1 : A)), h10âŸ©
    apply Quotient.sound
    change (p.num * p.den) * (1 : A) = (1 : A) * (p.den * p.num)
    simp[mul_comm]
}


section

variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) [NeZero (1 : A)]


noncomputable def Emb : A â†’ Q (A:=A) hC :=
  fun a => Q.mk (A:=A) hC a 1 (by simp[NeZero.ne (1 : A)])

@[simp] lemma Emb_apply (a : A) :
    Emb (A:=A) hC a
      = Q.mk (A:=A) hC a 1 (by simp[NeZero.ne (1 : A)]) := rfl

lemma Emb_injective : Function.Injective (Emb (A:=A) hC) := by
  intro a b h
  have hmk :
      Quot.mk (FracCarrier.setoid (A:=A) hC)
              âŸ¨(a, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ©
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC)
              âŸ¨(b, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ© := by
    simpa [Emb, Emb_apply] using h
  have hRel :
      FracCarrier.Rel (A:=A)
        âŸ¨(a, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ©
        âŸ¨(b, (1 : A)), by simp [NeZero.ne (1 : A)]âŸ© :=
    Quotient.exact hmk
  dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at hRel
  simpa [mul_one] using hRel

noncomputable def EmbHom :
    SemiringHomomorphism A (Q (A:=A) hC) :=
{ toFun := Emb (A:=A) hC

  map_add := by
    intro a b
    have h10 : (1 : A) â‰  0 := NeZero.ne (1 : A)
    simp [Emb]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        âŸ¨(a + b, 1), h10âŸ©
        (FracCarrier.addRep (A:=A) hC âŸ¨(a, 1), h10âŸ© âŸ¨(b, 1), h10âŸ©)
    unfold FracCarrier.Rel FracCarrier.addRep
           FracCarrier.num FracCarrier.den
    simp [mul_one]

  map_mul := by
    intro a b
    have h10 : (1 : A) â‰  0 := NeZero.ne (1 : A)
    simp [Emb]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        âŸ¨(a * b, 1), h10âŸ©
        (FracCarrier.mulRep (A:=A) hC âŸ¨(a, 1), h10âŸ© âŸ¨(b, 1), h10âŸ©)
    unfold FracCarrier.Rel FracCarrier.mulRep
           FracCarrier.num FracCarrier.den
    simp [mul_one]

  map_zero := by
    change Emb (A:=A) hC 0 = TropicalGeometry.Q.zero (A:=A) hC
    simp [Emb, TropicalGeometry.Q.zero]

  map_one := by
    change Emb (A:=A) hC 1 = TropicalGeometry.Q.one (A:=A) hC
    simp [Emb, TropicalGeometry.Q.one]
}

variable [Algebra A ğ”¹]

noncomputable local instance instAlgebraQ : Algebra (Q (A:=A) hC) ğ”¹ :=
  Algebra.ofHom
    (SemiringHomomorphism.comp
      (EmbHom (A:=A) hC)
      (Algebra.algebraMap (A:=A) (B:=ğ”¹)))

noncomputable def EmbAlgHom : AlgHom ğ”¹ A (Q (A:=A) hC) :=
{ toHom := EmbHom (A:=A) hC
  comm  := by rfl }

theorem theorem2_13 :
    Function.Injective (Emb (A:=A) hC)
      âˆ§ Nonempty (AlgHom ğ”¹ A (Q (A:=A) hC)) := by
  refine âŸ¨Emb_injective (A:=A) hC, ?_âŸ©
  exact âŸ¨EmbAlgHom (A:=A) hCâŸ©



