/-
Copyright (c) 2025 Sasaki Genta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sasaki Genta
-/
import Mathlib

namespace TropicalGeometry
class Semiring (R : Type u) : Type u
  extends AddCommMonoid R, CommMonoid R where
  mul_zero : ‚àÄ a : R, a * 0 = 0
  zero_mul : ‚àÄ a : R, 0 * a = 0
  left_distrib  : ‚àÄ a b c : R , a * (b + c) = a * b + a * c
  right_distrib : ‚àÄ a b c : R, (a + b) * c = a * c + b * c

class Semifield (R : Type u) : Type u
  extends Semiring R where
  (zero_ne_one : (0 : R) ‚â† 1)
  (exists_inv  : ‚àÄ {a : R}, a ‚â† 0 ‚Üí ‚àÉ b : R, a * b = 1)

def AddIdempotent (R : Type*) [Semiring R] : Prop :=
  ‚àÄ a : R, a + a = a

inductive ùîπ : Type
| negInf
| zero

instance : Zero ùîπ := ‚ü®ùîπ.negInf‚ü©
instance : One  ùîπ := ‚ü®ùîπ.zero‚ü©

instance : Add ùîπ :=
  ‚ü®fun a b =>
    match a, b with
    | .negInf, x      => x
    | x,      .negInf => x
    | .zero,  .zero   => .zero‚ü©

instance : Mul ùîπ :=
  ‚ü®fun a b =>
    match a, b with
    | .zero,  .zero   => .zero
    | _,      _       => .negInf‚ü©

instance : AddCommMonoid ùîπ where
  add := (¬∑+¬∑)
  zero := (0 : ùîπ)
  add_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  zero_add := by
    intro a; cases a <;> rfl
  add_zero := by
    intro a; cases a <;> rfl
  add_comm := by
    intro a b; cases a <;> cases b <;> rfl
  nsmul := fun n a => Nat.recOn n (0 : ùîπ) (fun _ s => s + a)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

instance : CommMonoid ùîπ where
  mul := (¬∑*¬∑)
  one := (1 : ùîπ)
  mul_assoc := by
    intro a b c; cases a <;> cases b <;> cases c <;> rfl
  one_mul := by
    intro a; cases a <;> rfl
  mul_one := by
    intro a; cases a <;> rfl
  mul_comm := by
    intro a b; cases a <;> cases b <;> rfl
  npow := fun n a => Nat.recOn n (1 : ùîπ) (fun _ s => s * a)

instance : Semiring ùîπ where
  mul_zero := by
    intro a
    cases a <;> rfl
  zero_mul := by
    intro a
    cases a <;> rfl
  left_distrib := by
    intro a b c
    cases a <;> cases b <;> cases c <;> rfl
  right_distrib := by
    intro a b c
    cases a <;> cases b <;> cases c <;> rfl

instance : Semifield ùîπ where
  zero_ne_one := by
    intro h
    cases h
  exists_inv := by
    intro a ha
    cases a with
    | negInf =>
        cases (ha rfl)
    | zero =>
        refine ‚ü®(1 : ùîπ), ?_‚ü©
        rfl

universe u v w
structure SemiringHomomorphism (S1 : Type u) (S2 : Type v)
  [Semiring S1] [Semiring S2] where
  toFun   : S1 ‚Üí S2
  map_add : ‚àÄ a b : S1, toFun (a + b) = toFun a + toFun b
  map_mul : ‚àÄ a b : S1, toFun (a * b) = toFun a * toFun b
  map_zero : toFun (0 : S1) = (0 : S2)
  map_one  : toFun (1 : S1) = (1 : S2)

namespace SemiringHomomorphism

variable {S1 : Type u} {S2 : Type v} {S3 : Type w}
variable [Semiring S1] [Semiring S2] [Semiring S3]

instance : CoeFun (SemiringHomomorphism S1 S2) (fun _ => S1 ‚Üí S2) where
  coe f := f.toFun

@[simp] lemma map_add' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a + b) = f a + f b :=
  f.map_add a b

@[simp] lemma map_mul' (f : SemiringHomomorphism S1 S2) (a b : S1) :
    f (a * b) = f a * f b :=
  f.map_mul a b

@[simp] lemma map_zero' (f : SemiringHomomorphism S1 S2) :
    f (0 : S1) = (0 : S2) :=
  f.map_zero

@[simp] lemma map_one' (f : SemiringHomomorphism S1 S2) :
    f (1 : S1) = (1 : S2) :=
  f.map_one

def id (S : Type u) [Semiring S] : SemiringHomomorphism S S where
  toFun := fun x => x
  map_add := by intro a b; rfl
  map_mul := by intro a b; rfl
  map_zero := rfl
  map_one := rfl

def comp (g : SemiringHomomorphism S2 S3) (f : SemiringHomomorphism S1 S2) :
    SemiringHomomorphism S1 S3 where
  toFun := fun x => g (f x)
  map_add := by
    intro a b
    calc
      g (f (a + b)) = g (f a + f b) := by
        exact congrArg (fun x => g x) (f.map_add a b) 
        --congrArg„ÅØ‰∏°Ëæ∫„Å´Âêå„ÅòÈñ¢Êï∞„ÇíÈÅ©Áî®„Åó„Å¶„Çà„ÅÑ„Å®„ÅÑ„ÅÜË£úÈ°å„ÄÇf.map_add„ÅÆ‰∏°Ëæ∫„Å´g„ÇíÈÅ©Áî®„Åó„Åü„Å®„ÅÑ„ÅÜ„Åì„Å®
      _ = g (f a) + g (f b) := by --_„ÅØg (f a + f b)
        exact g.map_add (f a) (f b)
  map_mul := by
    intro a b
    calc
      g (f (a * b)) = g (f a * f b) := by
        exact congrArg (fun x => g x) (f.map_mul a b)
      _ = g (f a) * g (f b) := by
        exact g.map_mul (f a) (f b)
  map_zero := by
    calc
      g (f 0) = g 0 := by exact congrArg (fun x => g x) f.map_zero
      _ = 0 := g.map_zero
  map_one := by
    calc
      g (f 1) = g 1 := by exact congrArg (fun x => g x) f.map_one
      _ = 1 := g.map_one




end SemiringHomomorphism
--10/9
--S‚ÇÅ‰ª£Êï∞„ÅÆÂÆöÁæ©
class Algebra (A : Type u) (B : Type v)
  [Semiring A] [Semiring B] : Type (max u v) where
  hom : SemiringHomomorphism B A

namespace Algebra

variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

def ofHom (Œ® : SemiringHomomorphism B A) : Algebra A B :=
  ‚ü®Œ®‚ü©
--semiringhomo„Å´„ÅØÂêçÂâç„ÅÆ„Å§„ÅÑ„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„Åå„ÅÇ„Çã„ÅÆ„Åß„Åù„Çå„ÇíŒ®„Å®Âêç‰ªò„Åë„Çã„ÄÇ

@[reducible] def algebraMap [h : Algebra A B] : SemiringHomomorphism B A :=
  h.hom
--A„Å®B„ÅÆÈñì„Å´ÂøÖ„ÅöÂ≠òÂú®„Åô„ÇãÂçäÁí∞Ê∫ñÂêåÂûã„Çí‰∏Ä„Å§Âèñ„ÇäÂá∫„Åô„Åì„Å®„ÅåÂá∫Êù•„Çã„Çà„ÅÜ„Å´„Å™„Çã„ÄÇreducible„Å´„Åô„Çã„Åì„Å®„ÅßalgeMap„Çí‰Ωø„ÅÜ„Å®Ëá™Âãï„Åßh.hom„ÅÆ„Çà„ÅÜ„Å™ÂøÖ„ÅöÂ≠òÂú®„Åô„ÇãÂçäÁí∞Ê∫ñÂêåÂûã„ÇíÂëº„Å≥Âá∫„Åó„Å¶„Åè„Çå„Çã„ÄÇ

--simpÁî®
variable {A : Type u} {B : Type v} [Semiring A] [Semiring B]

@[simp] lemma map_add [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x + y)
      = algebraMap (A:=A) (B:=B) x + algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_add' x y

@[simp] lemma map_mul [Algebra A B] (x y : B) :
    algebraMap (A:=A) (B:=B) (x * y)
      = algebraMap (A:=A) (B:=B) x * algebraMap (A:=A) (B:=B) y :=
  (algebraMap (A:=A) (B:=B)).map_mul' x y

@[simp] lemma map_zero [Algebra A B] :
    algebraMap (A:=A) (B:=B) 0 = (0 : A) :=
  (algebraMap (A:=A) (B:=B)).map_zero'

@[simp] lemma map_one [Algebra A B] :
    algebraMap (A:=A) (B:=B) 1 = (1 : A) :=
  (algebraMap (A:=A) (B:=B)).map_one'




end Algebra

-- A-‰ª£Êï∞Ê∫ñÂêåÂûã„ÅÆÂÆöÁæ©
structure AlgHom (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom : SemiringHomomorphism X Y
  comm  :
    SemiringHomomorphism.comp toHom
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))
namespace AlgHom

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

/-- ÂèØÊèõÂõ≥Âºè--/
@[simp] lemma comm_apply (h : AlgHom A X Y) (a : A) :
    h.toHom (Algebra.algebraMap (A:=X) (B:=A) a)  --A‚ÜíX(algebraMap)‚ÜíY(h.toHom)„Å®„ÅÑ„ÅÜÂÜôÂÉè„ÅÆÂêàÊàê„Å´a„ÇíÈÅ©Áî®
      = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- h.comm : comp h.toHom f = g „Å´ a „ÇíÈÅ©Áî®
  exact congrArg (fun (œÜ : SemiringHomomorphism A Y) => œÜ a) h.comm
  --congrArg„ÅØ‰∏°Ëæ∫„Å´Âêå„ÅòÈñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Å®„Åç„Å´‰Ωø„ÅÜ„Ç≥„Éû„É≥„Éâ„ÄÇ‰ªäÂõû„ÅØ„Äåa„ÇíÈÅ©Áî®„Åô„Çã„Äç„Å®„ÅÑ„ÅÜ„Åì„Å®Ëá™‰Ωì„ÅåÈñ¢Êï∞„Å´„Å™„Å£„Å¶„ÅÑ„Å¶„ÄÅ„Åù„Çå„Çíh.comm(‰∏ä„ÅÆAlgHom„ÅÆ‰∏≠„Å´„ÅÇ„Çãcomm)

end AlgHom


--A-‰ª£Êï∞Ê∫ñÂêåÂûã„ÅÆÂ≠òÂú®
def AlgebraRel (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Prop :=
  ‚àÉ (Œ® : SemiringHomomorphism X Y),
    SemiringHomomorphism.comp Œ®
      (Algebra.algebraMap (A:=X) (B:=A))
    = (Algebra.algebraMap (A:=Y) (B:=A))

scoped[TGAlgRel] notation "AlgRel " A:arg X:arg Y:arg =>
  TropicalGeometry.AlgebraRel A X Y
  --ÂêçÂâç„ÅÆË°ùÁ™Å„ÇíÈò≤„Åê„Åü„ÇÅ„Å´scoped„Çí„Å§„Åë„Å¶„Åä„Åè„ÄÇ‰ªäÂæå„ÅØopen„ÄÄscoped TGAlgRel„Å®Êõ∏„Åè„Å®TropicalGeometry.AlgebraRel A X Y „ÇíÁúÅÁï•„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çã„ÄÇ(Âà•„Éï„Ç°„Ç§„É´„Åã„Çâ„ÅÆÂèÇÁÖß)„ÇÇÂèØËÉΩ

namespace AlgebraRel

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

--ÂÖ∑‰ΩìÁöÑ„Å™ Œ® „Å®ÂèØÊèõÊÄß(Œ® „Åå„ÅÇ„Å£„Å¶„ÄÅÂèØÊèõÊÄß„ÇÇË®ºÊòé„Åß„Åç„Åü„Å™„ÇâAlgebraRel A X Y„ÅØÂ≠òÂú®„Åó„Åæ„Åô„Çà„Å≠„Äç„Å®„ÅÑ„ÅÜË£úÈ°å)
theorem intro
  (Œ® : SemiringHomomorphism X Y)
  (h : SemiringHomomorphism.comp Œ®
         (Algebra.algebraMap (A:=X) (B:=A))
       = (Algebra.algebraMap (A:=Y) (B:=A))) :
  AlgebraRel A X Y :=
  ‚ü®Œ®, h‚ü©
  --‚àÉ Œ®, P Œ®„Å®„ÅÑ„ÅÜÂΩ¢„ÅÆÂëΩÈ°å„ÄÇ„Çà„Å£„Å¶„ÄÅ‚ü® ‚ü©„ÅßÂÖ∑‰ΩìÁöÑ„Å™ÂÜôÂÉè„Å®‰ªÆÂÆö„Çí„Éö„Ç¢„ÅßÁæÖÂàó„Åô„Çã„Åì„Å®„ÅßÂ≠òÂú®„ÅÆË®ºÊòé„ÅØÂÆå‰∫Ü„Åô„Çã„ÄÇ

--„Å≤„Å®„Å§Œ®„ÇíÂèñ„ÇäÂá∫„Åô„ÄÇ 
noncomputable def psi (H : AlgebraRel A X Y) : SemiringHomomorphism X Y :=
  Classical.choose H
--def„ÅØH„Åã„ÇâÂÖ∑‰ΩìÁöÑ„Å™ÂÜôÂÉèŒ®„ÇíÂèñ„ÇäÂá∫„ÅôÊìç‰Ωú„ÇíË°å„ÅÜ„Åü„ÇÅ„ÅÆÂÆöÁæ©„ÄÇÈÅ∏ÊäûÂÖ¨ÁêÜ„Å´‰æùÂ≠ò„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åßnoncomputable„ÅßÂÆöÁæ©„Åô„Çã„ÄÇ‰Ωø„ÅÜÈöõ„ÅØOpen classical„Å´„Åô„Çå„Å∞„Çà„ÅÑ„ÄÇ

--psiH„ÅßÂèñ„ÇäÂá∫„Åó„ÅüŒ®„ÅåÂõ≥Âºè„ÇíÂèØÊèõ„Å´„Åô„Çã„ÄÇ 
@[simp] theorem comm (H : AlgebraRel A X Y) :
    SemiringHomomorphism.comp (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A))
  = (Algebra.algebraMap (A:=Y) (B:=A)) :=
  Classical.choose_spec H

--ÂèØÊèõÊÄß„ÅÆÁÇπ„Åî„Å®ver
@[simp] theorem comm_apply (H : AlgebraRel A X Y) (a : A) :
    (psi (A:=A) (X:=X) (Y:=Y) H)
      (Algebra.algebraMap (A:=X) (B:=A) a)
  = (Algebra.algebraMap (A:=Y) (B:=A) a) := by
  -- comm„ÅßÂèØÊèõÂõ≥Âºè„ÅÆÈñ¢Êï∞„ÅÆÁ≠âÂºè„ÇíÂèñ„ÇäÂá∫„Åó„Å¶congrArg„Åßa„ÇíÈÅ©Áî®„Åô„Çã„Å†„Åë
  have hc := comm (A:=A) (X:=X) (Y:=Y) H
  exact congrArg (fun (œÜ : SemiringHomomorphism A Y) => œÜ a) hc

end AlgebraRel

-- A-‰ª£Êï∞ÂêåÂûã„ÅÆÂÆöÁæ©
structure AlgIso (A : Type u) (X : Type v) (Y : Type w)
  [Semiring A] [Semiring X] [Semiring Y]
  [Algebra X A] [Algebra Y A] : Type (max u v w) where
  toHom   : AlgHom A X Y
  invHom  : AlgHom A Y X
  -- ‰∫í„ÅÑ„Å´ÈÄÜÔºàAlgHom „ÅÆ„Éï„Ç£„Éº„É´„Éâ toHom „Çí‰∏ÄÂ∫¶„Å†„ÅëÂèñ„ÇäÂá∫„Åó„Å¶‰Ωø„ÅÜÔºâ
  left_inv  :
    SemiringHomomorphism.comp invHom.toHom toHom.toHom
      = SemiringHomomorphism.id X
      --invHom.toHom„Å®toHom.toHom„ÅÆÂêàÊàê„ÅßÊÅíÁ≠âÂÜôÂÉè„Çí‰Ωú„ÇäÂá∫„Åô„ÄÇinvHom„ÅßAlgIso„Åã„ÇâAlgHom„ÇíÂèñ„ÇäÂá∫„Åó„ÄÅtoHom„ÅßAlgHom„Åã„ÇâSemiringhomomorphism„ÇíÂèñ„ÇäÂá∫„ÅôÊµÅ„Çå„ÄÇÔºàAlgHom„Å´„ÇÇÂÆöÁæ©„Åå„ÅÇ„Çã„ÅÆ„Åß„Åì„Çå„ÅØÂÖ•„ÇåÂ≠êÊßãÈÄ†Ôºâ
  right_inv :
    SemiringHomomorphism.comp toHom.toHom invHom.toHom
      = SemiringHomomorphism.id Y

namespace AlgIso

variable {A : Type u} {X : Type v} {Y : Type w}
variable [Semiring A] [Semiring X] [Semiring Y]
variable [Algebra X A] [Algebra Y A]

-- ÂêåÂûã„ÅÆÈ†ÜÊñπÂêë„ÅÆÂ∫ï„ÅÆÊ∫ñÂêåÂûã„ÇíÂèñ„ÇäÂá∫„Åô„ÄÇ 
@[simp] def toAlgHom (e : AlgIso A X Y) : AlgHom A X Y := e.toHom
-- ÂêåÂûã„ÅÆÈÄÜÊñπÂêë„ÅÆÂ∫ï„ÅÆÊ∫ñÂêåÂûã„ÇíÂèñ„ÇäÂá∫„Åô„ÄÇ 
@[simp] def invAlgHom (e : AlgIso A X Y) : AlgHom A Y X := e.invHom

--e.inv ‚àò e„ÅØidentity
@[simp] lemma left_inv_apply (e : AlgIso A X Y) (x : X) :
    e.invHom.toHom (e.toHom.toHom x) = x := by
  -- left_inv : comp inv to = id„Å´x„ÇíÈÅ©Áî®
  exact congrArg (fun (œÜ : SemiringHomomorphism X X) => œÜ x) e.left_inv

--e ‚àò e.inv„ÅØidentity
@[simp] lemma right_inv_apply (e : AlgIso A X Y) (y : Y) :
    e.toHom.toHom (e.invHom.toHom y) = y := by
  -- right_inv : comp to inv = id„Å´y„ÇíÈÅ©Áî®
  exact congrArg (fun (œÜ : SemiringHomomorphism Y Y) => œÜ y) e.right_inv

--ÂØæÁß∞ÊÄß
def symm (e : AlgIso A X Y) : AlgIso A Y X where
  toHom     := e.invHom
  invHom    := e.toHom
  left_inv  := e.right_inv
  right_inv := e.left_inv

end AlgIso

--1 + 1 = 1
@[simp] lemma B_one_add_one : ((1 : ùîπ) + (1 : ùîπ)) = (1 : ùîπ) := rfl


def boolHomOfAddIdem (A : Type u) [Semiring A]
    (h : AddIdempotent A) : SemiringHomomorphism ùîπ A :=
{ toFun := fun x =>
    match x with
    | ùîπ.negInf => 0
    | ùîπ.zero   => 1

  map_add := by
    intro x y
    cases x <;> cases y <;> simp
    exact (h (1 : A)).symm

  map_mul := by
    intro x y
    cases x <;> cases y 
    exact (Semiring.zero_mul (R:=A) (0 : A)).symm
    exact (Semiring.zero_mul (R:=A) (1 : A)).symm
    exact (Semiring.mul_zero (R:=A) (1 : A)).symm
    exact (one_mul (1 : A)).symm,

  map_zero := rfl,

  map_one  := rfl }

--‰ΩøÁî®
theorem addIdempotent_iff_nonempty_boolAlgebra
    (A : Type u) [Semiring A] :
    AddIdempotent A ‚Üî Nonempty (Algebra A ùîπ) := by
  constructor
  ¬∑ intro h
    exact ‚ü®Algebra.ofHom (boolHomOfAddIdem A h)‚ü©

  ¬∑ intro hAlg
    rcases hAlg with ‚ü®inst‚ü©
    let œà : SemiringHomomorphism ùîπ A := inst.hom
    have h11A : (1 : A) = (1 : A) + (1 : A) := by
      have h0 := œà.map_add (1 : ùîπ) (1 : ùîπ)
      have h1 : œà 1 = œà 1 + œà 1 := by
        simpa [B_one_add_one] using h0
      simpa [œà.map_one] using h1
    intro a
    have hmul : a * 1 = a * 1 + a * 1 := by
      simpa [‚Üê h11A] using (Semiring.left_distrib (R:=A) a 1 1)
    simpa [mul_one] using hmul.symm

def Cancellative (A : Type u) [Semiring A] : Prop :=
  ‚àÄ (a b c : A), a * b = a * c ‚Üí a = (0 : A) ‚à® b = c

namespace Cancellative
variable {A : Type u} [Semiring A]

theorem cancel_left (h : Cancellative A)
    {a b c : A} (ha : a ‚â† (0 : A)) (hmul : a * b = a * c) : b = c := by
  have h' := h (a:=a) (b:=b) (c:=c) hmul
  rcases h' with hzero | hbc
  ¬∑ exact (ha hzero).elim
  ¬∑ exact hbc

end Cancellative

--ÂàÜÊØç„Åå 0 „Åß„Å™„ÅÑÁµÑ (a,b)„ÅÆÈõÜÂêà„ÇíÂÆöÁæ©„ÄÇ//„ÅØÂâç„Å´Êõ∏„Åã„Çå„ÅüÊÉÖÂ†±„Å´Êù°‰ª∂„Çí‰ªò„ÅëÂä†„Åà„ÇãÈöõ„Å´Áî®„ÅÑ„Çâ„Çå„ÇãË°®Ë®òÊ≥ï„ÄÇ‰ªäÂõû„ÅØp(ÁúÅÁï•„Åï„Çå„Å¶„ÅÑ„Çã„ÅåÊ≠£„Åó„Åè„ÅØp.1Ôºâ„Å´p.2(p.1„ÅÆ‰∫å„Å§ÁõÆ„ÅÆÂÖÉ„Å´ÂØæ„Åô„ÇãÊù°‰ª∂„Å™„ÅÆ„ÅßÊ≠£Á¢∫„Å´„ÅØp.1.2)„ÅÆÊù°‰ª∂„Çí‰ªò„Åë„Åè„Çè„Åà„Å¶„ÅÑ„Çã„ÄÇ
def FracCarrier (A : Type u) [Semiring A] : Type u :=
  { p : A √ó A // p.2 ‚â† (0 : A) }

namespace FracCarrier
variable {A : Type u} [Semiring A]

def num (p : FracCarrier A) : A := p.1.1
def den (p : FracCarrier A) : A := p.1.2

@[simp] lemma num_mk (a b : A) (hb : b ‚â† 0) :
    num (A:=A) ‚ü®(a,b), hb‚ü© = a := rfl

@[simp] lemma den_mk (a b : A) (hb : b ‚â† 0) :
    den (A:=A) ‚ü®(a,b), hb‚ü© = b := rfl

@[simp] lemma den_ne_zero (p : FracCarrier A) :
    den (A:=A) p ‚â† 0 := p.2

def Rel (p q : FracCarrier A) : Prop :=
  num (A:=A) p * den (A:=A) q = num (A:=A) q * den (A:=A) p

@[simp] lemma rel_refl (p : FracCarrier A) : Rel (A:=A) p p := by
  simp [Rel]

@[simp] lemma rel_symm {p q : FracCarrier A} :
    Rel (A:=A) p q ‚Üí Rel (A:=A) q p := by
  intro h; simpa [Rel, mul_comm] using h.symm

lemma rel_trans (hC : Cancellative A)
    {p q r : FracCarrier A} :
    Rel (A:=A) p q ‚Üí Rel (A:=A) q r ‚Üí Rel (A:=A) p r := by
  intro hpq hqr
  have hq0 : den (A:=A) q ‚â† (0 : A) := den_ne_zero (A:=A) q

  have h1 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) r) hpq
    grind

  have h2 :
      den (A:=A) q * (num (A:=A) r * den (A:=A) p)
        = den (A:=A) r * (num (A:=A) q * den (A:=A) p) := by
    have t := congrArg (fun x : A => x * den (A:=A) p) hqr
    grind

  have h3 :
      den (A:=A) q * (num (A:=A) p * den (A:=A) r)
        = den (A:=A) q * (num (A:=A) r * den (A:=A) p) :=
    h1.trans h2.symm

  have h4 :
      num (A:=A) p * den (A:=A) r
        = num (A:=A) r * den (A:=A) p :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hq0 h3

  simpa [Rel] using h4
  
def setoid (hC : Cancellative A) : Setoid (FracCarrier A) where
  r := Rel (A:=A)
  iseqv :=
    ‚ü® (by intro p; exact rel_refl (A:=A) p)
    , (by intro p q h; exact rel_symm (A:=A) h)
    , (by intro p q r hpq hqr; exact rel_trans (A:=A) hC hpq hqr) ‚ü©

end FracCarrier

open Classical
section QuotBasic
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

def Q : Type u := Quotient (FracCarrier.setoid (A:=A) hC)

def Q.mk (a b : A) (hb : b ‚â† 0) : Q (A:=A) hC :=
  Quot.mk (FracCarrier.setoid (A:=A) hC) ‚ü®(a,b), hb‚ü©

structure NZDen (A : Type u) [Semiring A] : Type u where
  val     : A
  ne_zero : val ‚â† 0

namespace Q

def ofPair (a : A) (b : NZDen A) : Q (A:=A) hC :=
  Q.mk (A:=A) hC a b.val b.ne_zero

end Q

/-
Lean„Åß„ÅØÊºîÁÆó„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç„ÇíÊï∞ÂÄ§„ÅßÂÆöÁæ©„Åó„Å¶„ÅÑ„Çã„ÄÇ„Åü„Å†„ÄÅÊºîÁÆó„ÇíËá™Áî±„Å´ËøΩÂä†„Åß„Åç„Çã„Çà„ÅÜ„Å´‰ΩôË£ï„Çí„ÇÇ„Å£„Å¶Êï∞ÂÄ§„ÅØÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ
‰æã„ÇíÊåô„Åí„Çã„Å®‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„Å™„Çã„ÄÇ
„Åπ„Åç‰πóÔºöÔºòÔºê
Êéõ„ÅëÁÆóÂâ≤„ÇäÁÆóÔºöÔºóÔºê
Ë∂≥„ÅóÁÆóÂºï„ÅçÁÆóÔºöÔºñÔºï
„Ç§„Ç≥„Éº„É´„ÄÇÂ§ß„Å™„ÇäÂ∞è„Å™„ÇäÔºöÔºïÔºê
„ÅÇ„ÇãÊºîÁÆóÂ≠ê„ÇíÂÆö„ÇÅ„Åü„Å®„Åç„Å´„ÅØ‰∏ÄÁï™Âè≥„Å´Ë®òÂÖ•„Åï„Çå„ÅüÊï∞ÂÄ§„Åå„Åù„ÅÆÊºîÁÆó„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç„Å®„Å™„Çã„ÄÇ‰ª•‰∏ã„ÅÆnotation„Åß„ÅØÔºóÔºë„ÅåÊºîÁÆó„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç„Å®„Å™„Çã„ÄÇ71„Å´„Åó„Åü„ÅÆ„ÅØÂàÜÂ≠ê„ÅØÂâç„Å´„Å§„ÅÑ„ÅüÊéõx„ÅëÁÆó„ÇíÂ∑ª„ÅçËæº„Çì„Åß„Åª„Åó„ÅÑ„Åå„ÄÅÂàÜÊØç„ÅØÂæå„Çç„Å´„Å§„ÅÑ„ÅüÊéõ„ÅëÁÆó„ÇíÂ∑ª„ÅçËæº„ÇÄ„Å®‰∫ãÊïÖÁô∫Áîü„Å´„Å™„Çã„Åü„ÇÅ„ÄÇ
ÊºîÁÆó„ÅÆÂÑ™ÂÖàÂ∫¶„Çí71„Å´„Åô„Çã„Åì„Å®„Åß/„ÅØ
+Ôºà65Ôºâ„Çà„ÇäÂº∑„ÅÑ ‚Üí a / b + c „ÅØ (a / b) + c „Å®Ë™≠„Åæ„Çå„Çã
*Ôºà70Ôºâ„Çà„ÇäÂ∞ë„ÅóÂº∑„ÅÑ ‚Üí a / b * c „ÅØ (a / b) * c „Å®Ë™≠„Åæ„Çå„Çã
^Ôºà80Ôºâ„Çà„ÇäÂº±„ÅÑ ‚Üí a^2 / b „ÅØ (a^2) / b „Å®Ë™≠„Åæ„Çå„Çã
„Å®„Å™„Çã„ÄÇ
‰ª•‰∏ã„ÇΩ„Éº„Çπ
https://leanprover-community.github.io/lt2021/slides/sebastian-lean4-parsers-macros.pdf?utm_source=chatgpt.com
-/

-- „Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖÈôêÂÆö„ÅÆÂàÜÊï∞Ë°®Á§∫„ÅÆÂ∞éÂÖ•„ÄÇ a / b : Q(A,hC) Ôºàb : NZDen AÔºâ _/_
local notation a:70 " / " b:71 =>
  TropicalGeometry.Q.ofPair (A:=A) hC a b

-- open scoped TGFrac„Å®Êõ∏„Åë„Å∞„Å©„Åì„Åß„ÇÇ‰Ωø„Åà„Çã„Çà„ÅÜ„Å´„Åô„ÇãÔºöa /[hC] b Ôºàb : NZDen AÔºâ 
scoped[TGFrac] notation a:70 " /[" hC:71 "] " b:71 =>
  TropicalGeometry.Q.ofPair (A:=_) hC a b

end QuotBasic

open Classical

section QAddMul
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

namespace FracCarrier

-- ÂàÜÊØçÂêåÂ£´„ÅÆÁ©ç„ÅØ 0 „Å´„Å™„Çâ„Å™„ÅÑ„Åì„Å®„ÇíÁ§∫„ÅôË£úÈ°å„ÄÇÔºàCancellative „ÇíÂà©Áî®Ôºâ
lemma den_mul_ne_zero (hC : Cancellative A)
    (p q : FracCarrier A) : p.den * q.den ‚â† 0 := by
  have hb := den_ne_zero (A:=A) p
  have hd := den_ne_zero (A:=A) q
  intro h
  -- h : p.den * q.den = 0 „Åã„Çâ p.den * q.den = p.den * 0 „ÇíÂæó„Çã
  have h' : p.den * q.den = p.den * 0 := by
    have hz : p.den * (0 : A) = 0 := Semiring.mul_zero (R:=A) _ --_„ÅØp.den
    exact h.trans hz.symm
  have : q.den = 0 :=
    TropicalGeometry.Cancellative.cancel_left (A:=A) hC hb h'
  exact hd this

-- (a/b) + (c/d) := (ad + cb) / (bd)  FracCarrier„ÅØ„Éö„Ç¢„Å™„ÅÆ„Åß„ÄÅ‚ü®(ÂàÜÊØç,ÂàÜÂ≠ê),Âà∂Á¥ÑÊù°‰ª∂(ÂàÜÊØç„ÅØÔºê„Åò„ÇÉ„Å™„ÅÑ)‚ü© „Å®„ÅÑ„ÅÜÊñá‰øù„Å´„Å™„Çã„ÄÇ
def addRep (hC : Cancellative A) (p q : FracCarrier A) : FracCarrier A :=
  ‚ü® (p.num * q.den + q.num * p.den, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ‚ü©

-- (a/b) * (c/d) := (ac) / (bd) 
def mulRep (hC : Cancellative A)
    (p q : FracCarrier A) : FracCarrier A :=
  ‚ü® (p.num * q.num, p.den * q.den)
  , den_mul_ne_zero (A:=A) hC p q ‚ü©

-- Âä†Ê≥ï„ÅÆwell-definedÊÄß 
lemma addRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
      -- ÁõÆÊ®ô„ÅØ(p.num*q.den + q.num*p.den)*(p'.den*q'.den) = (p'.num*q'.den + q'.num*p'.den)*(p.den*q.den)
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC p' q') := by
  unfold Rel addRep
  have H‚ÇÄ :=
    Semiring.right_distrib (R:=A)
      (p.num * q.den) (q.num * p.den) (p'.den * q'.den)
  calc
    (p.num * q.den + q.num * p.den) * (p'.den * q'.den)
        = (p.num * q.den) * (p'.den * q'.den)
          + (q.num * p.den) * (p'.den * q'.den) := by --ÂàÜÈÖçÊ≥ïÂâá„ÅÆÈÅ©Áî®
            simpa using H‚ÇÄ
    _ = (p.num * p'.den) * (q.den * q'.den)
        + (q.num * q'.den) * (p.den * p'.den) := by --Êéõ„ÅëÁÆó„ÅÆÈ†ÜÁï™ÂÖ•„ÇåÊõø„Åà
            have L1 :
              (p.num * q.den) * (p'.den * q'.den)
              = (p.num * p'.den) * (q.den * q'.den) := by ac_rfl --assoc„Å®comm„ÇíÈÅ©Áî®„Åó„Åü„ÅÜ„Åà„Åß„ÅÆrfl
            have L2 :
              (q.num * p.den) * (p'.den * q'.den)
              = (q.num * q'.den) * (p.den * p'.den) := by ac_rfl
            simp [L1, L2]
    _ = (p'.num * p.den) * (q'.den * q.den)
        + (q'.num * q.den) * (p'.den * p.den) := by --ÂêÑÊã¨Âºß„ÅÆ‰∏≠„ÇíÂÖ•„ÇåÊõø„Åà„Çã
            have hp' : p.num * p'.den = p'.num * p.den := hp
            have hq' : q.num * q'.den = q'.num * q.den := hq
            have C1 : q.den * q'.den = q'.den * q.den := by ac_rfl
            have C2 : p.den * p'.den = p'.den * p.den := by ac_rfl
            simp [hp', hq', C1, C2]
    _ = (p'.num * q'.den + q'.num * p'.den) * (p.den * q.den) := by --p.den * d.den„ÅßÊã¨„Çä„Å†„Åó
            have H‚ÇÅ :=
              Semiring.right_distrib (R:=A)
                (p'.num * q'.den) (q'.num * p'.den) (p.den * q.den)
            simpa [mul_comm, mul_left_comm, mul_assoc] using H‚ÇÅ.symm

-- ‰πóÊ≥ï„ÅÆwell-definedÊÄß 
lemma mulRep_compat (hC : Cancellative A)
    {p p' q q' : FracCarrier A}
    (hp : Rel (A:=A) p p') (hq : Rel (A:=A) q q') :
      -- ÁõÆÊ®ô„ÅØ (p.num*q.num)*(p'.den*q'.den) = (p'.num*q'.num)*(p.den*q.den) (Rel)
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p' q') := by
  unfold Rel mulRep
  have hp' : p.num * p'.den = p'.num * p.den := hp
  have hq' : q.num * q'.den = q'.num * q.den := hq
  have tL :
      (p.num * q.num) * (p'.den * q'.den)
      = (p.num * p'.den) * (q.num * q'.den) := by ac_rfl
  have tR :
      (p'.num * q'.num) * (p.den * q.den)
      = (p'.num * p.den) * (q'.num * q.den) := by ac_rfl
  calc
    (p.num * q.num) * (p'.den * q'.den)
        = (p.num * p'.den) * (q.num * q'.den) := tL
    _ = (p'.num * p.den) * (q'.num * q.den) := by
          simp [hp', hq']
    _ = (p'.num * q'.num) * (p.den * q.den) := tR.symm

end FracCarrier

--11/14
-- Q(A) ‰∏ä„ÅÆÂä†Ê≥ï

/-
Quot.lift :                      
  (F : Œ± ‚Üí Œ≤) ‚Üí                  -- Èñ¢Êï∞ F
  (‚àÄ{x y}, r x y ‚Üí F x = F y) ‚Üí  -- r„ÅåÂêåÂÄ§„Å™„Çâ F „ÅÆÂÄ§„ÇÇÁ≠â„Åó„ÅÑÔºàwell-defined„ÅÆË®ºÊòéÂøÖË¶ÅÔºâ
  Quot r ‚Üí Œ≤                     -- ÂïÜ Quot r „Åã„Çâ Œ≤ „Å∏„ÅÆÈñ¢Êï∞„ÇíÂæó„Çã
-/

noncomputable def Q.add (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let addCore‚ÇÅ :
      --‰ª•‰∏ã„ÅÆFracCarrier A„ÅØ1„Å§ÁõÆ„ÅÆÂºïÊï∞„ÄÅ„Å§„Åæ„Çäp„ÅÆ„Åì„Å®„Åß„ÅÇ„Çã„ÄÇ„Åô„Å™„Çè„Å°„ÄÅp„ÇíÂõ∫ÂÆö„Åó„Åü„ÅÜ„Åà„Åß„ÅÆq„ÅÆQ(A)‚ÜíQ(A)„Å®„ÅÑ„ÅÜÊºîÁÆó„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Å´„Å™„Çã„ÄÇ
      FracCarrier A ‚Üí (Q (A:=A) hC ‚Üí Q (A:=A) hC) :=
    --fun p => Quot.lift„Åå‰∏ä„ÅÆFracCarrier A‚Üí Q(A)„Å´ÂØæÂøú„ÄÇ
    fun p =>
      --Quot.lift„ÅÆ‰∏≠„ÅÆfun q => Quot.mk„ÅåQ(A)‚ÜíQ(A)„Å´ÂØæÂøú„ÄÇ
      --Èñ¢Êï∞Ôº¶„Å®ÂêåÂÄ§ÔΩû„Å´„Å§„ÅÑ„Å¶„ÄÅaÔΩûb ‚Üí F(a)=F(b)„ÅåÊàê„ÇäÁ´ã„Å§„Å™„Çâ„ÄÅF(c)=F([c])„ÅåÊàê„ÇäÁ´ã„Å§„Å®„ÅÑ„ÅÜ„ÅÆ„ÅåQuot.lift
      Quot.lift
         --q„Åå‰∏é„Åà„Çâ„Çå„Åü„ÇâÊó¢„Å´Â≠òÂú®„Åô„Çãp„ÇíÊåÅ„Å£„Å¶„Åç„Å¶addrep„ÅßË∂≥„ÅóÁÆó„Åó„ÅüÂæå„Å´setoid„ÅßÂêåÂÄ§È°û„Å´„Åô„Çã„ÄÇ
         --„Åô„Å™„Çè„Å°„ÄÅ ‰ª•‰∏ã„ÅÆfun„Åå„ÇÑ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÅØ q ‚Üí [p + q]„Åß„ÅÇ„Çã„ÄÇ
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.addRep (A:=A) hC p q))
        (by
          -- q ~ q' „ÅÆ„Å®„Åçwell-defined„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åô„ÄÇ
          intro q q' hq
          --a„Å®b„ÅåÈñ¢‰øÇr„ÅßÂêåÂÄ§„Å™„Çâ„Å∞„ÄÅÂêåÂÄ§È°û„Å®„Åó„Å¶„ÅØ„Ç§„Ç≥„Éº„É´„ÅÆÈñ¢‰øÇ„Å´„Å™„Çã„ÄÇ
          apply Quot.sound
          exact FracCarrier.addRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let addCore‚ÇÇ : Q (A:=A) hC ‚Üí (Q (A:=A) hC ‚Üí Q (A:=A) hC) :=
    Quot.lift
      --‰ªäÂõûÂÜôÂÉè„ÅØFracCarrier„Åã„Çâp„ÇíÂèñ„Çå„ÅüÊôÇÁÇπ„Åß„ÅÇ„Å®„ÅØaddcore‚ÇÅ„Å´„Åô„Åπ„Å¶‰ªª„Åõ„Çå„Å∞„Çà„ÅÑ„ÄÇ
      (fun p => addCore‚ÇÅ p)
      (by
        -- p ~ p' „Å™„Çâ„ÄÅÈñ¢Êï∞ addCore‚ÇÅ p = addCore‚ÇÅ p'„ÇíÁ§∫„Åô„ÄÇ
        intro p p' hp
        apply funext
        intro y
        -- y„ÅåÂïÜ„ÅÆÂÖÉ„Å™„ÅÆ„Åß‰ª£Ë°®„Å´Êàª„Åó„Å¶„ÅÇ„Åí„Çã
        refine Quot.induction_on y ?_
        intro q
        -- ÁõÆÊ®ô„ÇíÊõ∏„ÅçÊèõ„Åà„Çãaddcore‚ÇÅp [q]Ôºù[p+q]„Å™„ÅÆ„Åß„ÄÅÊ¨°„ÅÆ2„Å§„ÅÆmk„ÅÆÁ≠â„Åó„Åï„ÇíÁ§∫„Åõ„Å∞„Çà„ÅÑ
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.addRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.addRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  -- ‰ª•‰∏ä„Çí‰Ωø„Å£„Å¶ x, y „Å´ÈÅ©Áî®
  exact addCore‚ÇÇ x y


-- Q(A) ‰∏ä„ÅÆ‰πóÊ≥ï 
noncomputable def Q.mul (x y : Q (A:=A) hC) : Q (A:=A) hC :=
by
  let mulCore‚ÇÅ :
      FracCarrier A ‚Üí (Q (A:=A) hC ‚Üí Q (A:=A) hC) :=
    fun p =>
      Quot.lift
        (fun q =>
          Quot.mk (FracCarrier.setoid (A:=A) hC)
            (FracCarrier.mulRep (A:=A) hC p q))
        (by
          intro q q' hq
          apply Quot.sound
          exact FracCarrier.mulRep_compat (A:=A) hC
            (FracCarrier.rel_refl (A:=A) p) hq)

  let mulCore‚ÇÇ : Q (A:=A) hC ‚Üí (Q (A:=A) hC ‚Üí Q (A:=A) hC) :=
    Quot.lift
      (fun p => mulCore‚ÇÅ p)
      (by
        intro p p' hp
        apply funext
        intro y
        refine Quot.induction_on y ?_
        intro q
        change
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p  q)
            =
          Quot.mk (FracCarrier.setoid (A:=A) hC)
              (FracCarrier.mulRep (A:=A) hC p' q)
        apply Quot.sound
        exact FracCarrier.mulRep_compat (A:=A) hC hp
          (FracCarrier.rel_refl (A:=A) q))

  exact mulCore‚ÇÇ x y

namespace Q

variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)

--[p]+[q]=[p+q]
@[simp] lemma add_mk (p q : FracCarrier A) :
  Q.add (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.addRep (A:=A) hC p q) := rfl

--[p][q]=[pq]
@[simp] lemma mul_mk (p q : FracCarrier A) :
  Q.mul (A:=A) hC (Quot.mk _ p) (Quot.mk _ q)
    = Quot.mk _ (FracCarrier.mulRep (A:=A) hC p q) := rfl

end Q


end QAddMul


open Classical

section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  --1‚â†0 

--Q(a)„ÅÆ0„Çí0/1„Å®ÂÆöÁæ©„ÄÇ(ÂàÜÊØç„ÅåÔºê„Åß„Å™„ÅÑË®ºÊòé‰ªò„Åç„Åß)
def Q.zero : Q (A:=A) hC :=
  Q.mk (A:=A) hC 0 1 (by simp[NeZero.ne (1 : A)])

--Q(a)„ÅÆ1„Çí1/1„Å®ÂÆöÁæ©„ÄÇ(ÂàÜÊØç„ÅåÔºê„Åß„Å™„ÅÑË®ºÊòé‰ªò„Åç„Åß)
def Q.one  : Q (A:=A) hC :=
  Q.mk (A:=A) hC 1 1 (by simp[NeZero.ne (1 : A)])

--Q(A)„ÅÆ0„Å®1„Çí‰Ωø„ÅÑ„Åü„ÅÑÈöõ„Å´„Éê„Ç∞„ÅåÂá∫„ÇÑ„Åô„ÅÑ„ÅÆ„Åßinstance„Å®„Åó„Å¶ËøΩÂä†
instance : Zero (Q (A:=A) hC) := ‚ü®Q.zero (A:=A) hC‚ü©
instance : One  (Q (A:=A) hC) := ‚ü®Q.one  (A:=A) hC‚ü©

--OfNat A n„ÅØn„ÇíA„ÅÆË¶ÅÁ¥†„Å®„Åó„Å¶Ë™≠„Åø„Å™„Åï„ÅÑ„Å®„ÅÑ„ÅÜÊåáÁ§∫„Çí‰∏é„Åà„Çãinstance
--(0 : ...)„ÇÑ(1 : ...)„Éê„Ç∞„ÅåÁô∫Áîü„Åó„ÇÑ„Åô„ÅÑ„ÅÆ„Åß„Åù„Çå„ÇíÂõûÈÅø„Åô„Çã„Åü„ÇÅ„ÄÇ
--Zero„ÅåÂ≠òÂú®„Åô„Çã„ÅÆ„Åß„ÄÅQ(A)„ÅÆÔºê„Çízero„ÅßÂëº„Å≥Âá∫„Åô„Å®„ÅÑ„ÅÜÂÜÖÂÆπ„Çí‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„Åß„ÅØËø∞„Åπ„Å¶„ÅÑ„Çã„ÄÇ
noncomputable instance instOfNat0Q :
    OfNat (Q (A:=A) hC) 0 where
  ofNat := (Zero.zero : Q (A:=A) hC)

noncomputable instance instOfNat1Q :
    OfNat (Q (A:=A) hC) 1 where
  ofNat := (One.one : Q (A:=A) hC)

noncomputable instance : Add  (Q (A:=A) hC) := ‚ü®Q.add (A:=A) hC‚ü©
noncomputable instance : Mul  (Q (A:=A) hC) := ‚ü®Q.mul (A:=A) hC‚ü©
end QSemiring

--11/21
namespace FracCarrier

variable {hC}
variable {A : Type u} [Semiring A]

-- Âä†Ê≥ï„ÅÆÂèØÊèõÊÄß„ÄÇÂàÜÊï∞„ÅÆ„Ç§„Ç≥„Éº„É´„ÅØRel„Çí„Åó„ÇÅ„Åõ„Å∞„Çà„ÅÑ„ÄÇ
lemma addRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (addRep (A:=A) hC p q) (addRep (A:=A) hC q p) := by
  unfold Rel addRep num den
  -- ÁõÆÊ®ô„ÅØ
  --(p.num*q.den + q.num*p.den) * (q.den*p.den) = (q.num*p.den + p.num*q.den) * (p.den*q.den)
  calc
    (p.num * q.den + q.num * p.den) * (q.den * p.den)
        = (q.num * p.den + p.num * q.den) * (q.den * p.den) := by
          simp [add_comm]
    _   = (q.num * p.den + p.num * q.den) * (p.den * q.den) := by
          ac_rfl

-- Âä†Ê≥ï„ÅÆÁµêÂêàÊÄß
lemma addRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (addRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC p (addRep (A:=A) hC q r)) := by
  unfold Rel addRep
  --Ë¶ãÈÄö„Åó„Çí„Çà„Åè„Åó„Åü„ÅÑ„ÅÆ„ÅßÂç≥ÂäπÊÄß„ÅÆ„ÅÇ„Çãset
  set a := p.num 
  set b := p.den
  set c := q.num
  set d := q.den
  set e := r.num
  set f := r.den
  --‰Ωø„ÅÑ„Å©„Åì„Çç„ÇíÈÅ∏„Çì„ÅßÈÅ©Áî®„Åó„Åü„ÅÑ„ÅÆ„Åßlet
  let k‚ÇÅ := b * (d * f)
  let k‚ÇÇ := (b * d) * f
  --Ë®ºÊòé„ÅÆÊú¨È°å
  --Â∑¶Ëæ∫„Å´„Å§„ÅÑ„Å¶
  --k‚ÇÅ„ÅÆÂàÜÈÖç
  have HL1 :
      ((a*d + c*b) * f + e * (b*d)) * k‚ÇÅ
        = ((a*d + c*b) * f) * k‚ÇÅ + (e * (b*d)) * k‚ÇÅ := by
    simpa using
      (Semiring.right_distrib (R:=A) ((a*d + c*b) * f) (e * (b*d)) k‚ÇÅ)

  --ÂàÜÈÖçÊ∏¨ ((a*d + c*b) * f) * k‚ÇÅ = (a*d)*(f*k‚ÇÅ) + (c*b)*(f*k‚ÇÅ)
  have HL2 :
      ((a*d + c*b) * f) * k‚ÇÅ
        = (a*d) * (f * k‚ÇÅ) + (c*b) * (f * k‚ÇÅ) := by
    have := Semiring.right_distrib (R:=A) (a*d) (c*b) (f * k‚ÇÅ)
    --mul_assoc„Åß((x+y)*f)*k‚ÇÅ = (x+y)*(f*k‚ÇÅ) „ÅÆÂΩ¢„Å∏ÁµêÂêàÂâá„Åß‰∏¶„Å≥Êõø„Åà„Å¶„Åã„Çâsimp„ÇíÈÅ©Áî®
    simpa [mul_assoc] using this

  --HL1„Å®HL2„ÇíÁµ±Âêà
  have HL :
      ((a*d + c*b) * f + e * (b*d)) * k‚ÇÅ
        = a*d*f*k‚ÇÅ + c*b*f*k‚ÇÅ + e*(b*d)*k‚ÇÅ := by
    calc
      ((a*d + c*b) * f + e * (b*d)) * k‚ÇÅ
          = ((a*d + c*b) * f) * k‚ÇÅ + (e * (b*d)) * k‚ÇÅ := HL1
      _ = ((a*d) * (f * k‚ÇÅ) + (c*b) * (f * k‚ÇÅ)) + (e * (b*d)) * k‚ÇÅ := by
            simp [HL2]
      _ = a*d*f*k‚ÇÅ + c*b*f*k‚ÇÅ + e*(b*d)*k‚ÇÅ := by
            simp [mul_assoc]
  --Âè≥Ëæ∫„Å´„Å§„ÅÑ„Å¶
  --k‚ÇÇ„ÅÆÂàÜÈÖç
  have HR1 :
      (a * (d*f) + (c*f + e*d) * b) * k‚ÇÇ
        = (a * (d*f)) * k‚ÇÇ + ((c*f + e*d) * b) * k‚ÇÇ := by
    simpa using
      (Semiring.right_distrib (R:=A) (a * (d*f)) ((c*f + e*d) * b) k‚ÇÇ)

  --ÂàÜÈÖçÊ∏¨((c*f + e*d) * b) * k‚ÇÇ = (c*f)*(b*k‚ÇÇ) + (e*d)*(b*k‚ÇÇ)
  have HR2 :
      ((c*f + e*d) * b) * k‚ÇÇ
        = (c*f) * (b * k‚ÇÇ) + (e*d) * (b * k‚ÇÇ) := by
    have := Semiring.right_distrib (R:=A) (c*f) (e*d) (b * k‚ÇÇ)
    simpa [mul_assoc] using this

  --HR1„Å®HR2„ÇíÁµ±Âêà
  have HR :
      (a * (d*f) + (c*f + e*d) * b) * k‚ÇÇ
        = a * (d*f) * k‚ÇÇ + (c*f) * b * k‚ÇÇ + (e*d) * b * k‚ÇÇ := by
    calc
      (a * (d*f) + (c*f + e*d) * b) * k‚ÇÇ
          = (a * (d*f)) * k‚ÇÇ + ((c*f + e*d) * b) * k‚ÇÇ := HR1
      _ = (a * (d*f)) * k‚ÇÇ + ((c*f) * (b * k‚ÇÇ) + (e*d) * (b * k‚ÇÇ)) := by
            simp [HR2]
      _ = a * (d*f) * k‚ÇÇ + (c*f) * b * k‚ÇÇ + (e*d) * b * k‚ÇÇ := by
            simp [mul_assoc, add_assoc]

  -- k‚ÇÅ „Å® k‚ÇÇ „ÅØÁµêÂêàÊ∏¨„ÅåÊàê„ÇäÁ´ã„Å§„Å®„Åç„Ç§„Ç≥„Éº„É´„Å®„Å™„Çã
  have k_same : k‚ÇÅ = k‚ÇÇ := by
    simp [k‚ÇÅ, k‚ÇÇ, mul_assoc]

  -- 3È†Ö„ÅÆÂíå„ÅÆ‰∏¶„Å≥Êõø„ÅàÔºàÊã¨Âºß„ÅÆ‰ªò„ÅëÊõø„Åà„ÇíÂê´„ÇÄÔºâ
  have align :
      a*d*f*k‚ÇÅ + c*b*f*k‚ÇÅ + e*(b*d)*k‚ÇÅ
        = a*(d*f)*k‚ÇÇ + (c*f)*b*k‚ÇÇ + (e*d)*b*k‚ÇÇ := by 
        simp [k_same, mul_assoc, mul_comm, mul_left_comm]

  -- „Åæ„Å®„ÇÅ
  calc
    ((a*d + c*b) * f + e * (b*d)) * k‚ÇÅ
        = a*d*f*k‚ÇÅ + c*b*f*k‚ÇÅ + e*(b*d)*k‚ÇÅ := HL
    _   = a*(d*f)*k‚ÇÇ + (c*f)*b*k‚ÇÇ + (e*d)*b*k‚ÇÇ := align
    _   = (a * (d*f) + (c*f + e*d) * b) * k‚ÇÇ := HR.symm


-- ‰πóÊ≥ï„ÅÆÂèØÊèõÊÄß
lemma mulRep_comm (hC : Cancellative A)
    (p q : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC p q) (mulRep (A:=A) hC q p) := by
  unfold Rel mulRep
  simp [mul_comm,  mul_assoc]

-- ‰πóÊ≥ï„ÅÆÁµêÂêàÊÄß
lemma mulRep_assoc (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A) (mulRep (A:=A) hC (mulRep (A:=A) hC p q) r)
                 (mulRep (A:=A) hC p (mulRep (A:=A) hC q r)) := by
  unfold Rel mulRep
  simp [mul_comm,  mul_assoc]

-- Â∑¶ÂàÜÈÖçÂâá(p(q+r)=pq+pr)
lemma left_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC p (addRep (A:=A) hC q r))
      (addRep (A:=A) hC (mulRep (A:=A) hC p q) (mulRep (A:=A) hC p r)) := by
  -- „Åæ„Åö p,q,r „ÅÆ‰∏≠Ë∫´„ÇíÂàÜÊØç„ÄÅÂàÜÂ≠ê„ÄÅÂàÜÊØç‚â†0Êù°‰ª∂„ÅÆ3„Å§„Å´„Éê„É©„Åô
  rcases p with ‚ü®‚ü®pn, pd‚ü©, hp0‚ü©
  rcases q with ‚ü®‚ü®qn, qd‚ü©, hq0‚ü©
  rcases r with ‚ü®‚ü®rn, rd‚ü©, hr0‚ü©

  unfold Rel addRep mulRep
  --‰æã„Åà„Å∞num(pn,pd)„ÅØpn„ÅÆ„Åì„Å®„Åß„ÅÇ„Çã„ÄÇsimp„ÅßË¶ã„ÇÑ„Åô„Åè„Åô„Çã„ÄÇ
  simp [FracCarrier.num, FracCarrier.den]

  -- „Åæ„ÅöÂàÜÊØç„ÅÆÁ©ç„Å´ÂêçÂâç‰ªò„Åë„Åó„Å¶„Åä„Åè
  set X : A := pd * qd * (pd * rd) with hX
  set Y : A := pd * (qd * rd) with hY

  -- (1) Â∑¶Ëæ∫„Çí pn * (qn*rd + rn*qd) * X „Å®„ÅÑ„ÅÜÂΩ¢„Å´„Åô„Çã
  have lhs_reassoc :
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
        =
      pn * (qn * rd + rn * qd) * X := by
    --(pd * (qd * (pd * rd))) „Çí assoc „Åß (pd * qd) * (pd * rd) Âûã„Å´„Åô„Çã
    have tail_assoc :
        pd * (qd * (pd * rd))
          = pd * qd * (pd * rd) := by
      -- (pd * (qd * Z)) = (pd * qd) * Z„Çímul_assoc„ÅßËß£Ê±∫„Åô„Çã
      simp [mul_assoc]
    calc
      pn * ((qn * rd + rn * qd) * (pd * (qd * (pd * rd))))
          = pn * ((qn * rd + rn * qd) * (pd * qd * (pd * rd))) := by
              simp [tail_assoc]
      _   = pn * (qn * rd + rn * qd) * (pd * qd * (pd * rd)) := by
              simp [mul_assoc]
      _   = pn * (qn * rd + rn * qd) * X := by
              simp [hX]

  have left_expand :
      pn * (qn * rd + rn * qd) * X = pn * (qn * rd) * X + pn * (rn * qd) * X := by
    -- „Åæ„Åö (qn*rd + rn*qd) * X „ÅÆÂè≥ÂàÜÈÖç„ÇíÁ§∫„Åô
    have inner :
        (qn * rd + rn * qd) * X = (qn * rd) * X + (rn * qd) * X := by
      have tmp :=
        Semiring.right_distrib (R:=A) (qn * rd) (rn * qd) X
      simpa using tmp
    -- Ê¨°„Å´pn * ((qn * rd) * X + (rn * qd) * X)„ÅÆÂ∑¶ÂàÜÈÖç„ÇíÁ§∫„Åô
    have tmp2 :=
      Semiring.left_distrib (R:=A) pn ((qn * rd) * X) ((rn * qd) * X)
    simpa [inner, mul_assoc] using tmp2

  --Y„ÅÆÂè≥ÂàÜÈÖçÊ∏¨
  have right_expand :
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y
        = pn * qn * (pd * rd) * Y + pn * rn * (pd * qd) * Y := by
    have tmp :=
      Semiring.right_distrib (R:=A) (pn * qn * (pd * rd)) (pn * rn * (pd * qd)) Y
    simpa [mul_assoc] using tmp

  have term1_match :
      pn * (qn * rd) * X = pn * qn * (pd * rd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  have term2_match :
      pn * (rn * qd) * X = pn * rn * (pd * qd) * Y := by
    simp [X, Y, hY, mul_comm, mul_left_comm]

  have rhs_reassoc :
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
        =
      (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
    calc
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd))
          =
        ((pn * qn * (pd * rd)) + (pn * rn * (pd * qd)))
          * (pd * (qd * rd)) := by
            simp [mul_assoc]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y := by
            simp [hY]

  have mid_chain :
      pn * (qn * rd + rn * qd) * X
        =
      (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := by
    calc
      pn * (qn * rd + rn * qd) * X
          =
        pn * (qn * rd) * X + pn * (rn * qd) * X := left_expand
      _ =
        pn * qn * (pd * rd) * Y
        + pn * rn * (pd * qd) * Y := by
          simp [term1_match, term2_match]
      _ =
        (pn * qn * (pd * rd) + pn * rn * (pd * qd)) * Y :=
          (right_expand.symm)
      _ =
        (pn * (qn * (pd * rd)) + pn * (rn * (pd * qd)))
          * (pd * (qd * rd)) := rhs_reassoc.symm

  grind
  --exact lhs_reassoc.trans mid_chain

-- Âè≥ÂàÜÈÖçÂâá
lemma right_distrib_rep (hC : Cancellative A)
    (p q r : FracCarrier A) :
    Rel (A:=A)
      (mulRep (A:=A) hC (addRep (A:=A) hC p q) r)
      (addRep (A:=A) hC (mulRep (A:=A) hC p r) (mulRep (A:=A) hC q r)) := by

  rcases p with ‚ü®‚ü®pn, pd‚ü©, hp0‚ü©
  rcases q with ‚ü®‚ü®qn, qd‚ü©, hq0‚ü©
  rcases r with ‚ü®‚ü®rn, rd‚ü©, hr0‚ü©

  unfold Rel addRep mulRep
  simp [FracCarrier.num, FracCarrier.den]

  set X : A := (pd * rd) * (qd * rd) with hX
  set Y : A := (pd * qd) * rd with hY

  have lhs_reassoc :
      ((pn * qd + qn * pd) * rn) * X
        =
      (pn * qd + qn * pd) * rn * X := by
    simp [X, mul_assoc]

  have left_expand :
      (pn * qd + qn * pd) * rn * X
        =
      (pn * qd) * rn * X + (qn * pd) * rn * X := by
    have step1 :
        (pn * qd + qn * pd) * rn
          =
        (pn * qd) * rn + (qn * pd) * rn := by
      simpa using
        Semiring.right_distrib (R:=A) (pn * qd) (qn * pd) rn
    calc
      (pn * qd + qn * pd) * rn * X
          = ((pn * qd) * rn + (qn * pd) * rn) * X := by
              simp [step1]
      _   = (pn * qd) * rn * X + (qn * pd) * rn * X := by
              simpa [mul_assoc] using
                Semiring.right_distrib (R:=A)
                  ((pn * qd) * rn) ((qn * pd) * rn) X

  have right_expand :
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y
        =
      (pn * rn) * (qd * rd) * Y + (qn * rn) * (pd * rd) * Y := by
    simpa [mul_assoc] using
      Semiring.right_distrib (R:=A)
        ((pn * rn) * (qd * rd)) ((qn * rn) * (pd * rd)) Y

  have term1_match :
      (pn * qd) * rn * X
        =
      (pn * rn) * (qd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  have term2_match :
      (qn * pd) * rn * X
        =
      (qn * rn) * (pd * rd) * Y := by
    simp [X, Y, mul_comm, mul_left_comm]

  have mid_chain :
      (pn * qd + qn * pd) * rn * X
        =
      ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
    calc
      (pn * qd + qn * pd) * rn * X
          = (pn * qd) * rn * X + (qn * pd) * rn * X := left_expand
      _   = (pn * rn) * (qd * rd) * Y
            + (qn * rn) * (pd * rd) * Y := by
              simp [term1_match, term2_match]
      _   = ((pn * rn) * (qd * rd) + (qn * rn) * (pd * rd)) * Y := by
              simpa [mul_assoc] using right_expand.symm
  grind
  --exact lhs_reassoc.trans mid_chain



end FracCarrier

--11/28

-- Q(A)„ÅØÂèØÊèõ„Å™Âä†Ê≥ï„É¢„Éé„Ç§„Éâ„Åß„ÅÇ„Çã
section
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

noncomputable instance instAddCommMonoidQ :
    AddCommMonoid (Q (A:=A) hC) where
  add  := (¬∑ + ¬∑)
  zero := (0 : Q (A:=A) hC)

  add_assoc := by
    intro x y z 
    refine Quot.induction_on x ?_ --induction„Åß‰ª£Ë°®ÂÖÉ„Å´„Å§„ÅÑ„Å¶„ÅÆË≠∞Ë´ñ„Å´ÊåÅ„Å°Ëæº„ÇÄ
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.addRep_assoc (A:=A) hC p q r

  zero_add := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    -- ÁõÆÊ®ô„ÇíQ.add„ÅßË®òËø∞„Åï„Çå„ÅüÂΩ¢„Å´„Åô„Çã„ÄÇ
    change
      Q.add (A:=A) hC (Q.zero (A:=A) hC) (Quot.mk _ p)
        = Quot.mk _ p
    -- Â∑¶Ëæ∫„ÅÆQ.zero„ÇíÂÖ∑‰ΩìÁöÑ„Å™0/1„Å´Â§âÊõ¥
    simp [Q.zero]  
    apply Quot.sound
    -- setoid „ÅÆÈñ¢‰øÇ„ÇíFracCarrier.Rel„ÅÆÂÖ∑‰ΩìÁöÑ„Å™ÂΩ¢„ÄÅ„Åô„Å™„Çè„Å°(0/1) + p ~ p„Å´Â§â„Åà„Çã
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC ‚ü®(0,1), by
          simp[NeZero.ne (1 : A)]‚ü© p)
        p
    -- Â±ïÈñã„Åó„Å¶simp„ÅßÈñâ„Åò„Çã
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm, Semiring.mul_zero]

  add_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Q.add (A:=A) hC (Quot.mk _ p) (Q.zero (A:=A) hC)
        = Quot.mk _ p
    simp [Q.zero]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.addRep (A:=A) hC p ‚ü®(0,1), by
          simp[NeZero.ne (1 : A)]‚ü©)
        p
    unfold FracCarrier.addRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp [mul_comm,Semiring.mul_zero]


  add_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.addRep_comm (A:=A) hC p q

  -- Ëá™ÁÑ∂Êï∞ÂÄç„ÅÆÂÆöÁæ©
  nsmul := fun n x => Nat.recOn n (0 : Q (A:=A) hC) (fun _ s => s + x)
  nsmul_zero := by intro x; rfl
  nsmul_succ := by intro n x; rfl

end




--Q(A)„ÅØÂèØÊèõ„Å™‰πóÊ≥ï„É¢„Éé„Ç§„Éâ„Åß„ÅÇ„Çã
section QCommMonoid
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  

noncomputable instance : CommMonoid (Q (A:=A) hC) where
  mul := (¬∑ * ¬∑)
  one := (1 : Q (A:=A) hC)

  mul_assoc := by --FracCarrier„ÅÆÁ©ç„ÅÆË©±„Å´ÊåÅ„Å°Ëæº„ÇÅ„Å∞mulRep_assoc„ÅßÂÆå‰∫Ü„Åô„Çã„ÄÇ
    intro x y z
    refine Quot.induction_on x ?_ 
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.mulRep_assoc (A:=A) hC p q r

  one_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
     Quot.mk (FracCarrier.setoid (A:=A) hC)
          (FracCarrier.mulRep (A:=A) hC ‚ü®(1,1), by simp[NeZero.ne (1 : A)]‚ü© p)
     =
     Quot.mk (FracCarrier.setoid (A:=A) hC) p
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC ‚ü®(1,1), by
          simp[NeZero.ne (1 : A)]‚ü© p) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp 

  mul_one := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC p ‚ü®(1,1), by
        simp[NeZero.ne (1 : A)]‚ü©) = Quot.mk _ p
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC p ‚ü®(1,1), by
          simp[NeZero.ne (1 : A)]‚ü©) p
    unfold FracCarrier.mulRep FracCarrier.Rel
           FracCarrier.num FracCarrier.den
    simp

  mul_comm := by
    intro x y
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    apply Quot.sound
    exact FracCarrier.mulRep_comm (A:=A) hC p q

  npow := fun n x =>
    Nat.recOn n (1 : Q (A:=A) hC) (fun _ s => s * x)

end QCommMonoid

--Q(A)„ÅØÂçäÁí∞„Åß„ÅÇ„Çã
section QSemiring
variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]  

noncomputable instance : Semiring (Q (A:=A) hC) :=
{ (inferInstance : AddCommMonoid (Q (A:=A) hC)),
  (inferInstance : CommMonoid     (Q (A:=A) hC)) with
  mul_zero := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with ‚ü®‚ü®a, b‚ü©, hb‚ü©
    let h10 : (1 : A) ‚â† 0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ‚ü®(a, b), hb‚ü© ‚ü®(0, 1), h10‚ü©)
        = Quot.mk _ ‚ü®(0, 1), h10‚ü©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC ‚ü®(a, b), hb‚ü© ‚ü®(0, 1), h10‚ü©)
        ‚ü®(0, 1), h10‚ü©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp  
    have hR : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hL : a * (0 : A) = 0 := TropicalGeometry.Semiring.mul_zero (R:=A) a
    simp [hL, hR]

  zero_mul := by
    intro x
    refine Quot.induction_on x ?_
    intro p
    rcases p with ‚ü®‚ü®a, b‚ü©, hb‚ü©
    let h10 : (1 : A) ‚â† 0 := (NeZero.ne (1 : A))
    change
      Quot.mk _ (FracCarrier.mulRep (A:=A) hC ‚ü®(0, 1), h10‚ü© ‚ü®(a, b), hb‚ü©)
        = Quot.mk _ ‚ü®(0, 1), h10‚ü©
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        (FracCarrier.mulRep (A:=A) hC ‚ü®(0, 1), h10‚ü© ‚ü®(a, b), hb‚ü©)
        ‚ü®(0, 1), h10‚ü©
    dsimp [FracCarrier.mulRep, FracCarrier.Rel,
           FracCarrier.num, FracCarrier.den]
    simp
    have hL : (0 : A) * b = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) b
    have hR : (0 : A) * a = 0 := TropicalGeometry.Semiring.zero_mul (R:=A) a
    simp [hL, hR]

  left_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.left_distrib_rep (A:=A) hC p q r

  right_distrib := by
    intro x y z
    refine Quot.induction_on x ?_
    intro p
    refine Quot.induction_on y ?_
    intro q
    refine Quot.induction_on z ?_
    intro r
    apply Quot.sound
    exact FracCarrier.right_distrib_rep (A:=A) hC p q r
}
end QSemiring

namespace FracCarrier

--[a/b] = 0 ‚Üî a = 0 „ÄÇ 
lemma zero_iff_num_eq_zero
    {A : Type u} [TropicalGeometry.Semiring A]
     (h10 : (1 : A) ‚â† 0)
    (p : FracCarrier A) :
    FracCarrier.Rel (A:=A) p ‚ü®(0, 1), h10‚ü© ‚Üî p.num = 0 := by
  rcases p with ‚ü®‚ü®a, b‚ü©, hb‚ü©
  constructor
  ¬∑ intro h
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at h
    have hz : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    have h1 : a * (1 : A) = 0 := by
      rw [hz] at h
      exact h
    have hm : a * (1 : A) = a := mul_one a
    rw [hm] at h1
    exact h1

  ¬∑ intro hnum
    dsimp [FracCarrier.num] at hnum
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
    rw [hnum]
    have hL : (0 : A) * (1 : A) = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) (1 : A)
    have hR : (0 : A) * b = 0 :=
      TropicalGeometry.Semiring.zero_mul (R:=A) b
    rw [hL, hR]

end FracCarrier


open Classical

-- ÈùûÈõ∂ÂÖÉ„ÅØÂàÜÂ≠ê„ÅåÈùûÈõ∂„Å™‰ª£Ë°®„ÇíÊåÅ„Å§ 
lemma nonzero_num_of_ne_zero
    {A : Type u} [TropicalGeometry.Semiring A]
    (hC : Cancellative A) [NeZero (1 : A)]
    {x : Q (A:=A) hC} (hx : x ‚â† (0 : Q (A:=A) hC)) :
    ‚àÉ p : FracCarrier A, Quot.mk _ p = x ‚àß p.num ‚â† 0 := by
  rcases Quot.exists_rep x with ‚ü®p, rfl‚ü© --hx„ÅÆ‰ª£„Çè„Çä„Å´rfl„Å®„Åã„Åè„Å®rfl„ÇíÈÅ©Áî®„Åó„Å¶„Åè„Çå„Çã‰æøÂà©„Å™Ë®òÊ≥ï
  by_cases hpn : p.num = 0
  ¬∑ rcases p with ‚ü®‚ü®a, b‚ü©, hb‚ü©
    have ha : a = 0 := by
      dsimp [FracCarrier.num] at hpn
      exact hpn
    have hRel :
        (FracCarrier.setoid (A:=A) hC).r
          ‚ü®(a, b), hb‚ü©
          ‚ü®(0, 1), (NeZero.ne (1 : A))‚ü© := by
      change FracCarrier.Rel (A:=A)
               ‚ü®(a, b), hb‚ü© ‚ü®(0, 1), NeZero.ne (1 : A)‚ü©
      dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den]
      rw [ha]
      simp [TropicalGeometry.Semiring.zero_mul]
    have hEq : (Quot.mk _ ‚ü®(a, b), hb‚ü© : Q (A:=A) hC)
             = (0 : Q (A:=A) hC) := Quot.sound hRel
    exact (hx hEq).elim
  ¬∑ exact ‚ü®p, rfl, hpn‚ü©


variable {A : Type u} [Semiring A]
variable (hC : Cancellative A)
variable [NeZero (1 : A)]

-- Q(A) „ÅØ Semifield
noncomputable instance : Semifield (Q (A:=A) hC) :=
{ (inferInstance : Semiring (Q (A:=A) hC)) with

  -- 0 ‚â† 1
  zero_ne_one := by
    intro h01
    let h10 : (1 : A) ‚â† 0 := (NeZero.ne (1 : A))
    have h01' :
      Quot.mk (FracCarrier.setoid (A:=A) hC) ‚ü®((0 : A), (1 : A)), h10‚ü©
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC) ‚ü®((1 : A), (1 : A)), h10‚ü© := by
      simpa [Q.zero, Q.one] using h01

    have hRel :
        FracCarrier.Rel (A:=A)
          ‚ü®((0 : A), (1 : A)), h10‚ü©
          ‚ü®((1 : A), (1 : A)), h10‚ü© :=
      Quotient.exact h01'
    dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at hRel
    have : (0 : A) = 1 := by
      simp at hRel
    exact h10 this.symm

  exists_inv := by
    intro x hx
    let h10 : (1 : A) ‚â† 0 := (NeZero.ne (1 : A))
    rcases nonzero_num_of_ne_zero (A:=A) (hC:=hC) hx with ‚ü®p, rfl, hp‚ü©
    --ÈÄÜÂÖÉ„ÅÆÂÄôË£ú„Çíp.den/p.num„Å´„Åô„Çã„ÄÇ„Åù„ÅÆÂ†¥Âêà„ÄÅ?_„ÅÆ(p.den/p.num)*(p.num/p.den)=1„Åå„Ç¥„Éº„É´„Å®„Å™„Çã
    refine ‚ü®
      Quot.mk (FracCarrier.setoid (A:=A) hC) ‚ü®(p.den, p.num), hp‚ü©,
      ?_‚ü©
    -- [p] * [p.den/p.num] = 1 „ÇíÁ§∫„Åô
    change
      Quot.mk (FracCarrier.setoid (A:=A) hC)
        (FracCarrier.mulRep (A:=A) hC p ‚ü®(p.den, p.num), hp‚ü©)
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC) ‚ü®((1 : A), (1 : A)), h10‚ü©
    apply Quotient.sound
    change (p.num * p.den) * (1 : A) = (1 : A) * (p.den * p.num)
    simp[mul_comm]
}


--12/5

-- A „ÅÆÂÖÉ a „ÇíÊó¢Á¥ÑÂàÜÊï∞ a/1 „Å´Âüã„ÇÅËæº„ÇÄÂÜôÂÉè f : A ‚Üí Q(A)„ÅåÂçòÂ∞Ñ„Åß„Åã„Å§ÂçäÁí∞Ê∫ñÂêåÂûã
section

variable {A : Type u} [Semiring A]
variable (hC : Cancellative A) [NeZero (1 : A)]

-- Ëá™ÁÑ∂„Å™Âüã„ÇÅËæº„Åø f : A ‚Üí Q(A)Ôºàa ‚Ü¶ a/1Ôºâ 
noncomputable def Emb : A ‚Üí Q (A:=A) hC :=
  fun a => Q.mk (A:=A) hC a 1 (by simp[NeZero.ne (1 : A)])

@[simp] lemma Emb_apply (a : A) :
    Emb (A:=A) hC a
      = Q.mk (A:=A) hC a 1 (by simp[NeZero.ne (1 : A)]) := rfl

lemma Emb_injective : Function.Injective (Emb (A:=A) hC) := by
  intro a b h
  have hmk :
      Quot.mk (FracCarrier.setoid (A:=A) hC)
              ‚ü®(a, (1 : A)), by simp [NeZero.ne (1 : A)]‚ü©
        =
      Quot.mk (FracCarrier.setoid (A:=A) hC)
              ‚ü®(b, (1 : A)), by simp [NeZero.ne (1 : A)]‚ü© := by
    simpa [Emb, Emb_apply] using h
  have hRel :
      FracCarrier.Rel (A:=A)
        ‚ü®(a, (1 : A)), by simp [NeZero.ne (1 : A)]‚ü©
        ‚ü®(b, (1 : A)), by simp [NeZero.ne (1 : A)]‚ü© :=
    Quotient.exact hmk
  dsimp [FracCarrier.Rel, FracCarrier.num, FracCarrier.den] at hRel
  simpa [mul_one] using hRel

noncomputable def EmbHom :
    SemiringHomomorphism A (Q (A:=A) hC) :=
{ toFun := Emb (A:=A) hC

  map_add := by
    intro a b
    have h10 : (1 : A) ‚â† 0 := NeZero.ne (1 : A)
    simp [Emb]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        ‚ü®(a + b, 1), h10‚ü©
        (FracCarrier.addRep (A:=A) hC ‚ü®(a, 1), h10‚ü© ‚ü®(b, 1), h10‚ü©)
    unfold FracCarrier.Rel FracCarrier.addRep
           FracCarrier.num FracCarrier.den
    simp [mul_one]

  map_mul := by
    intro a b
    have h10 : (1 : A) ‚â† 0 := NeZero.ne (1 : A)
    simp [Emb]
    apply Quot.sound
    change
      FracCarrier.Rel (A:=A)
        ‚ü®(a * b, 1), h10‚ü©
        (FracCarrier.mulRep (A:=A) hC ‚ü®(a, 1), h10‚ü© ‚ü®(b, 1), h10‚ü©)
    unfold FracCarrier.Rel FracCarrier.mulRep
           FracCarrier.num FracCarrier.den
    simp [mul_one]

  map_zero := by
    change Emb (A:=A) hC 0 = TropicalGeometry.Q.zero (A:=A) hC
    simp [Emb, TropicalGeometry.Q.zero]

  map_one := by
    change Emb (A:=A) hC 1 = TropicalGeometry.Q.one (A:=A) hC
    simp [Emb, TropicalGeometry.Q.one]
}


